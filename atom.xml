<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>陈YFの博客(￣▽￣)&quot;</title>
  
  <subtitle>(｡･∀･)ﾉﾞ嗨</subtitle>
  <link href="https://blog.cyfan.top/atom.xml" rel="self"/>
  
  <link href="https://blog.cyfan.top/"/>
  <updated>2022-01-16T12:23:54.551Z</updated>
  <id>https://blog.cyfan.top/</id>
  
  <author>
    <name>CYF</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>欲善其事，必利其器 - 论如何善用ServiceWorker</title>
    <link href="https://blog.cyfan.top/p/c0af86bb.html"/>
    <id>https://blog.cyfan.top/p/c0af86bb.html</id>
    <published>2022-01-16T13:57:45.000Z</published>
    <updated>2022-01-16T12:23:54.551Z</updated>
    
    <content type="html"><![CDATA[<p>ServiceWorker作为前端革命领袖，毫不夸张地被誉为前端黑科技，此文将阐述如何巧妙的使用它来实现一些看起来匪夷所思的事情。</p><a id="more"></a><blockquote><p>从2022/1/8开始，本文将持续更新。当前状态：更新中</p></blockquote><h1 id="起因-巨厦坍塌"><a href="#起因-巨厦坍塌" class="headerlink" title="起因 - 巨厦坍塌"></a>起因 - 巨厦坍塌</h1><p>2021/12/20日，赶在旧年的末尾，一则<code>JSdelivrSSL证书错误</code>缓缓上了v2ex论坛热点。</p><p>此前JSD由于各种原因,曾经不正常了一段时间,所以大家并未对此感冒.正当人们以为这只是JSdelivr每年一度的<code>年经</code>阵痛,发个issue,过一段时间就好了的时候.官方直接爆出大料:<strong>JSDelivr had lost their ICP license</strong></p><p>由此可见,过去的几年里,当人们发现JSD对个人面向国内加速拥有者无与伦比的效果时,各种滥用方式层出不穷:图床曾一阵流行,国内搜索引擎JSdelivr十有八九都是作为图床的,连PicGo插件都出了Github+JSdelivr图床;猛一点的,直接做视频床,甚至为了突破单文件20M限制开发了一套ts切片m3u8一条龙服务;作妖的,托管了不少突破网络审查的脚本和规则集;寻死的,添加了大量的政治宗教敏感,有些甚至不配称为宗教,直接上来就是骗钱的.</p><p>jas并不是没有发布许可条款，但这并不能阻止白嫖大军的进程。在羊毛大军中，只要是你是免费的、公益的，你就要做好被薅爆的结果。但是薅羊毛的前提是羊还活着，倘若羊被薅死了，哪来的羊毛给诸君所薅？</p><p>总之，不管怎样，JSDelivr在决定将节点设置为<code>NearChina</code>，可以肯定的是，在最近很长一段时间内，我们都无法享受国内外双料同时加速的快感，换句话说，jsd在中国就被永久地打入了冷宫。</p><p>视线转向国内，jsd的替代品并不少。早在我写<a href="https://blog.cyfan.top/p/eb490c73.html">图床的千层套路</a>我就试着假想jsd不可用时，我们该用什么。最终我给出的一份较为完美的答案-npm图床，优点无非就是镜像多速度快，许可条款较为宽松，缺点也很明显，需要安装node，用专门的客户端上传。</p><p>那事情就逐渐变得扑朔迷离起来了，我们应当如何选择合理的CDN加速器呢。</p><p>这时候，我想起了前端黑科技Serviceworker。是的，这种情况下使用SW最为巧妙不过，它可以在后台自动优选最佳的CDN，甚至可以用黑中黑<code>Promise.any</code>打出一套漂亮的并行拳。经过两天的完善，我终于写出了一套具有离线可达、绕备、优选CDN、跟踪统计合一的SW脚本。<a href="/sw.js">此博客使用的SW</a></p><p>接下来我将从头开始讲述ServiceWorker的妙用。</p><h1 id="Before-Start"><a href="#Before-Start" class="headerlink" title="Before Start"></a>Before Start</h1><h2 id="What-Is-The-ServiceWorker"><a href="#What-Is-The-ServiceWorker" class="headerlink" title="What Is The ServiceWorker"></a>What Is The ServiceWorker</h2><p>网上对于SW的解释比较模糊，在这里，我将其定义为<code>用户浏览器里的服务器</code>，功能强大到令人发指。是的，接下来的两张图你应该能显著的看到这一差距：</p><p><img src="https://npm.elemecdn.com/chenyfan-os@0.0.0-r5/1.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt="没有ServiceWorker中继，平淡无奇"></p><p><img src="https://npm.elemecdn.com/chenyfan-os@0.0.0-r5/2.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt="ServiceWorker中继，刺激拉满"></p><p>在第一张图中，用户和服务器的关系直的就像电线杆，用户想要什么，服务器就还给他什么。</p><p>第二张图中，用户在被ServiceWorker控制的页面中，无论向哪个服务器发起请求，其过程都会被SW捕获，SW可以仿佛不存在一般单纯地请求服务器，返回原本应该返回的内容【透明代理】；也可以对当前服务器返回的内容进行随意的捏造、修改【请求修改结果】；甚至可以将请求指向完全另一台服务器，返回不是此服务器应该返回的内容【移花接木】；当然，SW也可以直接返回已经存储在本地的文件，甚至离线的时候也能返回【离线访问可达性】。</p><p>由于SW对于用户页面的操纵实在过于强大，因此，它被设计成<code>不可跨域请求</code>、<code>SW脚本必须在同一域名下</code>、<code>必须在HTTPS条件下运行</code>、<code>不可操纵DOM和BOM</code>，同样的，为了避免阻塞和延迟，SW也被特意设计成<code>完全异步的</code>。这些点将会在后面一一讲述。</p><blockquote><p>当然，开发者至上，为了方便本地调试，本机地址<code>localhost</code>和<code>127.0.0.1</code>被浏览器所信任，允许以<code>非HTTPS</code>方式运行serviceworker。</p></blockquote><h2 id="What-Relationship-Between-ServiceWorker-and-PWA"><a href="#What-Relationship-Between-ServiceWorker-and-PWA" class="headerlink" title="What Relationship Between ServiceWorker and PWA"></a>What Relationship Between ServiceWorker and PWA</h2><p>很多人看到sw，第一反应是PWA，即渐进式Web应用。实际上，SW确实是PWA的核心与灵魂，但SW在PWA中起的主要作用是缓存文件，提供给离线访问。并没有完整地发挥出SW的巧妙用法。</p><p>SW可以完全脱离PWA存在，当然，PWA可离不开SW ：）</p><h2 id="And-WorkBox"><a href="#And-WorkBox" class="headerlink" title="And WorkBox ?"></a>And WorkBox ?</h2><p>WorkBox是谷歌开发的一款基于SW的缓存控制器，其主要目的是方便维护PWA。核心依旧是SW，但还是没有SW原本的自定义程度高（</p><h2 id="Why-Not-WorkBox"><a href="#Why-Not-WorkBox" class="headerlink" title="Why Not WorkBox ?"></a>Why Not WorkBox ?</h2><p>首先，博客呢，是没有必要用PWA，有SW做中间件足矣。同时，WorkBox只能简单的缓存数据，并不能做到拦截篡改请求的功能，尤其不能精准把握每一个资源的缓存情况，自定义程度并不高。</p><p><del>自己编写SW，格局就打开了</del></p><h1 id="Start-From-Zero"><a href="#Start-From-Zero" class="headerlink" title="Start From Zero"></a>Start From Zero</h1><h2 id="安装-Install"><a href="#安装-Install" class="headerlink" title="安装 / Install"></a>安装 / Install</h2><p>首先，SW的本质是JS脚本，要安装它必须要经过一个html。毕竟，只有拿到了html，JS才能运行于DOM上下文。</p><p>剥离层层加成，安装的代码只有一行</p><div class="hljs"><pre><code class="hljs JavaScript">navigator.serviceWorker.register(<span class="hljs-string">'/sw.js'</span>)</code></pre></div><p>其中，<code>/sw.js</code>即为ServiceWorker脚本所在，由于安全性，你不能加载跨域的SW。</p><p>例如，当前网页为<code>https://blog.cyfan.top</code>，以下加载位置是允许的</p><div class="hljs"><pre><code class="hljs url">/sw.jshttps://blog.cyfan.top/sw.js</code></pre></div><p>以下加载是不允许的:</p><div class="hljs"><pre><code class="hljs url">http://blog.cyfan.top/sw.js#非HTTPShttps://cyfan.top/sw.js#非同一域名，视为跨域https://119.91.80.151:59996/sw.js#虽然为同一文件,但非同一域名，视为跨域./sw.js#容易造成SW脚本获取路径不一致</code></pre></div><p>在加载前，我们最好判断一下dom是否加载完了，不然安装sw可能会卡dom</p><p>加载完成后，register函数将返回一个<code>Promise</code>，由于前端大多不适用于<code>异步</code>，我们通常以<code>同步</code>的方式<code>.then()</code>和<code>.catch()</code>来获取是否加载成功。</p><p>为了方便判断脚本是否能够加载，我们还要判断navigator里有无sw这一属性<code>&#39;serviceWorker&#39; in navigator</code>。</p><p>由于SW安装后，页面需要刷新后才能交给SW所宰割，同时为了避免浏览器缓存的影响，我通常采用修改<code>search</code>的方式强刷新，而不是通过<code>reload</code>函数。同样的，为了避免刚安装完就刷新的尴尬感，建议用<code>setTimeout</code>延迟一秒刷新。</p><p>简易的完整安装代码如下:</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'load'</span>, <span class="hljs-keyword">async</span> () =&gt; &#123;    navigator.serviceWorker.register(<span class="hljs-string">`/sw.js?time=<span class="hljs-subst">$&#123;<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime()&#125;</span>`</span>)        .then(<span class="hljs-keyword">async</span> reg =&gt; &#123;            <span class="hljs-comment">//安装成功，建议此处强刷新以立刻执行SW</span>            setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;                <span class="hljs-built_in">window</span>.location.search = <span class="hljs-string">`?time=<span class="hljs-subst">$&#123;<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime()&#125;</span>`</span>            &#125;, <span class="hljs-number">1000</span>)        &#125;).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;            <span class="hljs-comment">//安装失败，错误信息会由err传参</span>        &#125;)&#125;);</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p>一刷新，世界就变成了ServiceWorker的瓮中之鳖，接下来，该是SW脚本正式登场的时候了。</p><h2 id="SW安装初始化-Installations"><a href="#SW安装初始化-Installations" class="headerlink" title="SW安装初始化 / Installations"></a>SW安装初始化 / Installations</h2><p>首先，先尴尬的开一个空缓存列表：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> CACHE_NAME = <span class="hljs-string">'ICDNCache'</span>;<span class="hljs-comment">//可以为Cache版本号，但这样可能会导致缓存冗余累积</span><span class="hljs-keyword">let</span> cachelist = [];</code></pre></div><p><code>cachelist</code>里面填写的是预缓存网址，例如在离线时返回的错误页面。此处不宜添加过多网址，此处点名@一下Akilar。</p><p>此处我建议只缓存离线页面展示的内容:</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">let</span> cachelist = [    <span class="hljs-string">'/offline.html'</span>,    <span class="hljs-string">'https://npm.elemecdn.com/chenyfan-os@0.0.0-r6'</span>];</code></pre></div><p>同时监听sw安装时开启此缓存空间：</p><div class="hljs"><pre><code class="hljs js">self.addEventListener(<span class="hljs-string">'install'</span>, <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">installEvent</span>) </span>&#123;    self.skipWaiting();    installEvent.waitUntil(        caches.open(CACHE_NAME)            .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cache</span>) </span>&#123;                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Opened cache'</span>);                <span class="hljs-keyword">return</span> cache.addAll(cachelist);            &#125;)    );&#125;);</code></pre></div><p>由于SW完全没有办法访问DOM，因此对于全局变量，不应当用<code>window</code>，而是<code>self</code>指代自己。</p><p><code>addEventListener</code>这一监听器将监听<code>install</code>,也就是这一段代码只会在脚本首次安装和更新时运行.</p><p><code>skipWaiting</code>的作用是促进新版本sw跳过waiting这一阶段，直接active。</p><blockquote><p>关于SW的状态（waiting，installing，activing）将在文后详细解释。</p></blockquote><p><code>installEvent.waitUntil</code>的作用是直接结束安装过程的等待，待会在后台完成开启缓存空间这一操作。</p><p><code>cache.addAll</code>将会直接获取<code>cachelist</code>里面所有的网址并直接缓存到CacheStorage。如果此处网址过多，将在页面加载时疯狂请求所有的url<del>(例如1k个)</del></p><p>现在，SW初始化已经完成了。接下来，我将讲述SW如何捕获页面的请求。</p><h2 id="捕获请求-Fetch-Event"><a href="#捕获请求-Fetch-Event" class="headerlink" title="捕获请求 / Fetch Event"></a>捕获请求 / Fetch Event</h2><h3 id="添加监听器-AddEventListener"><a href="#添加监听器-AddEventListener" class="headerlink" title="添加监听器 / AddEventListener"></a>添加监听器 / AddEventListener</h3><div class="hljs"><pre><code class="hljs js">self.addEventListener(<span class="hljs-string">'fetch'</span>, <span class="hljs-keyword">async</span> event =&gt; &#123;    event.respondWith(handle(event.request))&#125;);<span class="hljs-keyword">const</span> handle = <span class="hljs-keyword">async</span>(req)=&gt;&#123;    <span class="hljs-comment">//do something</span>&#125;</code></pre></div><p>第一行很简单，绑定一个监听器，监听<code>fetch</code>事件，即网页向服务器获取请求，也就是相当于前端的<code>XMLHTTPRequest</code></p><p><code>event.respondWith</code>即设定返回内容，交给<code>handle</code>主函数处理，传参<code>event.request</code>。这是一个<code>Request</code>对象，里面包含了请求的详细信息。</p><p>接下来，我们开始实战吧。</p><blockquote><p>以下所有内容均针对handle修改</p></blockquote><h3 id="透明代理-Transparent-Proxy"><a href="#透明代理-Transparent-Proxy" class="headerlink" title="透明代理 / Transparent Proxy"></a>透明代理 / Transparent Proxy</h3><p>顾名思义，此实战脚本的作用是SW代理目前的所有流量但不进行修改，仿佛SW不存在一般。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> handle = <span class="hljs-keyword">async</span>(req)=&gt;&#123;    <span class="hljs-keyword">return</span> fetch(req)&#125;</code></pre></div><p><code>fetch</code>这个函数相当于前端的<code>ajax</code>或者<code>XMLHTTPRequest</code>，作用是发起一个请求，获得一个返回值。由于sw不可访问<code>window</code>，在sw中是无法使用<code>ajax</code>或<code>XMLHTTPRequest</code>。同时，<code>fetch</code>是一个异步函数，直接调用它会返回一个<code>Promise</code>。</p><p><code>fetch</code>只能传递<code>Requset</code>对象,而<code>Requset</code>对象有两个参数<code>(url,[option])</code>,第一个参数是网址,第二个参数为<code>Request</code>的内容,例如<code>body</code>或<code>header</code>。</p><p>此脚本适用于卸载<code>ServiceWorker</code>的替换脚本。因为sw在无法拉取新版本时不会主动卸载，依旧保持运行，填入一个透明代理sw即可。</p><p>由于SW冷启动【即页面关闭后SW】处于暂停状态是从硬盘读取的，这会导致第一次请求有少许性能延迟[~10ms]。</p><h3 id="篡改请求-Edit-Requset"><a href="#篡改请求-Edit-Requset" class="headerlink" title="篡改请求 / Edit Requset"></a>篡改请求 / Edit Requset</h3><p>对于一张图片，有时候服务端会变态到让你必须用<code>POST</code>协议才能获得，此时用SW篡改最为方便。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> handle = <span class="hljs-keyword">async</span> (req) =&gt; &#123;    <span class="hljs-keyword">if</span> ((req.url.split(<span class="hljs-string">'/'</span>))[<span class="hljs-number">2</span>].match(<span class="hljs-string">'xxx.com'</span>)) &#123;        <span class="hljs-comment">//xxx.com为图片所在域名</span>        <span class="hljs-keyword">return</span> fetch(req.url, &#123;            <span class="hljs-attr">method</span>: <span class="hljs-string">"POST"</span>        &#125;)    &#125;    <span class="hljs-keyword">return</span> fetch(req)&#125;</code></pre></div><blockquote><p>注意，在ServiceWorker里面，header头是不能修改refferer和origin的，因此此方法无法绕开新浪图床反盗链</p></blockquote><h3 id="篡改响应-Edit-Response"><a href="#篡改响应-Edit-Response" class="headerlink" title="篡改响应 / Edit Response"></a>篡改响应 / Edit Response</h3><p>这个例子会检测返回内容，若为html，将把所有的”TEST”都替换成”SHIT”</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> handle = <span class="hljs-keyword">async</span> (req) =&gt; &#123;    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> fetch(req)    <span class="hljs-keyword">const</span> resp = res.clone()    <span class="hljs-keyword">if</span> (!!resp.headers.get(<span class="hljs-string">'content-type'</span>)) &#123;        <span class="hljs-keyword">if</span> (resp.headers.get(<span class="hljs-string">'content-type'</span>).includes(<span class="hljs-string">'text/html'</span>)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Response((<span class="hljs-keyword">await</span> resp.text()).replace(<span class="hljs-regexp">/TEST/g</span>, <span class="hljs-string">'SHIT'</span>), &#123;                <span class="hljs-attr">headers</span>: resp.headers,                <span class="hljs-attr">status</span>: resp.status            &#125;)        &#125;    &#125;    <span class="hljs-keyword">return</span> resp&#125;</code></pre></div><p><code>const resp = res.clone()</code>由于<code>Response</code>的<code>body</code>一旦被读取，这个<code>body</code>就会被锁死，再也无法读取。<code>clone()</code>能够创造出响应的副本用于处理。</p><p><code>resp.headers.get(&#39;content-type&#39;)</code>通过读取响应的头，判断是否包含<code>text/html</code>，如果是，将响应以<code>text()</code>异步流的方式读取，然后正则替换掉响应内容，并还原头和响应Code。</p><p>返回的内容必须是<code>Response</code>对象，所以<code>new Response</code>构建一个新对象，并直接返回。不匹配html头将直接原封不动地透明代理。</p><h3 id="移花接木-Graft-Request-To-Another-Server"><a href="#移花接木-Graft-Request-To-Another-Server" class="headerlink" title="移花接木 / Graft Request To Another Server"></a>移花接木 / Graft Request To Another Server</h3><p><code>unpkg.zhimg.com</code>是<code>unpkg.com</code>的镜像网站。此脚本将会把所有的<code>unpkg.com</code>流量直接拦截到<code>unpkg.zhimg.com</code>，用于中国大陆内CDN加速。</p><p>由于npm镜像固定为GET请求方式并且没有其他鉴权需求，所以我们没有必要还原<code>Request</code>其他数据。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> handle = <span class="hljs-keyword">async</span> (req) =&gt; &#123;    <span class="hljs-keyword">const</span> domain = req.url.split(<span class="hljs-string">'/'</span>)[<span class="hljs-number">2</span>];    <span class="hljs-keyword">if</span> (domain.match(<span class="hljs-string">"unpkg.com"</span>)) &#123;        <span class="hljs-keyword">return</span> fetch(req.url.replace(<span class="hljs-string">"https://unpkg.com"</span>, <span class="hljs-string">"https://zhimg.unpkg.com"</span>));    &#125;    <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> fetch(req)    &#125;&#125;</code></pre></div><p><code>domain.match</code>捕获请求中是否有待替换域名，检查出来后直接<code>replace</code>掉域名，如果没有匹配到，直接透明代理走掉。</p><h3 id="并行请求-Request-Parallelly"><a href="#并行请求-Request-Parallelly" class="headerlink" title="并行请求 / Request Parallelly"></a>并行请求 / Request Parallelly</h3><p>SW中又一大黑科技隆重登场=&gt;<code>Promise.any</code>，这个函数拥有另外两个衍生兄弟<code>Promise.all</code>&amp;<code>Promise.race</code>。下面我将简单介绍这三种方式</p><h4 id="Promose-all"><a href="#Promose-all" class="headerlink" title="Promose.all"></a>Promose.all</h4><p>当列表中所有的<code>Promise</code>都<code>resolve</code>[即成功]后，这个函数才会返回<code>resolve</code>，只要有一个返回<code>reject</code>，整个函数都会<code>reject</code>。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">Promise</span>.all([    fetch(<span class="hljs-string">'https://unpkg.com/jquery'</span>),    fetch(<span class="hljs-string">'https://cdn.jsdelivr.net/npm/jquery'</span>),    fetch(<span class="hljs-string">'https://unpkg.zhimg.com/jquery'</span>)])</code></pre></div><p>这个函数将会请求三个网址，当每一个网址都链接联通后，整个函数将会返回一个列表：</p><div class="hljs"><pre><code class="hljs js">[Response1,Response2,Response3]</code></pre></div><p>当任何一个<code>fetch</code>失败[即<code>reject</code>]后，整个<code>Promise.any</code>函数都会直接<code>reject</code>并报错。</p><p>此函数可以检测网络连通性，由于采取并行处理，相比以前的循环效率要高不少。</p><p>这是一段检测国内国外网络连通性的测试。</p><p>没有采用<code>Promise.any</code>的代码和效果：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> test = <span class="hljs-keyword">async</span> () =&gt; &#123;    <span class="hljs-keyword">const</span> url = [                <span class="hljs-string">"https://cdn.jsdelivr.net/npm/jquery@3.6.0/package.json"</span>,        <span class="hljs-string">"https://unpkg.com/jquery@3.6.0/package.json"</span>,        <span class="hljs-string">"https://unpkg.zhimg.com/jquery@3.6.0/package.json"</span>    ]    flag = <span class="hljs-literal">true</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> url) &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> fetch(url[i])            <span class="hljs-keyword">if</span> (res.status !== <span class="hljs-number">200</span>) &#123;                flag = <span class="hljs-literal">false</span>            &#125;        &#125;<span class="hljs-keyword">catch</span>(n)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>        &#125;    &#125;    <span class="hljs-keyword">return</span> flag&#125;</code></pre></div><p><img src="https://npm.elemecdn.com/chenyfan-os@0.0.0-r7/1.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>采用循环，<code>await</code>会堵塞循环，直到这次请求完成后才能执行下一个。如果有任何一个url长时间无法联通，将会导致极长的检测时间浪费。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> test = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    <span class="hljs-keyword">const</span> url = [        <span class="hljs-string">"https://cdn.jsdelivr.net/npm/jquery@3.6.0/package.json"</span>,        <span class="hljs-string">"https://unpkg.com/jquery@3.6.0/package.json"</span>,        <span class="hljs-string">"https://unpkg.zhimg.com/jquery@3.6.0/package.json"</span>    ]    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.all(url.map(<span class="hljs-function"><span class="hljs-params">url</span> =&gt;</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;            fetch(url)                .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;                    <span class="hljs-keyword">if</span> (res.status == <span class="hljs-number">200</span>) &#123;                        resolve(<span class="hljs-literal">true</span>)                    &#125; <span class="hljs-keyword">else</span> &#123;                        reject(<span class="hljs-literal">false</span>)                    &#125;                &#125;)                .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;                    reject(<span class="hljs-literal">false</span>)                &#125;)        &#125;)    &#125;    )).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>    &#125;).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;)&#125;</code></pre></div><p><img src="https://npm.elemecdn.com/chenyfan-os@0.0.0-r7/2.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p><code>Promise.all</code>几乎在一瞬间请求所有的url，其请求时并行，每一个请求并不会堵塞其他请求，函数总耗时为最长请求耗时。</p><h4 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h4><p>此函数也是并行执行，不过与all不同的是，只要有任何一个函数完成，就立刻返回，无论其是否<code>reject</code>或者<code>resolve</code>。</p><p>这个函数比较适合用于同时请求一些不关心结果，只要访问达到了即可，例如统计、签到等应用场景。</p><h4 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any"></a>Promise.any</h4><p>这个函数非常的有用，其作用和<code>race</code>接近，不过与之不同的是，<code>any</code>会同时检测结果是否<code>resolve</code>。其并行处理后，只要有任何一个返回正确，就直接返回哪个最快的请求结果，返回错误的直接忽视，除非所有的请求都失败了，才会返回<code>reject</code></p><p>这是一段同时请求<code>jquery</code>的<code>package.json</code>代码，它将从四个镜像同时请求：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> get_json = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;        <span class="hljs-keyword">const</span> urllist = [            <span class="hljs-string">"https://cdn.jsdelivr.net/npm/jquery@3.6.0/package.json"</span>,            <span class="hljs-string">"https://unpkg.com/jquery@3.6.0/package.json"</span>,            <span class="hljs-string">"https://unpkg.zhimg.com/jquery@3.6.0/package.json"</span>,            <span class="hljs-string">"https://npm.elemecdn.com/jquery@3.6.0/package.json"</span>        ]        <span class="hljs-built_in">Promise</span>.any(urllist.map(<span class="hljs-function"><span class="hljs-params">url</span> =&gt;</span> &#123;            fetch(url)                .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;                    <span class="hljs-keyword">if</span> (res.status == <span class="hljs-number">200</span>) &#123;                        resolve(res)                    &#125; <span class="hljs-keyword">else</span> &#123;                        reject()                    &#125;                &#125;).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;                    reject()                &#125;)        &#125;))    &#125;)&#125;<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">await</span>(<span class="hljs-keyword">await</span> get_json()).text())</code></pre></div><p><img src="https://npm.elemecdn.com/chenyfan-os@0.0.0-r7/3.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>函数将会在<code>21ms</code>上下返回json中的数据。</p><p>此函数的好处在于可以在用户客户端判断哪一个镜像发挥速度最快，并保证用户每一次获取都能达到最大速度。同时，任何一个镜像站崩溃了都不会造成太大的影响，脚本将自动从其他源拉取信息。</p><p>除非所有源都炸了，否则此请求不会失败。</p><p>但是，我们会额外地发现，当知乎镜像返回最新版本后，其余的请求依旧在继续，只是没有被利用到而已。</p><p>这会堵塞浏览器并发线程数，并且会造成额外的流量浪费。所以我们应该在其中任何一个请求完成后就打断其余请求。</p><p><code>fetch</code>有一个<code>abort</code>对象，只要刚开始<code>new AbortController()</code>指定控制器，在<code>init</code>的里面指定控制器的<code>signal</code>即可将其标记为待打断函数，最后<code>controller.abort()</code>即可打断。</p><p>那么，很多同学就会开始这么写了:</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> get_json = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;        <span class="hljs-keyword">const</span> controller = <span class="hljs-keyword">new</span> AbortController();        <span class="hljs-keyword">const</span> urllist = [            <span class="hljs-string">"https://cdn.jsdelivr.net/npm/jquery@3.6.0/package.json"</span>,            <span class="hljs-string">"https://unpkg.com/jquery@3.6.0/package.json"</span>,            <span class="hljs-string">"https://unpkg.zhimg.com/jquery@3.6.0/package.json"</span>,            <span class="hljs-string">"https://npm.elemecdn.com/jquery@3.6.0/package.json"</span>        ]        <span class="hljs-built_in">Promise</span>.any(urllist.map(<span class="hljs-function"><span class="hljs-params">url</span> =&gt;</span> &#123;            fetch(url,&#123;                <span class="hljs-attr">signal</span>: controller.signal            &#125;)                .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;                    <span class="hljs-keyword">if</span> (res.status == <span class="hljs-number">200</span>) &#123;                        controller.abort();                        resolve(res)                    &#125; <span class="hljs-keyword">else</span> &#123;                        reject()                    &#125;                &#125;).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;                    reject()                &#125;)        &#125;))    &#125;)&#125;<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">await</span>(<span class="hljs-keyword">await</span> get_json()).text())</code></pre></div><p>但很快，你就会发现它报错了：<code>Uncaught DOMException: The user aborted a request.</code>，并且没有任何数据输出。</p><p>让我们看一下Network选项卡：</p><p><img src="https://npm.elemecdn.com/chenyfan-os@0.0.0-r7/4.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>其中，知乎返回的最快，但他并没有完整的返回文件[源文件1.8KB，但他只返回了1.4KB]。这也直接导致了整个函数的<code>fail</code>。</p><p>原因出在<code>fetch</code>上，这个函数在获得响应之后就立刻<code>resolve</code>了<code>Response</code>，但这个时候<code>body</code>并没有下载完成，即<code>fetch</code>的返回基于状态的而非基于响应内容，当其中<code>fetch</code>已经拿到了完整的状态代码，它就立刻把<code>Response</code>丢给了下一个管道函数，而此时<code>status</code>正确，<code>abort</code>打断了包括这一个<code>fetch</code>的所有请求，<code>fetch</code>就直接工作不正常。</p><p>我个人采取的方式是读取<code>arrayBuffer</code>，阻塞<code>fetch</code>函数直到把整个文件下载下来。函数名为<code>PauseProgress</code></p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> get_json = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;        <span class="hljs-keyword">const</span> controller = <span class="hljs-keyword">new</span> AbortController();        <span class="hljs-keyword">const</span> PauseProgress = <span class="hljs-keyword">async</span> (res) =&gt; &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Response(<span class="hljs-keyword">await</span> (res).arrayBuffer(), &#123; <span class="hljs-attr">status</span>: res.status, <span class="hljs-attr">headers</span>: res.headers &#125;);        &#125;;        <span class="hljs-keyword">const</span> urllist = [            <span class="hljs-string">"https://cdn.jsdelivr.net/npm/jquery@3.6.0/package.json"</span>,            <span class="hljs-string">"https://unpkg.com/jquery@3.6.0/package.json"</span>,            <span class="hljs-string">"https://unpkg.zhimg.com/jquery@3.6.0/package.json"</span>,            <span class="hljs-string">"https://npm.elemecdn.com/jquery@3.6.0/package.json"</span>        ]        <span class="hljs-built_in">Promise</span>.any(urllist.map(<span class="hljs-function"><span class="hljs-params">url</span> =&gt;</span> &#123;            fetch(url, &#123;                <span class="hljs-attr">signal</span>: controller.signal            &#125;)                .then(PauseProgress)                .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;                    <span class="hljs-keyword">if</span> (res.status == <span class="hljs-number">200</span>) &#123;                        controller.abort();                        resolve(res)                    &#125; <span class="hljs-keyword">else</span> &#123;                        reject()                    &#125;                &#125;).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;                    reject()                &#125;)        &#125;))    &#125;)&#125;<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">await</span>(<span class="hljs-keyword">await</span> get_json()).text())</code></pre></div><p><img src="https://npm.elemecdn.com/chenyfan-os@0.0.0-r7/5.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>在这其中通过<code>arrayBuffer()</code>方法异步读取<code>res</code>的<code>body</code>，将其读取为二进制文件，并新建一个新的<code>Response</code>，还原状态和头，然后丢给管道函数同步处理。</p><p>在这里，我们就实现了暴力并发，以流量换速度的方式。同时也获得了一个高可用的SW负载均衡器。</p><p>这一段函数可以这样写在SW中：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//...</span><span class="hljs-keyword">const</span> lfetch = <span class="hljs-function">(<span class="hljs-params">urllist</span>) =&gt;</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;        <span class="hljs-keyword">const</span> controller = <span class="hljs-keyword">new</span> AbortController();        <span class="hljs-keyword">const</span> PauseProgress = <span class="hljs-keyword">async</span> (res) =&gt; &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Response(<span class="hljs-keyword">await</span> (res).arrayBuffer(), &#123; <span class="hljs-attr">status</span>: res.status, <span class="hljs-attr">headers</span>: res.headers &#125;);        &#125;;        <span class="hljs-built_in">Promise</span>.any(urllist.map(<span class="hljs-function"><span class="hljs-params">url</span> =&gt;</span> &#123;            fetch(url, &#123;                <span class="hljs-attr">signal</span>: controller.signal            &#125;)                .then(PauseProgress)                .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;                    <span class="hljs-keyword">if</span> (res.status == <span class="hljs-number">200</span>) &#123;                        controller.abort();                        resolve(res)                    &#125; <span class="hljs-keyword">else</span> &#123;                        reject()                    &#125;                &#125;).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;                    reject()                &#125;)        &#125;))    &#125;)&#125;<span class="hljs-keyword">const</span> handle = <span class="hljs-keyword">async</span> (req) =&gt; &#123;    <span class="hljs-keyword">const</span> npm_mirror = [        <span class="hljs-string">'https://cdn.jsdelivr.net/npm/'</span>,        <span class="hljs-string">'https://unpkg.com/'</span>,        <span class="hljs-string">'https://npm.elemecdn.com/'</span>,        <span class="hljs-string">'https://unpkg.zhimg.com/'</span>    ]    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> k <span class="hljs-keyword">in</span> npm_mirror) &#123;        <span class="hljs-keyword">if</span> (req.url.match(npm_mirror[k]) &amp;&amp; req.url.replace(<span class="hljs-string">'https://'</span>, <span class="hljs-string">''</span>).split(<span class="hljs-string">'/'</span>)[<span class="hljs-number">0</span>] == npm_mirror[k].replace(<span class="hljs-string">'https://'</span>, <span class="hljs-string">''</span>).split(<span class="hljs-string">'/'</span>)[<span class="hljs-number">0</span>]) &#123;            <span class="hljs-keyword">return</span> lfetch(<span class="hljs-function">(<span class="hljs-params">(</span>) =&gt;</span> &#123;                <span class="hljs-keyword">let</span> l = []                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; npm_mirror.length; i++) &#123;                    l.push(npm_mirror[i] + req.url.split(<span class="hljs-string">'/'</span>)[<span class="hljs-number">3</span>])                &#125;                <span class="hljs-keyword">return</span> l            &#125;)())        &#125;    &#125;    <span class="hljs-keyword">return</span> fetch(req)&#125;</code></pre></div><h2 id="缓存控制-Cache"><a href="#缓存控制-Cache" class="headerlink" title="缓存控制 / Cache"></a>缓存控制 / Cache</h2><h3 id="持久化缓存-Cache-Persistently"><a href="#持久化缓存-Cache-Persistently" class="headerlink" title="持久化缓存 / Cache Persistently"></a>持久化缓存 / Cache Persistently</h3><p>对于来自CDN的流量，大部分是持久不变的，因此，如果我们将文件获得后直接填入缓存，之后访问也直接从本地缓存中读取，那将大大提升访问速度。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> handle = <span class="hljs-keyword">async</span> (req) =&gt; &#123;    <span class="hljs-keyword">const</span> cache_url_list = [        <span class="hljs-regexp">/(http:\/\/|https:\/\/)cdn\.jsdelivr\.net/g</span>,        /(http:\/\/|https:\/\/)cdn\.bootcss\.com/g,        /(http:\/\/|https:\/\/)zhimg\.unpkg\.com/g,        /(http:\/\/|https:\/\/)unpkg\.com/g    ]    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> cache_url_list) &#123;        <span class="hljs-keyword">if</span> (req.url.match(cache_url_list[i])) &#123;            <span class="hljs-keyword">return</span> caches.match(req).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resp</span>) </span>&#123;                <span class="hljs-keyword">return</span> resp || fetch(req).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) </span>&#123;                    <span class="hljs-keyword">return</span> caches.open(CACHE_NAME).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cache</span>) </span>&#123;                        cache.put(req, res.clone());                        <span class="hljs-keyword">return</span> res;                    &#125;);                &#125;);            &#125;)        &#125;    &#125;    <span class="hljs-keyword">return</span> fetch(req)&#125;</code></pre></div><p><code>cache_url_list</code>列出所有待匹配的域名(包括http/https头是为了避免误杀其他url)，然后<code>for</code>开始遍历待列表，如果url中匹配到了，开始执行返回缓存操作。</p><p>cache是一个近似于Key/Value(键名/键值)，只要有对应的<code>Request</code>(<code>KEY</code>)，就能匹配到响应的<code>Response</code>(<code>VALUE</code>)。</p><p><code>caches.match(req)</code>将会试图在CacheStorage中匹配请求的url获取值，然后丢给管道同步函数<code>then</code>，传参<code>resp</code>为Cache匹配到的值。</p><p>此时管道内将尝试返回resp，如果resp为<code>null</code>或<code>undefined</code>[即获取不到对应的缓存]，将执行fetch操作，fetch成功后将<code>open</code>打开CacheStorage，并<code>put</code>放入缓存。此时如果<code>fetch</code>失败将直接报错，不写入缓存。</p><p>在下一次获取同一个URL的时候，缓存匹配到的将不再是空白值，此时<code>fetch</code>不执行，直接返回缓存，大大提升了速度。</p><p>由于npm的cdn对于latest缓存并不是持久有效的，所以我们最好还是判断一下url版本中是否以@latest为结尾。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> is_latest = <span class="hljs-function">(<span class="hljs-params">url</span>) =&gt;</span> &#123;    <span class="hljs-keyword">return</span> url.replace(<span class="hljs-string">'https://'</span>, <span class="hljs-string">''</span>).split(<span class="hljs-string">'/'</span>)[<span class="hljs-number">1</span>].split(<span class="hljs-string">'@'</span>)[<span class="hljs-number">1</span>] === <span class="hljs-string">'latest'</span>&#125;<span class="hljs-comment">//...</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> cache_url_list) &#123;    <span class="hljs-keyword">if</span> (is_latest(req.url)) &#123; <span class="hljs-keyword">return</span> fetch(req) &#125;    <span class="hljs-keyword">if</span> (req.url.match(cache_url_list[i])) &#123;        <span class="hljs-keyword">return</span> caches.match(req).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resp</span>) </span>&#123;            <span class="hljs-comment">//...</span>        &#125;)    &#125;&#125;</code></pre></div><h3 id="离线化缓存-Cache-For-Offline"><a href="#离线化缓存-Cache-For-Offline" class="headerlink" title="离线化缓存 / Cache For Offline"></a>离线化缓存 / Cache For Offline</h3><p>对于博客来说，并不是所有内容都是一成不变的。传统PWA采用SW更新同时刷新缓存，这样不够灵活，同时刷新缓存的版本号管理也存在着很大的漏洞，长时间访问极易造成庞大的缓存冗余。因此，对于博客的缓存，我们要保证用户每次获取都是最新的版本，但也要保证用户在离线时能看到最后一个版本的内容。</p><p>因此，针对博客来说，策略应该是先获取最新内容，然后更新本地缓存，最后返回最新内容；离线的时候，尝试访问最新内容会回退到缓存，如果缓存也没有，就回退到错误页面。</p><p>即：</p><div class="hljs"><pre><code class="hljs undefined">Online:发起Request =&gt; 发起fetch =&gt; 更新Cache =&gt; 返回ResponseOffline:发起Request =&gt; 获取Cache =&gt; 返回Response</code></pre></div><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> handle = <span class="hljs-keyword">async</span> (req) =&gt; &#123;    <span class="hljs-keyword">return</span> fetch(req.url).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) </span>&#123;        <span class="hljs-keyword">if</span> (!res) &#123; <span class="hljs-keyword">throw</span> <span class="hljs-string">'error'</span> &#125; <span class="hljs-comment">//1</span>        <span class="hljs-keyword">return</span> caches.open(CACHE_NAME).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cache</span>) </span>&#123;            cache.delete(req);            cache.put(req, res.clone());            <span class="hljs-keyword">return</span> res;        &#125;);    &#125;).catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>&#123;        <span class="hljs-keyword">return</span> caches.match(req).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resp</span>) </span>&#123;            <span class="hljs-keyword">return</span> resp || caches.match(<span class="hljs-keyword">new</span> Request(<span class="hljs-string">'/offline.html'</span>)) <span class="hljs-comment">//2</span>        &#125;)    &#125;)&#125;</code></pre></div><p><code>if (!res) { throw &#39;error&#39; }</code> 如果没有返回值，直接抛出错误，会被下面的Catch捕获，返回缓存或错误页面</p><p><code>return resp || caches.match(new Request(&#39;/offline.html&#39;))</code> 返回缓存获得的内容。如果没有，就返回从缓存中拿到的错误网页。此处offline.html应该在最开始的时候就缓存好</p><h2 id="持久化存储-Storage-Persistently"><a href="#持久化存储-Storage-Persistently" class="headerlink" title="持久化存储 / Storage Persistently"></a>持久化存储 / Storage Persistently</h2><p>由于sw中无<code>window</code>，我们不能使用<code>localStorage</code>和<code>sessionStorage</code>。SW脚本会在所有页面都关闭或重载的时候丢失原先的数据。因此，如果想要使用持久化存储，我们只能使用<code>CacheAPI</code>和<code>IndexdDB</code>。</p><h3 id="IndexdDB"><a href="#IndexdDB" class="headerlink" title="IndexdDB"></a>IndexdDB</h3><p>这货结构表类型类似于<code>SQL</code>，能够存储JSON对象和数据内容，但版本更新及其操作非常麻烦，因此本文不对此做过多解释。</p><h3 id="CacheAPI"><a href="#CacheAPI" class="headerlink" title="CacheAPI"></a>CacheAPI</h3><p>这东西原本是用来缓存响应，但其本身的特性我们可以将其改造成一个简易的Key/Value数据表，可以存储文本/二进制，可扩展性远远比IndexdDB要好。</p><div class="hljs"><pre><code class="hljs js">self.CACHE_NAME = <span class="hljs-string">'SWHelperCache'</span>;self.db = &#123;    <span class="hljs-attr">read</span>: <span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;            caches.match(<span class="hljs-keyword">new</span> Request(<span class="hljs-string">`https://LOCALCACHE/<span class="hljs-subst">$&#123;<span class="hljs-built_in">encodeURIComponent</span>(key)&#125;</span>`</span>)).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) </span>&#123;                res.text().then(<span class="hljs-function"><span class="hljs-params">text</span> =&gt;</span> resolve(text))            &#125;).catch(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;                resolve(<span class="hljs-literal">null</span>)            &#125;)        &#125;)    &#125;,    <span class="hljs-attr">read_arrayBuffer</span>: <span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;            caches.match(<span class="hljs-keyword">new</span> Request(<span class="hljs-string">`https://LOCALCACHE/<span class="hljs-subst">$&#123;<span class="hljs-built_in">encodeURIComponent</span>(key)&#125;</span>`</span>)).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) </span>&#123;                res.arrayBuffer().then(<span class="hljs-function"><span class="hljs-params">aB</span> =&gt;</span> resolve(aB))            &#125;).catch(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;                resolve(<span class="hljs-literal">null</span>)            &#125;)        &#125;)    &#125;,    <span class="hljs-attr">write</span>: <span class="hljs-function">(<span class="hljs-params">key, value</span>) =&gt;</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;            caches.open(CACHE_NAME).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cache</span>) </span>&#123;                cache.put(<span class="hljs-keyword">new</span> Request(<span class="hljs-string">`https://LOCALCACHE/<span class="hljs-subst">$&#123;<span class="hljs-built_in">encodeURIComponent</span>(key)&#125;</span>`</span>), <span class="hljs-keyword">new</span> Response(value));                resolve()            &#125;).catch(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;                reject()            &#125;)        &#125;)    &#125;&#125;</code></pre></div><p>使用操作：</p><p>写入key，value:</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">await</span> db.wtite(key,value)</code></pre></div><p>以文本方式读取key：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">await</span> db.read(key)</code></pre></div><p>以二进制方式读取key：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">await</span> db.read_arrayBuffer(key)</code></pre></div><p>其余的blob读取、delete操作此处不过多阐述。</p><h2 id="页面与SW通信-Build-Communication-with-Page-and-ServiceWorker"><a href="#页面与SW通信-Build-Communication-with-Page-and-ServiceWorker" class="headerlink" title="页面与SW通信 / Build Communication with Page and ServiceWorker"></a>页面与SW通信 / Build Communication with Page and ServiceWorker</h2><blockquote><p>施工中</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;ServiceWorker作为前端革命领袖，毫不夸张地被誉为前端黑科技，此文将阐述如何巧妙的使用它来实现一些看起来匪夷所思的事情。&lt;/p&gt;</summary>
    
    
    
    <category term="随心扯" scheme="https://blog.cyfan.top/categories/随心扯/"/>
    
    
    <category term="黑科技" scheme="https://blog.cyfan.top/tags/黑科技/"/>
    
    <category term="JSdelivr" scheme="https://blog.cyfan.top/tags/JSdelivr/"/>
    
    <category term="ServiceWorker" scheme="https://blog.cyfan.top/tags/ServiceWorker/"/>
    
  </entry>
  
  <entry>
    <title>2022新春小记</title>
    <link href="https://blog.cyfan.top/p/7c7f6808.html"/>
    <id>https://blog.cyfan.top/p/7c7f6808.html</id>
    <published>2022-01-10T13:57:45.000Z</published>
    <updated>2022-01-16T12:23:54.551Z</updated>
    
    <content type="html"><![CDATA[<p>这是一篇随迟但到的新春贺词（</p><a id="more"></a><p>首先呢，旧年总结是不可能做的，这辈子都不可能做的。我发这篇文章的首要目的就是证明我还活着，毕竟上一篇文章到现在已经快半年了（实际上确实有半年）</p><p>2021年是牛年，这一年过得很平淡，但却伴随着不少热点事件，刨去政治的，防沉迷、反诈、jsd掉备等等。这些热点我会在以后（maybe）一一热炒冷饭。</p><p>新文仍在赶工，可以<a href="/p/c0af86bb.html">戳我围观新文</a>（还没写完）</p><p>博客已经开启了自己写的ChenBlogHelper，在第一次进入博客的时候会自动安装并刷新激活。此helper能够在前端绕过备案、优选cdn以及统计。</p><p>博客现在在中国大陆有一个广州节点承载，希望这能够给你们带来更好的访问体验。</p><p>总之，新的一年，祝大家顺心顺意，愉快地享受新年的每一天！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这是一篇随迟但到的新春贺词（&lt;/p&gt;</summary>
    
    
    
    <category term="随心扯" scheme="https://blog.cyfan.top/categories/随心扯/"/>
    
    
    <category term="新年贺词" scheme="https://blog.cyfan.top/tags/新年贺词/"/>
    
  </entry>
  
  <entry>
    <title>为什么是APP而不是网页</title>
    <link href="https://blog.cyfan.top/p/c0af86a9.html"/>
    <id>https://blog.cyfan.top/p/c0af86a9.html</id>
    <published>2021-07-28T05:24:15.000Z</published>
    <updated>2022-01-16T12:23:54.551Z</updated>
    
    <content type="html"><![CDATA[<p>一个简单的功能，完全可以在浏览器内实现，凭什么国内某些软件这么希望你去下载，去使用他们的app？</p><a id="more"></a><p>就在不久前，我是真的体会到了什么叫流氓厂商。点名批评一下百度，我苹果手机Safari随便在百度上搜索点什么，还没把营销号、广告和垃圾信息从眼中剔除，突然间，AppStore界面平移到我眼前，一个叫<code>百度</code>的软件可怜巴巴的望着我。于是我点击左上角返回键，然后继续搜索…</p><p>这不是一件在国内很常见的事情吗，然后我继续浏览，点击一个百度百科网页链接，又是还没开看，appstore显示了出来，这次是百度百科app。</p><p>好，没事，我平复了一下心情，整理了一下被打乱的思绪，继续浏览着百科，滑到页面底部，加载新的内容时，一个弹窗显示出来：使用百度百科APP，获取更好的浏览体验！</p><p>关闭，继续浏览。</p><p>点击百科内部的内链，尝试跳转到另一个百科界面，突然，浏览器一片空白，我又被引导向appstore。</p><p>很抱歉，我直接关闭了百度，使用谷歌和维基百科继续查询资料。这一次，谷歌虽然也在下方提示【在IOS上尝试使用谷歌桌面版，获取更好的体验】，但至始至终没有把我强制跳到appstore。维基百科就更不用说了，连使用app都没有提示。</p><p>退出了浏览器，我不禁陷入了沉思。我还记得不久前拿到朋友的新鸿蒙手机，划开屏幕一看，第一个界面全是百度系列：百度、百度搜索、百度智能浏览器、百度贴吧、百度知道…一个个功能冗余的百度app赫然显示在我的眼前，当我一脸震惊地看向朋友，他耸耸肩：点进去就自己下载的，不安装就没办法看了。</p><p>看着自己苹果手机中的两个一个浏览器：Safari和Alook，我停止了思考，当一个大厂天天为自己的免费网盘带宽叫屈，下载一个3M的电子书被限成一副狗样时，你还能相信他有这么大的带宽给用户推自己的动辄100MB的APP？这能算是本末倒置吗？</p><p>从此，我在手机上再也没有用过百度系。必应和谷歌，DogeDoge和DuckDuckGo成为了我的搜索主力。</p><h1 id="为什么是APP"><a href="#为什么是APP" class="headerlink" title="为什么是APP"></a>为什么是APP</h1><h2 id="隐私"><a href="#隐私" class="headerlink" title="隐私"></a>隐私</h2><p>app对隐私的疯狂到了什么地步？我也就不贴知乎链接了，就贴一个今天cctv的内容吧：</p><p><a href="https://tv.cctv.com/live/cctv13/index.shtml?spm=C28340.P1dzdfA9CsHZ.E1oxZyG629bH.79&amp;stime=1627446780&amp;etime=1627448400&amp;type=lbacks" target="_blank" rel="noopener">https://tv.cctv.com/live/cctv13/index.shtml?spm=C28340.P1dzdfA9CsHZ.E1oxZyG629bH.79&amp;stime=1627446780&amp;etime=1627448400&amp;type=lbacks</a></p><p>在安卓环境【尤其是国内某些套壳系统】下，app的权限不算小，有些时候可以在没有提醒的情况下把你的浏览器记录翻个遍。</p><p>ios其实相对安卓来说，至少系统能主动提醒用户是否给予其访问权利。</p><p>这一点我也十分佩服MIUI，能在这种隐私岁随意获取风气下站住来守住用户的底线，无论其目的如何，这一点已经赢得了我的好感【虽然我不用安卓】</p><p>对于软件商来说，用户的数据是一大笔财富。比如知道所有人的喜好、购买能力等，这些信息掌握得越细致，越能挖掘到更多的商机。</p><p>暂且不说百度，就连TIM和QQ也会主动扫描用户Chrome浏览记录<span class="heimu"><del>我靠那我的nhentai浏览记录怎么办</del></span></p><h2 id="互唤醒【For安卓】"><a href="#互唤醒【For安卓】" class="headerlink" title="互唤醒【For安卓】"></a>互唤醒【For安卓】</h2><p>为了实现广告营销，部分软件实际上要向用户主动推送广告信息。</p><p>尤其是安卓，由于谷歌市场退出中国大陆，国内安卓生态其实很乱，一个简单的消息推送，也能难倒一群开发者。</p><p>为什么消息推送变成了一个难题？其实我们想象中的消息推送与实际上的方式有很大差距:</p><p>想象中：用户手机&lt;==主动推送==微信服务器<br>实际上：用户手机&lt;==被动推送==&gt;苹果|安卓消息推送服务器&lt;==主动推送==微信服务器</p><p>苹果还好说，18年以前经常会出现微信无法推送的情况，但自从大陆线路优化以及云上贵州的迁移，其推送服务逐渐变得正常。然而谷歌早已退出中国市场，其内置的推送服务器已经不可链接，请问这些app这么办？</p><p>答：常驻系统后台。</p><p>但是常驻系统后台成为一个Zombine进程也不可避免会被杀掉，请问这又能怎么办？</p><p>答：相互唤醒。</p><p>当用户打开一个app，此app会在后台激活另一群app，然后如果当前app被杀了，被激活的app又会激活那个被杀的app。</p><p>这样就很好理解了虽然只有百度app才会推送广告，但他依旧会引导你去下载百度浏览器—避免被杀掉啊。</p><h1 id="为什么不是浏览器应用"><a href="#为什么不是浏览器应用" class="headerlink" title="为什么不是浏览器应用"></a>为什么不是浏览器应用</h1><h2 id="隐私-1"><a href="#隐私-1" class="headerlink" title="隐私"></a>隐私</h2><p>在这个隐私即金钱的时代，对于国内厂商来说，首先一个遗憾的事情是，浏览器是很难获取到用户的隐私信息。不是说功能限制，而是浏览器其核心就是沙盒化。在没有用户同意和外接接口、插件的前提下，你不可能直接用js获取到用户手机/电脑上的文件。</p><p>而且最致命的是，如果网页应用敢在后台偷偷上传用户隐私，控制台一开就会使其暴露无遗，相对比APP的黑盒操作，那简直是天差地别。</p><h2 id="功能限制"><a href="#功能限制" class="headerlink" title="功能限制"></a>功能限制</h2><p>js功能其实很强大，但有些底层和协议上的限制不能做就是不能做，你不可能用js空手写一个SMTP发送邮件，你也不可能直接用SSH协议链接服务器【WebSSH需要在服务器主动安装服务端】</p><p>其次，一些十分耗资源和计算力的服务不可能在浏览器上实现，比如腾讯不可能把王者荣耀搬到浏览器上，你也不可能在浏览器里跑机器学习。</p><h2 id="网络限制"><a href="#网络限制" class="headerlink" title="网络限制"></a>网络限制</h2><p>如果使用浏览器，其每一次打开服务网店都要重新下载上面的js、css和图片资源，这一瞬间爆发对服务器压力其实不小。</p><p>而使用app，他可以事先在后台下载好广告图片，其样式和功能无需重新下载，并且很多资源可以缓存在本地，即使短暂离线也能推送。</p><p>这一点，PWA技术完全可以胜任。PWA通过在浏览器内ServiceWorker拦截和缓存内容实现离线浏览。但目前来讲PWA技术在国内不温不火【很明显，触碰到了某些企业的利益】，所以还是以应用程序为主。</p><p><span class="heimu">但是，你这样剩下来的流量费还是比不过强制更新来的多啊</span></p><h1 id="为什么国外没有出现类似的情况"><a href="#为什么国外没有出现类似的情况" class="headerlink" title="为什么国外没有出现类似的情况"></a>为什么国外没有出现类似的情况</h1><h2 id="监管缺失"><a href="#监管缺失" class="headerlink" title="监管缺失"></a>监管缺失</h2><p>海外，安卓应用最官方的商店只有一家：GooglePlay，虽然不像AppStore那种不上架连安装都不给的程度，但也是一种象征。没有上架谷歌商店的应用基本都会被判定为盗版或者危险。而且谷歌play对广告监管很严。如果一个应用敢像百度般，疯狂推送广告和自唤醒，可能连安全审查都过不去。</p><p>在国内，连老大都管不了，宛若袁世凯暴毙天下军阀混战，其乱象不言而喻。</p><h2 id="隐私意识缺乏"><a href="#隐私意识缺乏" class="headerlink" title="隐私意识缺乏"></a>隐私意识缺乏</h2><p>李彦宏有句<del>名言</del>：中国人更愿意用隐私交换便捷性。</p><p>虽然此话一出被无数网友嘲讽，但也不得不承认这确实如此。甚至有些时候自己也是被迫的。没有多少人会上网的时候开无数个虚拟机中继代理AdGuard，相反，有更多人为了PDD的几分钱蔬菜而抢破头。一句话：国人都喜欢薅羊毛，但最终都会成为韭菜被割。</p><p>相反，在国外，人们对于隐私十分看重，哪怕GoogleAdsense都被罚了好几次，还不用说Tor之类的隐私保护软件。</p><h2 id="使用观念的不同"><a href="#使用观念的不同" class="headerlink" title="使用观念的不同"></a>使用观念的不同</h2><p>我个人的习惯是，完成一件事情，用什么东西都越轻越好，不是有必要就不下客户端。比如在电脑微信接收消息，你可以选择下载微信客户端完成传输，也可以用<a href="https://wx.qq.com" target="_blank" rel="noopener">网页微信</a>。相较于前者，后者用完就关，不留痕迹，速度也快。</p><p>然而国人的习惯大多是：先下载下来，万一以后有用呢。</p><p>当我看到电视上的手机广告，大多8H16G运存128G内存起步，盯着手里这台国产只装了QQ到2021年还能打Minecraft的iPhone6s【实际配置2GB运存A9处理器】，不禁留下了悔恨的泪水：幸好没买安卓。</p><p>安卓手机即使内存再大，其底层核心还是虚拟化，加上国内的恶劣的生态，如果你不留神多下点软件，其流畅度甚至比不过6年前的6s。</p><p>而手机卡，大多数人的第一个想法是：换一台手机。而不是：我删掉点软件，只保留QQ和微信。</p><p>尤其是，在国内的内循环已经完成的前提下，更多人选择了买爱国手机，装爱国软件。实际上，留一条隐私底线其实也没有什么。但偏偏有人喜欢把自己隐私送给别人。</p><h1 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h1><p>实际上，绝大多数软件从C/S架构向B/S架构的转换是不可避免的。但是国内的生态似乎在阻碍着这一发展。</p><p>或许有人会问，隐私再保护有什么用。那我只能说，如果你的隐私在黑市只能卖1毛钱一条，那隐私保护的好的人或许能卖5块钱一条。真正的危害其实不在于精准推送，而更怕有人会拿去做违法事情，暴力你，诈骗你。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;一个简单的功能，完全可以在浏览器内实现，凭什么国内某些软件这么希望你去下载，去使用他们的app？&lt;/p&gt;</summary>
    
    
    
    <category term="叨叨念" scheme="https://blog.cyfan.top/categories/叨叨念/"/>
    
    
    <category term="浏览器" scheme="https://blog.cyfan.top/tags/浏览器/"/>
    
    <category term="应用" scheme="https://blog.cyfan.top/tags/应用/"/>
    
    <category term="隐私" scheme="https://blog.cyfan.top/tags/隐私/"/>
    
    <category term="app" scheme="https://blog.cyfan.top/tags/app/"/>
    
  </entry>
  
  <entry>
    <title>致敬袁老，精神永在</title>
    <link href="https://blog.cyfan.top/p/4ee6384.html"/>
    <id>https://blog.cyfan.top/p/4ee6384.html</id>
    <published>2021-05-22T08:49:21.000Z</published>
    <updated>2022-01-16T12:23:54.551Z</updated>
    
    <content type="html"><![CDATA[<p>“共和国勋章”获得者、中国工程院院士、国家杂交水稻工程技术研究中心主任、湖南省政协原副主席袁隆平，因多器官功能衰竭，于2021年5月22日13时07分在长沙逝世，享年91岁。</p><p>感谢袁老，让我们端的起饭碗，让我们00后的孩子至少吃得饱。一路走好。</p><p>我的博客即将同步至腾讯云+社区，邀请大家一同入驻：<a href="https://cloud.tencent.com/developer/support-plan?invite_code=3uzi7w7znlsa" target="_blank" rel="noopener">https://cloud.tencent.com/developer/support-plan?invite_code=3uzi7w7znlsa</a></p><style>html{filter: grayscale(100%);-webkit-filter: grayscale(100%);-moz-filter: grayscale(100%);-ms-filter: grayscale(100%);-o-filter: grayscale(100%);filter:progid:DXImageTransform.Microsoft.BasicImage(grayscale=1);}</style>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;“共和国勋章”获得者、中国工程院院士、国家杂交水稻工程技术研究中心主任、湖南省政协原副主席袁隆平，因多器官功能衰竭，于2021年5月22日13时07分在长沙逝世，享年91岁。&lt;/p&gt;
&lt;p&gt;感谢袁老，让我们端的起饭碗，让我们00后的孩子至少吃得饱。一路走好。&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>再见Z16，Hi Laffey！</title>
    <link href="https://blog.cyfan.top/p/a12e0ab7.html"/>
    <id>https://blog.cyfan.top/p/a12e0ab7.html</id>
    <published>2021-04-19T08:26:23.000Z</published>
    <updated>2022-01-16T12:23:54.551Z</updated>
    
    <content type="html"><![CDATA[<p>2019-7-16 本站建成，第二天，Z16进入了我的博客。今天，我更换了陪伴我641天的看板娘。</p><a id="more"></a><p>越来越多的模型采用了最新版本的Live2d Cubism 3或4【以下简称Live2d V3/V4】，而我用的hexo live2d插件<a href="https://github.com/EYHN/hexo-helper-live2d" target="_blank" rel="noopener">hexo-helper-live2d</a>已经很久没更新了，直接使用v3模型显然是不行的。</p><p>原来用的Z16【V2】模型地址：</p><div class="hljs"><pre><code class="hljs url">https://npm.elemecdn.com/chenyfan-cdn@2.0.0/js/live2d-widget-model-z16/assets/z16.model.json</code></pre></div><p>格式如下：</p><div class="hljs"><pre><code class="hljs json">&#123;    <span class="hljs-attr">"version"</span>: <span class="hljs-string">"Live2DViewerEX Config 1.0"</span>,    <span class="hljs-attr">"model"</span>: <span class="hljs-string">"moc/z16.moc"</span>,    <span class="hljs-attr">"textures"</span>: [        <span class="hljs-string">"moc/z16.1024/texture_00.png"</span>    ],    <span class="hljs-attr">"layout"</span>: &#123;        <span class="hljs-attr">"center_x"</span>: <span class="hljs-number">0</span>,        <span class="hljs-attr">"center_y"</span>: <span class="hljs-number">0</span>,        <span class="hljs-attr">"width"</span>: <span class="hljs-number">2</span>    &#125;,    <span class="hljs-attr">"motions"</span>: &#123;        <span class="hljs-attr">"idle"</span>: [            &#123;                <span class="hljs-attr">"file"</span>: <span class="hljs-string">"mtn/idle.mtn"</span>            &#125;        ]    &#125;,    <span class="hljs-attr">"expressions"</span>: [        &#123;            <span class="hljs-attr">"name"</span>: <span class="hljs-string">"f00.exp.json"</span>,            <span class="hljs-attr">"file"</span>: <span class="hljs-string">"exp/f00.exp.json"</span>        &#125;    ],    <span class="hljs-attr">"physics"</span>: <span class="hljs-string">"z16.physics.json"</span>&#125;</code></pre></div><p>而V3模型普遍长这样：</p><div class="hljs"><pre><code class="hljs json">&#123;    <span class="hljs-attr">"Version"</span>: <span class="hljs-number">3</span>,    <span class="hljs-attr">"FileReferences"</span>: &#123;        <span class="hljs-attr">"Moc"</span>: <span class="hljs-string">"lafei_4.moc3"</span>,        <span class="hljs-attr">"Textures"</span>: [            <span class="hljs-string">"textures/texture_00.png"</span>        ],        <span class="hljs-attr">"Physics"</span>: <span class="hljs-string">"lafei_4.physics3.json"</span>,        <span class="hljs-attr">"Motions"</span>: &#123;            <span class="hljs-attr">""</span>: [                &#123;                    <span class="hljs-attr">"File"</span>: <span class="hljs-string">"motions/complete.motion3.json"</span>                &#125;,                ...            ]        &#125;    &#125;,    <span class="hljs-attr">"Groups"</span>: [        &#123;            <span class="hljs-attr">"Target"</span>: <span class="hljs-string">"Parameter"</span>,            <span class="hljs-attr">"Name"</span>: <span class="hljs-string">"LipSync"</span>,            <span class="hljs-attr">"Ids"</span>: [                <span class="hljs-string">"ParamMouthOpenY"</span>            ]        &#125;    ]&#125;</code></pre></div><p>将所有除了Ver信息全部移入了<code>FileReferences</code>Key里面。</p><p>当然，V3和V2的差别肯定不止json格式的差异，所以我们很显然要一个新的js加载V3。</p><h1 id="更新V3-4-Core"><a href="#更新V3-4-Core" class="headerlink" title="更新V3/4 Core"></a>更新V3/4 Core</h1><blockquote><p>Live2d官网已经决定后来的live2d版本都允许向前兼容到V3,所以V4的core还是能加载V3的模型[当然V2不行]</p></blockquote><p>啃了一遍官文,我们首先需要这些js插件:</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-selector-tag">live2dcubismcore</span><span class="hljs-selector-class">.js</span><span class="hljs-selector-tag">live2dcubismframework</span><span class="hljs-selector-class">.js</span><span class="hljs-selector-tag">pixi</span><span class="hljs-selector-class">.js</span><span class="hljs-selector-tag">live2dcubismpixi</span><span class="hljs-selector-class">.js</span></code></pre></div><p>首先说<code>live2dcubismcore.js</code>,这是一个急需注意的js,由于版权原因,你需要自行去官网下载再上传到自己的cdn,所以不能随便找一个人的网站就爬下来<strong>[包括我的]</strong>,这样会收到官方警告的。</p><p>前往<a href="https://cubism.live2d.com/sdk-web/cubismcore/live2dcubismcore.min.js" target="_blank" rel="noopener">https://cubism.live2d.com/sdk-web/cubismcore/live2dcubismcore.min.js</a>下载。</p><p>然后剩下的你可以选择嫖我的</p><p><a href="https://cdn.jsdelivr.net/combine/npm/chenyfan-oss@2.0.3/pixi.min.js,npm/chenyfan-oss@2.0.3/live2dcubismframework.min.js,npm/chenyfan-oss@2.0.3/live2dcubismpixi.min.js" target="_blank" rel="noopener">https://cdn.jsdelivr.net/combine/npm/chenyfan-oss@2.0.3/pixi.min.js,npm/chenyfan-oss@2.0.3/live2dcubismframework.min.js,npm/chenyfan-oss@2.0.3/live2dcubismpixi.min.js</a></p><h1 id="加载模型"><a href="#加载模型" class="headerlink" title="加载模型"></a>加载模型</h1><p>我选择白嫖<a href="https://github.com/Himehane/live2d_on_website/blob/master/loadModel.js" target="_blank" rel="noopener">https://github.com/Himehane/live2d_on_website/blob/master/loadModel.js</a></p><p>当然这有一点点小问题，比如上面这么配置：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> baseModelPath = <span class="hljs-string">'https://npm.elemecdn.com/chenyfan-oss@2.0.2'</span><span class="hljs-keyword">var</span> modelNames = [<span class="hljs-string">"lafei_4"</span>];</code></pre></div><p>那么他会这么请求</p><div class="hljs"><pre><code class="hljs url">https://npm.elemecdn.com/chenyfan-oss@2.0.2/lafei_4/lafei_4.model3.json</code></pre></div><p>可是问题是我没有加一层文件夹。。。我的位置是</p><div class="hljs"><pre><code class="hljs url">https://npm.elemecdn.com/chenyfan-oss@2.0.2/lafei_4.model3.json</code></pre></div><p>修改loadModel 288行</p><div class="hljs"><pre><code class="hljs undefined">- modelPath =  <span class="hljs-keyword">baseModelPath </span>+ modelName + <span class="hljs-string">"/"</span> + modelName + <span class="hljs-string">".model3.json"</span><span class="hljs-comment">;</span>+ modelPath = <span class="hljs-keyword">baseModelPath </span>+ <span class="hljs-string">"/"</span> + modelName + <span class="hljs-string">".model3.json"</span><span class="hljs-comment">;</span></code></pre></div><h1 id="样式调整"><a href="#样式调整" class="headerlink" title="样式调整"></a>样式调整</h1><p>首先给live2d一个div位置</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"live2d"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"live2d"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">canvas</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"live2dm"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"live2d"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"z-index: 999!important;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">canvas</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p>然后样式微调</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.live2d</span> &#123;    <span class="hljs-attribute">position</span>: fixed;     <span class="hljs-attribute">left</span>: -<span class="hljs-number">100px</span>;    <span class="hljs-attribute">bottom</span>: -<span class="hljs-number">20px</span>;    <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span> <span class="hljs-meta">!important</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">437.5px</span> <span class="hljs-meta">!important</span>;    <span class="hljs-attribute">z-index</span>: <span class="hljs-number">998</span>;&#125;</code></pre></div><p><code>bottom</code>将其固定页面底端，大小用<code>!important</code>强制固定<del>【不规范写法，请勿模仿】</del></p><h1 id="判断屏幕大小进行懒加载"><a href="#判断屏幕大小进行懒加载" class="headerlink" title="判断屏幕大小进行懒加载"></a>判断屏幕大小进行懒加载</h1><p>嘿嘿，这么大的js怎么不能懒加载呢</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadScript</span>(<span class="hljs-params">src, callback</span>) </span>&#123;        <span class="hljs-keyword">var</span> script = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'script'</span>),            head = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">'head'</span>)[<span class="hljs-number">0</span>];        script.type = <span class="hljs-string">'text/javascript'</span>;        script.charset = <span class="hljs-string">'UTF-8'</span>;        script.src = src;        <span class="hljs-keyword">if</span> (script.addEventListener) &#123;            script.addEventListener(<span class="hljs-string">'load'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;                callback();            &#125;, <span class="hljs-literal">false</span>);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (script.attachEvent) &#123;            script.attachEvent(<span class="hljs-string">'onreadystatechange'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;                <span class="hljs-keyword">var</span> target = <span class="hljs-built_in">window</span>.event.srcElement;                <span class="hljs-keyword">if</span> (target.readyState == <span class="hljs-string">'loaded'</span>) &#123;                    callback();                &#125;            &#125;);        &#125;        head.appendChild(script);    &#125;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadlive2d</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">document</span>.body.clientWidth &gt; <span class="hljs-number">600</span>) &#123;            <span class="hljs-built_in">document</span>.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">document</span>.readyState == <span class="hljs-string">"complete"</span>) &#123;                    loadScript(<span class="hljs-string">'https://npm.elemecdn.com/chenyfan-os@0.0.0-r1/load.js'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;                        loadModel();&#125;)                &#125;            &#125;        &#125;    &#125;loadlive2d()</code></pre></div><p><code>document.body.clientWidth</code>判断可见宽度，<code>loadScript</code>强制异步执行loadModel，丢上去就行了</p><p>然后你就可以正常使用live2d了，这是一个demo：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">    <span class="hljs-selector-class">.live2d</span> &#123;        <span class="hljs-attribute">position</span>: fixed;        <span class="hljs-attribute">left</span>: -<span class="hljs-number">100px</span>;        <span class="hljs-attribute">bottom</span>: -<span class="hljs-number">20px</span>;        <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span> <span class="hljs-meta">!important</span>;        <span class="hljs-attribute">height</span>: <span class="hljs-number">437.5px</span> <span class="hljs-meta">!important</span>;        <span class="hljs-attribute">z-index</span>: <span class="hljs-number">998</span>;    &#125;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"live2d"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"live2d"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">canvas</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"live2dm"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"live2d"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"z-index: 999!important;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">canvas</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://npm.elemecdn.com/chenyfan-oss@2.0.3"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p><img src="https://npm.elemecdn.com/chenyfan-cdn@2.0.0-img/hpp_upload/1618822975000.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>然后添加到Hexo就改模板吧…没什么好说的<img src="https://npm.elemecdn.com/chenyfan-oss@1.1.8/5896ec2cb7f39.gif" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;2019-7-16 本站建成，第二天，Z16进入了我的博客。今天，我更换了陪伴我641天的看板娘。&lt;/p&gt;</summary>
    
    
    
    <category term="随心记" scheme="https://blog.cyfan.top/categories/随心记/"/>
    
    
    <category term="Live2d" scheme="https://blog.cyfan.top/tags/Live2d/"/>
    
    <category term="Z16" scheme="https://blog.cyfan.top/tags/Z16/"/>
    
    <category term="Laffey" scheme="https://blog.cyfan.top/tags/Laffey/"/>
    
  </entry>
  
  <entry>
    <title>看毛片(KMP)算法小记</title>
    <link href="https://blog.cyfan.top/p/cef76c6c.html"/>
    <id>https://blog.cyfan.top/p/cef76c6c.html</id>
    <published>2021-04-07T11:22:12.000Z</published>
    <updated>2022-01-16T12:23:54.551Z</updated>
    
    <content type="html"><![CDATA[<p>一直摸鱼的CYF突然安静了下来,因为他想学学一个别人都会的算法。</p><a id="more"></a><p><del>我菜就是菜，只能学别人早就会的算法了</del></p><p>先贴维基链接【讲的比CSDN清楚，自己访问】</p><p><a href="https://zh.wikipedia.org/wiki/KMP%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/KMP%E7%AE%97%E6%B3%95</a></p><p>长串匹配短串，基本上DP打一遍就冲了。</p><p>DP本质简单的很：</p><div class="hljs"><pre><code class="hljs undefined">匹配串：ABCDPOPABQO待匹配串：ABQ</code></pre></div><p>开始匹配</p><div class="hljs"><pre><code class="hljs undefined">ABCDPOPABQO↑ABQ↑ABCDPOPABQO ↑ABQ ↑ ABCDPOPABQO  ↑ABQ  ↑  ABCDPOPABQO ↑ ABQ ↑...</code></pre></div><p>显而易见，这种复杂度极高【O(m*n)】，当然，冲个入门级别的绝对没问题</p><p>然而类似基因匹配这种数量级恶心心的东西，DP绝对是不够的。</p><p>或者说一个恶心的数据</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attribute">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAB</span></code></pre></div><p>这样如果直接硬DP，那绝对TLE。</p><p>于是，我们选择一个简单的算法，<span class="heimu">看毛片</span> KMP算法，他可以很好的提升我们匹配的效率</p><h1 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h1><p>首先名字很有意思，之所以叫做KMP，是因为这个算法是由Knuth、Morris、Pratt三个提出来的，取了这三个人的名字的头一个字母。</p><h2 id="跳过已匹配字符"><a href="#跳过已匹配字符" class="headerlink" title="跳过已匹配字符"></a>跳过已匹配字符</h2><p>扯远了，将匹配方式简单讲一下</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attribute">ABCDPOPABQO</span>↑ABQ↑匹配，指针右移【以下未特殊表明均指针】ABCDPOPABQO ↑ABQ ↑ 匹配，右移ABCDPOPABQO  ↑ABQ  ↑</code></pre></div><p>这时候我们撞上了不匹配的情景，怎么办？右移一位？</p><p>不，我们发现原串里面的<code>C</code>在待匹配串里面根本没出现，并且原串[0]~[2]均不匹配，所以我们选择把匹配串整个向右移动三位</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attribute">ABCDPOPABQO</span>   ↑   ABQ   ↑   不匹配，字符串右移一位ABCDPOPABQO↑    ABQ    ↑   省略数步ABCDPOPABQO       ↑       ABQ       ↑   匹配，右移ABCDPOPABQO        ↑       ABQ        ↑匹配，右移ABCDPOPABQO         ↑       ABQ         ↑匹配，右移这时候待匹配串已匹配完毕，记录并将整个串移动到末尾ABCDPOPABQO          ↑          ABQ          ↑  待匹配串已超过原串长度，结束</code></pre></div><h2 id="部分匹配"><a href="#部分匹配" class="headerlink" title="部分匹配"></a>部分匹配</h2><p>上面的例子可能没有讲到重点，接下来换个例子，部分匹配才是KMP的核心</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attribute">ABCEABCABCDABDABCDABD</span></code></pre></div><p>OK我们开始匹配</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attribute">ABCDABCDABDABCDABD</span>↑ABCDABD↑ABCDABCDABDABCDABD ↑ABCDABD ↑ ABCDABCDABDABCDABD  ↑ABCDABD  ↑ABCDABCDABDABCDABD   ↑ABCDABD   ↑   ABCDABCDABDABCDABD    ↑ABCDABD    ↑ABCDABCDABDABCDABD     ↑ABCDABD     ↑ABCDABCDABDABCDABD      ↑ABCDABD      ↑</code></pre></div><p>这个时候我们发现了原串[6]与比较串不符合,这时候怎么办?直接跳到后面去?</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attribute">ABCDABCDABDABCDABD</span>       ↑       ABCDABD       ↑</code></pre></div><p>好家伙,你会直接丢掉[4]~[10],而这正是我们要匹配的</p><p>所以我们定个小规矩:</p><blockquote><p>移动位数 = 已匹配的字符数 - 对应的部分匹配值</p></blockquote><blockquote><p>换句话说,就是移动到下一个重复片段的地方</p></blockquote><p>所以这个时候我们应该移动<strong>4位</strong>而不是<strong>6位</strong></p><div class="hljs"><pre><code class="hljs undefined">ABCDABCDABDABCDABD<span class="hljs-code">      ↑</span><span class="hljs-code">    ABCDABD</span><span class="hljs-code">      ↑</span><span class="hljs-code">  </span><span class="hljs-bullet">...</span>ABCDABCDABDABCDABD<span class="hljs-code">          ↑</span><span class="hljs-code">    ABCDABD</span><span class="hljs-code">          ↑</span></code></pre></div><p>这个时候我们已经匹配到了一串,那么接下来怎么移?还是直接移动6位?</p><p>不,我们还是要用自己定下的规矩,移动<strong>4位</strong></p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attribute">ABCDABCDABDABCDABD</span>          ↑        ABCDABD          ↑</code></pre></div><p>此时,我们才能将其整个向右移动<strong>2位</strong></p><div class="hljs"><pre><code class="hljs undefined">ABCDABCDABDABCDABD<span class="hljs-code">           ↑</span><span class="hljs-code">           ABCDABD</span><span class="hljs-code">           ↑</span><span class="hljs-code">   </span><span class="hljs-bullet">...</span>ABCDABCDABDABCDABD<span class="hljs-code">                 ↑</span><span class="hljs-code">           ABCDABD</span><span class="hljs-code">                 ↑</span></code></pre></div><p>OK我们将其匹配完毕,整个<code>ABCDABCDABDABCDABD</code>包含两处<code>ABCDABD</code></p><h2 id="部分匹配表"><a href="#部分匹配表" class="headerlink" title="部分匹配表"></a>部分匹配表</h2><p>这是一张神奇的表格</p><p>首先我们搞清楚前缀和后缀是什么</p><p><code>SHITERS</code></p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-selector-tag">-</span> 前缀<span class="hljs-selector-tag">Q</span><span class="hljs-selector-attr">[<span class="hljs-string">'S'</span>,<span class="hljs-string">'SH'</span>,<span class="hljs-string">'SHI'</span>,<span class="hljs-string">'SHIT'</span>,<span class="hljs-string">'SHITE'</span>,<span class="hljs-string">'SHITER'</span>]</span><span class="hljs-selector-tag">-</span> 后缀<span class="hljs-selector-tag">H</span><span class="hljs-selector-attr">[<span class="hljs-string">'HITERS'</span>,<span class="hljs-string">'ITERS'</span>,<span class="hljs-string">'TERS'</span>,<span class="hljs-string">'ERS'</span>,<span class="hljs-string">'RS'</span>,<span class="hljs-string">'S'</span>]</span></code></pre></div><p>“部分匹配值”就是”前缀”和”后缀”的最长的共有元素的长度</p><p>那么<code>SHITERS</code>的部分匹配值是多少呢?相当于Q和H里面有几个元素是共存的?</p><p>答,一个</p><p>所以,其<code>S</code>部分匹配值是1，而其他均为0</p><p>所以这张表有什么用?和部分匹配表有什么关系?</p><p>回到之前的,我们会发现有些时候往后匹配时有时候后缀和前缀会相同,那么匹配值向右移动就是其部分匹配值。</p><h1 id="尝试上手"><a href="#尝试上手" class="headerlink" title="尝试上手"></a>尝试上手</h1><h2 id="板子题P3375"><a href="#板子题P3375" class="headerlink" title="板子题P3375"></a>板子题<a href="https://www.luogu.com.cn/problem/P3375" target="_blank" rel="noopener">P3375</a></h2><p>匹配这样子就是有手就行，而所谓的<code>border</code>其实就是部分匹配值<del>比较扯淡的是第一次看的时候就是没搞懂border</del></p><p>扯皮点，直接搞getfail</p><div class="hljs"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getfail</span><span class="hljs-params">(<span class="hljs-keyword">int</span> plen)</span></span>&#123;    border[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;plen;i++)&#123;        <span class="hljs-keyword">int</span> j=border[i];        <span class="hljs-keyword">while</span>(j&amp;&amp;p[i]!=p[j]) j=border[j];<span class="hljs-keyword">if</span>(p[i]==p[j])border[i+<span class="hljs-number">1</span>]=j+<span class="hljs-number">1</span>;    &#125;&#125;</code></pre></div><p>然后夹带上主代码直接冲了</p><div class="hljs"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> M 1000000</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-comment">//脚手架</span><span class="hljs-keyword">char</span> c[M],p[M];<span class="hljs-keyword">int</span> border[M];<span class="hljs-comment">//...getfail丢着</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,c);<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,p);    <span class="hljs-keyword">int</span> clen=<span class="hljs-built_in">strlen</span>(c);<span class="hljs-keyword">int</span> plen=<span class="hljs-built_in">strlen</span>(p);    getfail(plen);    <span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;clen;i++)&#123;        <span class="hljs-keyword">while</span>(j&amp;&amp;p[j]!=c[i]) j=border[j];        <span class="hljs-keyword">if</span>(p[j]==c[i]) j++;        <span class="hljs-keyword">if</span>(j==plen) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,i-plen+<span class="hljs-number">2</span>);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=plen;i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,border[i]);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;一直摸鱼的CYF突然安静了下来,因为他想学学一个别人都会的算法。&lt;/p&gt;</summary>
    
    
    
    <category term="摸鱼小记" scheme="https://blog.cyfan.top/categories/摸鱼小记/"/>
    
    
    <category term="算法" scheme="https://blog.cyfan.top/tags/算法/"/>
    
    <category term="C++" scheme="https://blog.cyfan.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Euserv正确打开优化方式</title>
    <link href="https://blog.cyfan.top/p/d788bdf3.html"/>
    <id>https://blog.cyfan.top/p/d788bdf3.html</id>
    <published>2021-03-14T03:12:41.000Z</published>
    <updated>2022-01-16T12:23:54.551Z</updated>
    
    <content type="html"><![CDATA[<p>Euserv，盛名远扬【老白嫖怪了】，但是如何合理打开它，却是一个难题。这篇文章就是简单讲讲合理使用其免费的纯IPv6小鸡</p><a id="more"></a><p>首先是bench测试普通小鸡</p><div class="hljs"><pre><code class="hljs sh">---------------------------------------------------------------------- CPU Model             : AMD Phenom(tm) II X6 1055T Processor CPU Cores             : 1 CPU Frequency         : 3101.198 MHz CPU Cache             : 512 KB Total Disk            : 9.8 GB (3.4 GB Used) Total Mem             : 976 MB (334 MB Used) Total Swap            : 976 MB (0 MB Used) System uptime         : 76 days, 21 hour 6 min Load average          : 16.17, 19.45, 20.53 OS                    : CentOS Linux release 7.9.2009 (Core) Arch                  : x86_64 (64 Bit) Kernel                : 4.20.8-1.el7.elrepo.x86_64 TCP CC                : cubic Virtualization        : LXC Organization          : AS29432 TREX Regional Exchanges Oy Region                : Pirkanmaa---------------------------------------------------------------------- I/O Speed(1st run)    : 19.3 MB/s I/O Speed(2nd run)    : 28.5 MB/s I/O Speed(3rd run)    : 34.0 MB/s Average I/O speed     : 27.3 MB/s---------------------------------------------------------------------- Node Name        Upload Speed      Download Speed      Latency      Speedtest.net    288.12 Mbps       350.72 Mbps         46.84 ms</code></pre></div><p>这是一张简单优化后的小鸡</p><div class="hljs"><pre><code class="hljs sh">---------------------------------------------------------------------- CPU Model             : Intel(R) Xeon(R) CPU E3-1270 v3 @ 3.50GHz CPU Cores             : 1 CPU Frequency         : 3740.322 MHz CPU Cache             : 8192 KB Total Disk            : 9.8 GB (0.9 GB Used) Total Mem             : 976 MB (60 MB Used) Total Swap            : 976 MB (0 MB Used) System uptime         : 0 days, 0 hour 36 min Load average          : 5.06, 6.01, 7.01 OS                    : Debian GNU/Linux 10 Arch                  : x86_64 (64 Bit) Kernel                : 4.20.8-1.el7.elrepo.x86_64 TCP CC                : cubic Virtualization        : LXC Organization          : AS13335 Cloudflare, Inc. Location              : Frankfurt am Main / DE Region                : Hesse---------------------------------------------------------------------- I/O Speed(1st run)    : 71.8 MB/s I/O Speed(2nd run)    : 58.1 MB/s I/O Speed(3rd run)    : 57.3 MB/s Average I/O speed     : 62.4 MB/s---------------------------------------------------------------------- Node Name        Upload Speed      Download Speed      Latency      Speedtest.net    203.45 Mbps       105.67 Mbps         9.28 ms      Beijing    CU    71.94 Mbps        112.58 Mbps         271.97 ms    Shanghai   CU    89.92 Mbps        111.97 Mbps         245.60 ms    Guangzhou  CT    0.18 Mbps         131.79 Mbps         234.00 ms    Guangzhou  CU    103.38 Mbps       118.68 Mbps         284.22 ms    Shenzhen   CU    82.26 Mbps        115.67 Mbps         268.41 ms    Hongkong   CN    81.69 Mbps        141.33 Mbps         274.20 ms    Singapore  SG    99.51 Mbps        108.96 Mbps         330.77 ms    Tokyo      JP    104.81 Mbps       85.70 Mbps          246.56 ms   ----------------------------------------------------------------------</code></pre></div><h1 id="安装-Debian10"><a href="#安装-Debian10" class="headerlink" title="安装 - Debian10"></a>安装 - Debian10</h1><p>这里务必要安装Debian系统，不然后面可能会有点小问题</p><p><img src="https://npm.elemecdn.com/chenyfan-cdn@2.0.0/img/hpp_upload/1615692757000.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>可能要很长一段时间，完毕后<code>ServerData</code>记录ipv6地址和密码备用</p><h1 id="链接SSH"><a href="#链接SSH" class="headerlink" title="链接SSH"></a>链接SSH</h1><p>由于次小鸡用的是纯ipv6,鉴于国内ipv6的部署情况您很有可能连接不上,请选择以下六种方式链接</p><ul><li>CloudFlareSpectrum + UcloudGlobalSSH</li><li>嘿哟终端</li><li>ZeroTier虚拟局域网</li><li>挂ipv6代理</li><li>使用另一台已安装宝塔的Euserv小鸡,用宝塔自带的终端ssh中继到另一台服务器</li><li>使用ipv4+ipv6双栈vps,用ssh链接</li></ul><p>篇幅所限,只讲第一种</p><h2 id="CloudFlareSpectrum-UcloudGlobalSSH"><a href="#CloudFlareSpectrum-UcloudGlobalSSH" class="headerlink" title="CloudFlareSpectrum + UcloudGlobalSSH"></a>CloudFlareSpectrum + UcloudGlobalSSH</h2><p><strong>这个方案比较推荐,就是需要白嫖一个CloudFlarePro</strong></p><p> UcloudGlobalSSH只能支持ipv4,所以你需要一个CloudFlareSpectrum中继</p><p>CloudFlareSpectrum每月5GB流量,仅SSH链接完全足够</p><p><img src="https://npm.elemecdn.com/chenyfan-cdn@2.0.0/img/hpp_upload/1615692972000.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p><img src="https://npm.elemecdn.com/chenyfan-cdn@2.0.0/img/hpp_upload/1615693007000.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p><img src="https://npm.elemecdn.com/chenyfan-cdn@2.0.0/img/hpp_upload/1615693064000.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p><img src="https://npm.elemecdn.com/chenyfan-cdn@2.0.0/img/hpp_upload/1615693130000.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>这一步之后需要注意解析你的专属ip，CloudFlareSpectrum使用的ip不是供用的。</p><p>Windows命令提示符使用</p><div class="hljs"><pre><code class="hljs cmd">nslookup abc.cyfan.top.cdn.cloudflare.<span class="hljs-built_in">net</span></code></pre></div><p>或者使用我的DNS over HTTPS</p><div class="hljs"><pre><code class="hljs url">https://api.cyfan.top/ohhhdns?name=abc.cyfan.top.cdn.cloudflare.net&amp;host=true</code></pre></div><p>请自己更改abc.cyfan.top这个域名。</p><p>解析的ip形如<code>172.65.124.0</code>,但这个ip并不好,三网都很差,所以用UcloudGlobalSSH</p><p>UcloudGlobalSSH拥有免费版一天1GB,完全足矣</p><p><a href="https://console.ucloud.cn/upathx/globalssh" target="_blank" rel="noopener">https://console.ucloud.cn/upathx/globalssh</a></p><p>新建一个隧道</p><p><img src="https://npm.elemecdn.com/chenyfan-cdn@2.0.0/img/hpp_upload/1615693476000.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>将之前解析的ip写入，区域建议香港，点击确定，生成专属域名</p><p><img src="https://npm.elemecdn.com/chenyfan-cdn@2.0.0/img/hpp_upload/1615693543000.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p><img src="https://npm.elemecdn.com/chenyfan-cdn@2.0.0/img/hpp_upload/1615693601000.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>然后链接，我这里用的是XShell，其实客户端自己看喜好</p><p>域名就是ucloud的专属域名，<strong>端口是UC分配给你的而不是22</strong>，922是UC给我的端口，密码是Euserv的密码，用户直接用<code>root</code></p><p><img src="https://npm.elemecdn.com/chenyfan-cdn@2.0.0/img/hpp_upload/1615693743000.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p><img src="https://npm.elemecdn.com/chenyfan-cdn@2.0.0/img/hpp_upload/1615693767000.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>然后就直接链接</p><p><img src="https://npm.elemecdn.com/chenyfan-cdn@2.0.0/img/hpp_upload/1615693951000.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>使用此方式链接方式如下</p><div class="hljs"><pre><code class="hljs undefined">你 - 中国 &lt;=<span class="hljs-attribute">40ms</span>=&gt; Ucloud - 中国香港 &lt;=<span class="hljs-attribute">10ms</span>=&gt; CloudFlareSpectrum - AnyCast &lt;=Argo 横跨北半球,<span class="hljs-attribute">150ms</span>=&gt; Euserv - 德国</code></pre></div><p>也就是说链接直连可以与美国vps媲美</p><h1 id="DNS设置-DNS64"><a href="#DNS设置-DNS64" class="headerlink" title="DNS设置 -DNS64"></a>DNS设置 -DNS64</h1><p>Euserv只有一个ipv6地址,没有ipv4网卡,所以只能链接纯ipv6网站</p><p>使用DNS64可以强制把域名解析到ipv6地址,并且原来只有ipv4的也能通过算法解析到ipv6</p><p>由于你要安装Warp,为了下载来自外网的软件,需要使用DNS64</p><div class="hljs"><pre><code class="hljs undefined">nano <span class="hljs-regexp">/etc/</span>resolv.conf</code></pre></div><p>大概是这样的</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-selector-tag">search</span> <span class="hljs-selector-tag">blue</span><span class="hljs-selector-class">.kundencontroller</span><span class="hljs-selector-class">.de</span><span class="hljs-selector-tag">options</span> <span class="hljs-selector-tag">rotate</span><span class="hljs-selector-tag">nameserver</span> 2<span class="hljs-selector-tag">a02</span><span class="hljs-selector-pseudo">:180</span><span class="hljs-selector-pseudo">:6</span><span class="hljs-selector-pseudo">:5</span><span class="hljs-selector-pseudo">::1c</span><span class="hljs-selector-tag">nameserver</span> 2<span class="hljs-selector-tag">a02</span><span class="hljs-selector-pseudo">:180</span><span class="hljs-selector-pseudo">:6</span><span class="hljs-selector-pseudo">:5</span><span class="hljs-selector-pseudo">::1e</span><span class="hljs-selector-tag">nameserver</span> 2<span class="hljs-selector-tag">a02</span><span class="hljs-selector-pseudo">:180</span><span class="hljs-selector-pseudo">:6</span><span class="hljs-selector-pseudo">:5</span><span class="hljs-selector-pseudo">::1d</span><span class="hljs-selector-tag">nameserver</span> 2<span class="hljs-selector-tag">a02</span><span class="hljs-selector-pseudo">:180</span><span class="hljs-selector-pseudo">:6</span><span class="hljs-selector-pseudo">:5</span><span class="hljs-selector-pseudo">::4</span></code></pre></div><p>删除最后4行nameserver,添加</p><div class="hljs"><pre><code class="hljs undefined">nameserver <span class="hljs-number">2001</span>:67c:<span class="hljs-number">2b0</span>::<span class="hljs-number">4</span>nameserver <span class="hljs-number">2001</span>:67c:<span class="hljs-number">2b0</span>::<span class="hljs-number">6</span></code></pre></div><h1 id="Warp安装-上IPv4地址"><a href="#Warp安装-上IPv4地址" class="headerlink" title="Warp安装 - 上IPv4地址"></a>Warp安装 - 上IPv4地址</h1><blockquote><p>Debian安装时若意外退出则需要相当麻烦解除锁定,所以建立一个稳定的隧道是必须的</p></blockquote><p>首先安装一些必要依赖</p><div class="hljs"><pre><code class="hljs sh">apt updateapt install curl sudo lsb-release -y</code></pre></div><p>添加 back­ports 源,并安装wireguard</p><div class="hljs"><pre><code class="hljs sh"><span class="hljs-built_in">echo</span> <span class="hljs-string">"deb http://deb.debian.org/debian <span class="hljs-variable">$(lsb_release -sc)</span>-backports main"</span> | sudo tee /etc/apt/sources.list.d/backports.listsudo apt updatesudo apt install net-tools iproute2 openresolv dnsutils -ysudo apt install wireguard-tools --no-install-recommends</code></pre></div><p>然后因为是LXC虚拟内核,无奈之下只能使用go语言编译的内核</p><div class="hljs"><pre><code class="hljs sh">curl -fsSL git.io/wireguard-go.sh | sudo bash</code></pre></div><p>安装wgcf【第三方注册器】，注册并生成配置</p><div class="hljs"><pre><code class="hljs sh">curl -fsSL git.io/wgcf.sh | sudo bashwgcf registerwgcf generate</code></pre></div><p>修改配置</p><div class="hljs"><pre><code class="hljs sh">nano wgcf-profile.conf</code></pre></div><p>内容差不多这样：</p><div class="hljs"><pre><code class="hljs sh">[Interface]PrivateKey = xxxAddress = 172.16.0.2/32Address = fd01:5ca1:ab1e:89f5:9dfa:759c:9348:13e6/128DNS = 1.1.1.1MTU = 1280[Peer]PublicKey = xxxAllowedIPs = 0.0.0.0/0AllowedIPs = ::/0Endpoint = engage.cloudflareclient.com:2408</code></pre></div><p>几个关键配置</p><ul><li>第五行DNS改成</li></ul><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attr">DNS</span> = <span class="hljs-number">2606</span>:<span class="hljs-number">4700</span>:<span class="hljs-number">4700</span>::<span class="hljs-number">1111</span></code></pre></div><ul><li><p>删除第十行，否则Warp会托管ipv6</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attr">AllowedIPs</span> = ::/<span class="hljs-number">0</span></code></pre></div></li><li><p>修改第十一行为</p></li></ul><div class="hljs"><pre><code class="hljs undefined">Endpoint = [<span class="hljs-number">2606</span><span class="hljs-symbol">:</span><span class="hljs-number">4700</span><span class="hljs-symbol">:d0</span><span class="hljs-symbol">:</span><span class="hljs-symbol">:a29f</span><span class="hljs-symbol">:c001</span>]<span class="hljs-symbol">:</span><span class="hljs-number">2408</span></code></pre></div><p>输入以下命令</p><div class="hljs"><pre><code class="hljs sh">sudo cp wgcf-profile.conf /etc/wireguard/wgcf.confsudo systemctl start wg-quick@wgcfsudo systemctl <span class="hljs-built_in">enable</span> wg-quick@wgcf<span class="hljs-built_in">echo</span> <span class="hljs-string">'precedence  ::ffff:0:0/96   100'</span> | sudo tee -a /etc/gai.conf</code></pre></div><p>然后ping一下baidu：</p><div class="hljs"><pre><code class="hljs undefined">root@srv10866:~#<span class="hljs-built_in"> ping </span>baidu.com<span class="hljs-built_in">PING </span>baidu.com (220.181.38.148) 56(84) bytes of data.64 bytes <span class="hljs-keyword">from</span> 220.181.38.148 (220.181.38.148): <span class="hljs-attribute">icmp_seq</span>=1 <span class="hljs-attribute">ttl</span>=50 <span class="hljs-attribute">time</span>=452 ms64 bytes <span class="hljs-keyword">from</span> 220.181.38.148 (220.181.38.148): <span class="hljs-attribute">icmp_seq</span>=2 <span class="hljs-attribute">ttl</span>=50 <span class="hljs-attribute">time</span>=300 ms64 bytes <span class="hljs-keyword">from</span> 220.181.38.148 (220.181.38.148): <span class="hljs-attribute">icmp_seq</span>=3 <span class="hljs-attribute">ttl</span>=50 <span class="hljs-attribute">time</span>=302 ms<span class="hljs-built_in">..</span>.^C--- baidu.com<span class="hljs-built_in"> ping </span>statistics ---26 packets transmitted, 23 received, 11.5385% packet loss, time 121msrtt min/avg/max/mdev = 297.390/307.370/451.503/30.906 ms</code></pre></div><p>简单安装besttrace</p><div class="hljs"><pre><code class="hljs sh">wget https://cdn.ipip.net/17mon/besttrace4linux.zipapt-get install zipunzip besttrace4linux.zipchmod +x besttrace</code></pre></div><p>路由到CF网络都是一步到位</p><div class="hljs"><pre><code class="hljs sh">root@srv10866:~<span class="hljs-comment"># ./besttrace -q 1 1.0.0.1</span>traceroute to 1.0.0.1 (1.0.0.1), 30 hops max, 32 byte packets 1  one.one.one.one (1.0.0.1)  9.61 ms  AS13335  CLOUDFLARE.COM, apnic.netroot@srv10866:~<span class="hljs-comment"># ./besttrace -q 1 cloudflare.com</span>traceroute to cloudflare.com (104.16.133.229), 30 hops max, 32 byte packets 1  104.16.133.229  13.62 ms  AS13335  CLOUDFLARE.COM, cloudflare.com</code></pre></div><p>路由到谷歌，那就是穿透一层内网直接出去</p><div class="hljs"><pre><code class="hljs sh">root@srv10866:~<span class="hljs-comment"># ./besttrace -q 1 google.com</span>traceroute to google.com (142.250.186.46), 30 hops max, 32 byte packets 1  172.16.0.1  9.45 ms  *  LAN Address 2  162.158.82.1  18.34 ms  AS13335  Germany, Hesse, Frankfurt, cloudflare.com 3  162.158.84.5  10.08 ms  AS13335  Germany, Hesse, Frankfurt, cloudflare.com 4  108.170.251.129  28.06 ms  AS15169  United States, google.com 5  172.253.71.89  11.58 ms  AS15169  United States, google.com 6  fra24s04-in-f14.1e100.net (142.250.186.46)  12.48 ms  AS15169  Germany, Hesse, Frankfurt, google.com</code></pre></div><p>路由到百度就很有意思，从HKG出去进入移动CMI北上北京</p><blockquote><p>去年10月移动在欧洲和cf做的对等互联,因为遵循路由链最短原则,电信和联通在欧洲没有比这个更短的,到联通是cf-gtt-联通,到电信是cf-level3-电信,到移动是cf-移动,所以会走移动<br>金句From – <a href="https://www.puresys.net/" target="_blank" rel="noopener">CLAM</a></p></blockquote><div class="hljs"><pre><code class="hljs sh">root@srv10866:~<span class="hljs-comment"># ./besttrace -q 1 baidu.com</span>traceroute to baidu.com (39.156.69.79), 30 hops max, 32 byte packets 1  172.16.0.1  9.50 ms  *  LAN Address 2  162.158.82.1  10.37 ms  AS13335  Germany, Hesse, Frankfurt, cloudflare.com 3  223.119.65.37  20.01 ms  AS58453  China, Hong Kong, ChinaMobile 4  * 5  221.183.46.250  257.40 ms  AS9808  China, ChinaMobile 6  221.176.27.253  200.99 ms  AS9808  China, ChinaMobile 7  111.24.2.241  202.99 ms  AS9808  China, ChinaMobile 8  * 9  39.156.27.1  203.69 ms  AS9808  China, Beijing, ChinaMobile10  *11  *12  *13  *14  39.156.69.79  259.35 ms  AS9808  China, Beijing, ChinaMobile</code></pre></div><p>Speedtest</p><div class="hljs"><pre><code class="hljs sh">curl -fsSL git.io/speedtest-cli.sh | sudo bashspeedtest</code></pre></div><p>返回</p><div class="hljs"><pre><code class="hljs sh">   Speedtest by Ookla     Server: RETN - Frankfurt (id = 31120)        ISP: Cloudflare Warp    Latency:     9.88 ms   (0.11 ms jitter)   Download:   112.57 Mbps (data used: 101.0 MB)                                    Upload:   127.19 Mbps (data used: 115.5 MB)                               Packet Loss:     0.0% Result URL: https://www.speedtest.net/result/c/556afff6-e56a-4d53-844b-fe88b562ceb8</code></pre></div><p>速度不快,但是起码上ipv4了</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Euserv，盛名远扬【老白嫖怪了】，但是如何合理打开它，却是一个难题。这篇文章就是简单讲讲合理使用其免费的纯IPv6小鸡&lt;/p&gt;</summary>
    
    
    
    <category term="白嫖怪" scheme="https://blog.cyfan.top/categories/白嫖怪/"/>
    
    
    <category term="白嫖" scheme="https://blog.cyfan.top/tags/白嫖/"/>
    
    <category term="Euserv" scheme="https://blog.cyfan.top/tags/Euserv/"/>
    
  </entry>
  
  <entry>
    <title>失败的光速叛逃！CloudFlarePage初体验</title>
    <link href="https://blog.cyfan.top/p/363f2ff1.html"/>
    <id>https://blog.cyfan.top/p/363f2ff1.html</id>
    <published>2021-02-20T01:24:00.000Z</published>
    <updated>2022-01-16T12:23:54.551Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，CloudFlare曾开放CloudFlarePage内测资格申请，如今我获得了资格，免费享受边缘部署岂不美哉！可万万没想到，简单的迁移过程会出现如此问题</p><a id="more"></a><p>据我所知，使用CloudFlare做hexo无非以下两种：</p><ul><li>GithubPage+CloudFlareCDN</li><li>CloudFlareWorkerKV+ClouFlareWorkerSite</li></ul><p>CloudFlare早先时候支持WorkerSite，当时KV照实没有免费，我也不想为了<code>100ms</code>的回源耗时而花费金钱。不过后来KV在一定额度上免费了，打开WorkerSite的文档，第一步wrangler直接把我劝退。</p><p>笑话，国内使用wrangler，那还不如CloudFlare+GithubPage。</p><p><a href="https://blog.skk.moe/post/deploy-blog-to-cf-workers-site/" target="_blank" rel="noopener">苏卡卡大佬写的一篇文章</a>讲述了自己部署WorkerSite的经历，<a href="https://blog.ichr.me/post/cf-workers-site-deploy/" target="_blank" rel="noopener">ChrAlpha’s Blog</a>也曾提到过迁移的过程。不过我懒<img src="https://npm.elemecdn.com/chenyfan-oss@1.1.11/62.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt>，我觉得<code>100ms</code>回源不算什么，赔个Worker还是有点亏。</p><p>2020年11月份，偶然得知CFPage<a href="https://www.cloudflare.com/zh-cn/pages-jamstack-platform-beta-sign-up/" target="_blank" rel="noopener">正在公开招聘Pagebeta计划</a>，抱着试试看的心理，我简单写了些就交了上去。凭借着对CloudFlare发布新产品小心翼翼的态度，我揣摩估计很难申请到。果不其然，年都过了，连封邮件都没通知我。</p><p>2021年2月20日，我先日常翻了遍邮件，0。正准备继续开发HexoPlusPlus，登陆CloudFlare，却发现右边多了个新玩意：</p><p><img src="https://npm.elemecdn.com/chenyfan-cdn@2.0.0/img/hpp_upload/1613786871000.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p><img src="https://npm.elemecdn.com/chenyfan-oss@1.1.11/156.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>不愧是我，我一眼就看出来我的CFPage申请到了。</p><h1 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h1><p>由于我的博客源码在Github上，而CFPage只能从Github上获取源码。<br>我面向中国大陆CDN有一部分用的也是CloudFlare，通过BNXB第三方接入。<br>因为之前用的就是GithubAction的集成部署，所以<code>package.json</code>已经配置完成了。</p><p>那么我看起来确实是最佳的接入选择。</p><div class="note note-warning">            <p>非常操蛋的是，我无法删除已经添加的CloudFlarePage域名，所以我没有办法重新演示我如何安装，下面的截图是删除时的错误：<br><img src="https://npm.elemecdn.com/chenyfan-cdn@2.0.0/img/hpp_upload/1613787919000.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt><br><img src="https://npm.elemecdn.com/chenyfan-cdn@2.0.0/img/hpp_upload/1613787960000.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p>          </div><p>首先，进去，点击<code>创建项目</code>选择博客的github存储库，获得GithubAccess权限后跳转到这：</p><p><img src="https://npm.elemecdn.com/chenyfan-cdn@2.0.0/img/hpp_upload/1613788198000.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>勾选需要接入的项目</p><p><img src="https://npm.elemecdn.com/chenyfan-cdn@2.0.0/img/hpp_upload/1613788329000.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><ul><li>构建设置 - 框架预设</li></ul><p>由于之前吃过Vercel的亏，不想选Hexo，但是抱着试试看的心态，还是选择了内置的hexo。</p><p>选择之后，后面的构建命令和构建输出也直接填好了，保存并部署？</p><p><img src="https://npm.elemecdn.com/chenyfan-cdn@2.0.0/img/hpp_upload/1613789246000.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><blockquote><p>因为本博客使用了neat而不是gulp插件压缩html<del>管他呢反正丢CI</del>，所以构建时间会比较长。</p></blockquote><p>修改CNAME记录和TXT记录，分别去BNXB修改CNMAE和DNSPOD【NS所在处】修改TXT记录</p><p><img src="https://npm.elemecdn.com/chenyfan-cdn@2.0.0/img/hpp_upload/1613790247000.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p><img src="https://npm.elemecdn.com/chenyfan-cdn@2.0.0/img/hpp_upload/1613790482000.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>就好了？就好了。</p><p><span class="heimu">这是我最快的迁移速度</span></p><p><img src="https://npm.elemecdn.com/chenyfan-cdn@2.0.0/img/hpp_upload/1613789961000.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>NetWork选项卡里出<code>x-server: Cloudflare Pages</code>说明迁移完毕。</p><h1 id="使用体验"><a href="#使用体验" class="headerlink" title="使用体验"></a>使用体验</h1><p>简洁，加载速度快，这是我第一个感受。</p><p>用GithubAction老是卡在同一个界面不会动，要手动刷新一下才能出来，而且加载的东西贼多，我这台破笔记本有点卡。</p><p>CloudFlarePage则轻巧的多，并且部署状况很快就能体现出来。</p><p>无缝切换，这是我的第二个体验。</p><p>以前换CI换CDN的时候，非得断掉先然后才能切换回来，现在两步走之后，直接在dns平台修改无缝迁移，体验良好，总耗时不超过10分钟。</p><p>鉴于CloudFlare在国内的连接情况，电信这一条线我还是切回vercel【也是0回源】，其他的走CloudFlarePage</p><p>平台还是beta，这是第三个感受。</p><p>我删不掉已经添加的域名，这是我最纳闷的一点。</p><p>然后我不想让cfpage检测我的<code>gh-pages</code>分支，因为GithubAction还有存在的必要，但是CFpage每每还是检测pages分支，然后扔出部署失败，提示错误。</p><p>这两个问题<a href="https://community.cloudflare.com/t/cloudflarepagebug-i-cannot-delete-my-site/246093" target="_blank" rel="noopener">我已经丢论坛里了</a>，目前还未回复</p><p>至于快多少，因为没有免费版本Argo做对比，也没有大量数据做对比，<strong>目前</strong>无法得出结论。</p><p>真的要说快多少，因为大部分静态资源切jsd上，所有经过cf的只有一个单html，至少我在国内大环境下，我还没体会出100ms能快多少(´இ皿இ｀)</p><p>另外CloudFlarePage用的证书很奇怪，可能是为了CNAME兼容性，不用自己自家的证书，反而用Let’s Encrypt，鉴于OSCP在国内阻断，ios用户可能会出现首次访问白屏，这一点我有点担心。</p><p>最好的一点莫过于完全贴合HexoPlusPlus了，以后我就有充分的理由宣传HPP了<img src="https://npm.elemecdn.com/chenyfan-oss@1.1.11/320.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><h1 id="额度"><a href="#额度" class="headerlink" title="额度"></a>额度</h1><ul><li>每月构建次数：500次</li></ul><p>【用了HPP，构建次数再多也不够500/mo，这一点我还是放心的，再说我常年咕咕咕】</p><ul><li><p>自定义域名：10个 【我也没这么多域名】</p></li><li><p>文件：2w个【绝对用不完】</p></li><li><p>总大小：25MB【图片啥的都扔图床，其实也就5MB】</p></li><li><p>带宽：无限制【！！！】</p></li></ul><h1 id="然后我切回来了"><a href="#然后我切回来了" class="headerlink" title="然后我切回来了"></a>然后我切回来了</h1><p>高高兴兴的搞完了CFPage部署，<del>水了这篇文章</del>去吃饭。吃完饭后回来一看谷歌统计，好家伙404的怎么这么多。</p><p>还好之前的GithubPage没有删掉，去bnxb赶紧切了回来。</p><p><del>完了我也经历了和Sukka大佬一样的问题</del></p><p>问题很容易定位，所有的404来自cfpage而非vercel。</p><p><img src="https://npm.elemecdn.com/chenyfan-cdn@2.0.0/img/hpp_upload/1613795675000.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>首先是Vercel，开代理的情况下国外访问均正确解析至vercel，可以在<code>x-vercel</code>头里看出来</p><p>地址是<code>https://blog.cyfan.top/p/52382e42.html</code>，相应代码是<code>200</code></p><p><img src="https://npm.elemecdn.com/chenyfan-cdn@2.0.0/img/hpp_upload/1613795874000.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>关闭代理，将自动选择CloudFlareCDN+GithubPage，可以从<code>x-github-request-id</code>看出</p><p>地址是<code>https://blog.cyfan.top/p/52382e42.html</code>，相应代码是<code>200</code></p><p><img src="https://npm.elemecdn.com/chenyfan-cdn@2.0.0/img/hpp_upload/1613796163000.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>然后是有问题的CFPage，可以在<code>x-server</code>头里看出来</p><p>地址是<code>https://blog-9una.pages.dev/p/52382e42.html</code>，相应代码是<code>308</code><strong>跳转</strong>，跳向<code>https://blog-9una.pages.dev/p/52382e42</code>，<strong>CFPage会把末尾.html抹掉</strong></p><p>抹掉就罢了,结果在vercel这边又出问题</p><p><img src="https://npm.elemecdn.com/chenyfan-cdn@2.0.0/img/hpp_upload/1613796374000.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>但是最奇葩的是,githubpage是允许不带html裸访</p><p><img src="https://npm.elemecdn.com/chenyfan-cdn@2.0.0/img/hpp_upload/1613796456000.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>这就是整个经过,CFPage必须抹掉后缀,GithubPage保持无所谓,Vercel必须不能抹掉</p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>先从自己入手，CFPage和vercel不能共留，干掉vercel？好主意，毕竟国内访问CF并无大碍，但是有个大问题梗在面前，评论怎么办，之前的收录怎么办，首页链接不一致怎么办？</p><p>我又不想抛弃CFpage，于是试图和Sukka大佬针对中文解码一样来个拯救计划，结果发现，CFPage不开源……</p><p>后来仔细翻了一遍<a href="https://developers.cloudflare.com/pages/platform/serving-pages#route-matching" target="_blank" rel="noopener">文档</a>才发现，这样是有意为之，故意删掉后缀名。</p><p>的，切回Github+CFCDN，这一早上的折腾白费了( ง ᵒ̌皿ᵒ̌)ง⁼³₌₃</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;众所周知，CloudFlare曾开放CloudFlarePage内测资格申请，如今我获得了资格，免费享受边缘部署岂不美哉！可万万没想到，简单的迁移过程会出现如此问题&lt;/p&gt;</summary>
    
    
    
    <category term="好方法" scheme="https://blog.cyfan.top/categories/好方法/"/>
    
    
    <category term="CloudFlare" scheme="https://blog.cyfan.top/tags/CloudFlare/"/>
    
    <category term="Hexo" scheme="https://blog.cyfan.top/tags/Hexo/"/>
    
    <category term="集成部署" scheme="https://blog.cyfan.top/tags/集成部署/"/>
    
    <category term="CloudFlarePage" scheme="https://blog.cyfan.top/tags/CloudFlarePage/"/>
    
  </entry>
  
  <entry>
    <title>HexoPlusPlus-从一个妄想到现实</title>
    <link href="https://blog.cyfan.top/p/348e7d8a.html"/>
    <id>https://blog.cyfan.top/p/348e7d8a.html</id>
    <published>2021-02-11T07:40:00.000Z</published>
    <updated>2022-01-16T12:23:54.551Z</updated>
    
    <content type="html"><![CDATA[<p>我一直都习惯在线写作，但因为口袋里没钱，不能买服务器用动态博客，使用Hexo，即使实现了集成部署，想要在github上直接书写，尤其是出门在外有所灵感，国内手机登陆github真的是极其糟糕的体验。博客本就是碎片化写作和高质量文章发布处，使用hexo却使我无法发挥博客的用处。</p><a id="more"></a><p>先前，我曾使用白嫖的Euserv搭建的Typecho，也是用过wordpress.com白嫖的wordpress，但两个都不符合我对速度和可用性的追求，一个连CloudFlare能不能连上都是问题，另一个中国支持贼差【虽然可以用万能Worker可以替换加解决,但是就是不想用啊】。免空的选择又难以择手<img src="https://npm.elemecdn.com/chenyfan-oss@1.1.11/194.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt>，弄来弄去还是用回Hexo。</p><p>但是Hexo就是有一点不爽，每次使用的时候就必须要在本地进行构建静态网页，然后上传到GithubPage。后来实现了集成部署【没想到折腾了很长时间的集成部署最后用到这里了】，方便了不少，直接在Github上面改源代码。但相较于Typecho和Wordpress，没有后台的写作总感觉有点难受<img src="https://npm.elemecdn.com/chenyfan-oss@1.1.8/5896e9710dfd5.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt>，每次更改源代码都要上Github<img src="https://npm.elemecdn.com/chenyfan-oss@1.1.8/5896ece2ab57a.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt>，在国内这种大环境下总是不太好使的。</p><p>2020年最后一个月，我总是在想如何解决这个问题，我的要求很简单，能弄个在线书写环境就好了。</p><p>在当时，真的只是睡觉的时候想想，现在回头不禁感慨，这妄想真的实现了。</p><p>由于我的文件是存储在Github上，于是我第一个先去Github文档查找相关资料，果不其然，Github的API能够上传、删除、下载【废话】、列表文件，并且能通过base64上传，直接免去了手写头的问题.关于调用限制，没鉴权时每个ip每小时只有<strong>60次</strong>，但一旦鉴权每个用户每小时就有<strong>5000次</strong>。这些api完全能够支撑起一个在线写作的环境,<a href="https://developer.github.com/v3/guides/getting-started/" target="_blank" rel="noopener">https://developer.github.com/v3/guides/getting-started/</a>更是详细讲解并提供了数个例子。</p><p>这篇文章,就是详细讲解我如何把这个梦想变成现实.具体步骤很多,请慢慢咀嚼<img src="https://npm.elemecdn.com/chenyfan-oss@1.1.8/5896ece2ab57a.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><blockquote><p><strong>这篇不是<a href="https://hexoplusplus.js.org/" target="_blank" rel="noopener">使用文档</a>,而是教程</strong></p></blockquote><h1 id="原理-GithubAPI"><a href="#原理-GithubAPI" class="headerlink" title="原理 - GithubAPI"></a>原理 - GithubAPI</h1><p>譬如罢，上传一个文件，首先你要鉴权，在header中写入：</p><div class="hljs"><pre><code class="hljs url">content-type: &quot;application/json;charset=UTF-8&quot;Authorization: &quot;token  $&#123;hpp_githubimagetoken&#125;&quot;</code></pre></div><blockquote><p>Anyone,你也可以在url后面加上<code>?access_token=</code>传参，但是这样不安全，Github官方也是提示将在明年彻底禁用传参鉴权</p></blockquote><p>但是记得GithubAPI不允许空User-Agent，所以你还得在header中加入UA：</p><div class="hljs"><pre><code class="hljs url">user-agent: &quot;GoogleChrome&quot;,</code></pre></div><p>OK这么一搞鉴权这一块就完毕了，接下来，我们要搞基本功能</p><p>Github更改一个文件的url是一样的，为了方便接下来的书写和表达，我们统一将以下url称为RESTURL：</p><div class="hljs"><pre><code class="hljs url">https://api.github.com/repos/$&#123;Github用户名&#125;/$&#123;Github仓库名字&#125;/contents/$&#123;Github文件路径&#125;/$&#123;Github文件名&#125;?ref=$&#123;Github分支&#125;</code></pre></div><h2 id="拉取信息"><a href="#拉取信息" class="headerlink" title="拉取信息"></a>拉取信息</h2><p>默认情况下，直接<code>GET</code> <code>RESTURL</code>就能获取该文件/文件夹的信息,例如获取我<code>AVorBV.md</code>源文件,那么<code>RESTURL</code>如下:</p><div class="hljs"><pre><code class="hljs undefined">https:<span class="hljs-regexp">//</span>api.github.com<span class="hljs-regexp">/repos/</span>ChenYFan<span class="hljs-regexp">/blog/</span>contents<span class="hljs-regexp">/source/</span>_posts<span class="hljs-regexp">/AVorBV.md?ref=master</span></code></pre></div><p>直接<code>GET</code>[我的是公开仓库,不需要鉴权就能获取],得到数据如下:</p><div class="hljs"><pre><code class="hljs json">&#123;<span class="hljs-attr">"name"</span>: <span class="hljs-string">"AVorBV.md"</span>,<span class="hljs-attr">"path"</span>: <span class="hljs-string">"source/_posts/AVorBV.md"</span>,<span class="hljs-attr">"sha"</span>: <span class="hljs-string">"a0bd826f999a9bb73ac56251415f9e57199600a7"</span>,<span class="hljs-attr">"size"</span>: <span class="hljs-number">15742</span>,<span class="hljs-attr">"url"</span>: <span class="hljs-string">"https://api.github.com/repos/ChenYFan/blog/contents/source/_posts/AVorBV.md?ref=master"</span>,<span class="hljs-attr">"html_url"</span>: <span class="hljs-string">"https://github.com/ChenYFan/blog/blob/master/source/_posts/AVorBV.md"</span>,<span class="hljs-attr">"git_url"</span>: <span class="hljs-string">"https://api.github.com/repos/ChenYFan/blog/git/blobs/a0bd826f999a9bb73ac56251415f9e57199600a7"</span>,<span class="hljs-attr">"download_url"</span>: <span class="hljs-string">"https://raw.githubusercontent.com/ChenYFan/blog/master/source/_posts/AVorBV.md"</span>,<span class="hljs-attr">"type"</span>: <span class="hljs-string">"file"</span>,<span class="hljs-attr">"content"</span>: <span class="hljs-string">"dGl0bGU6IEFWP0JWIQphdX..."</span>,<span class="hljs-attr">"encoding"</span>: <span class="hljs-string">"base64"</span>,<span class="hljs-attr">"_links"</span>: &#123;<span class="hljs-attr">"self"</span>: <span class="hljs-string">"https://api.github.com/repos/ChenYFan/blog/contents/source/_posts/AVorBV.md?ref=master"</span>,<span class="hljs-attr">"git"</span>: <span class="hljs-string">"https://api.github.com/repos/ChenYFan/blog/git/blobs/a0bd826f999a9bb73ac56251415f9e57199600a7"</span>,<span class="hljs-attr">"html"</span>: <span class="hljs-string">"https://github.com/ChenYFan/blog/blob/master/source/_posts/AVorBV.md"</span>&#125;&#125;</code></pre></div><p>这样子,我们只要提取json中的sha,就能知道到hash,进而进行修改.<br>但这样子有个非常尴尬的一点,单文件获取会把<code>content</code>一口气拿过来<br>例如下面的<code>RESTURL</code></p><div class="hljs"><pre><code class="hljs url">https://api.github.com/repos/ChenYFan/CDN/contents/img/hpp_upload/1612843011000.jpg?ref=master</code></pre></div><p>你获取的时候会发现返回了这个:</p><div class="hljs"><pre><code class="hljs json">&#123;<span class="hljs-attr">"message"</span>: <span class="hljs-string">"This API returns blobs up to 1 MB in size. The requested blob is too large to fetch via the API, but you can use the Git Data API to request blobs up to 100 MB in size."</span>,<span class="hljs-attr">"errors"</span>: [&#123;<span class="hljs-attr">"resource"</span>: <span class="hljs-string">"Blob"</span>,<span class="hljs-attr">"field"</span>: <span class="hljs-string">"data"</span>,<span class="hljs-attr">"code"</span>: <span class="hljs-string">"too_large"</span>&#125;],<span class="hljs-attr">"documentation_url"</span>: <span class="hljs-string">"https://docs.github.com/rest/reference/repos#get-repository-content"</span>&#125;</code></pre></div><p>很显然,直接用GithubAPI不能获取单个文件的hash值</p><p>那怎么办？</p><p>答：列表获取</p><p>我们把之前的<code>RESTURL</code>去掉小尾巴,变成这样:</p><div class="hljs"><pre><code class="hljs url">https://api.github.com/repos/ChenYFan/CDN/contents/img/hpp_upload?ref=master</code></pre></div><p>这样就能获取这个目录下整个列表,然后用json循环查找遍历name,再通过name拉hash即可.</p><p>只是这样查询时间会略微变长.</p><h2 id="新建"><a href="#新建" class="headerlink" title="新建"></a>新建</h2><p>如果是新建,body中这么写</p><div class="hljs"><pre><code class="hljs json">&#123;    branch: $&#123;上传的分支&#125;,    message: $&#123;上传的信息&#125;,    content: $&#123;base64过的文件&#125;,     sha: ""&#125;</code></pre></div><p>接着使用<code>PUT</code>形式访问RESTURL</p><p>创建成功后状态码应该返回：</p><div class="hljs"><pre><code class="hljs status">201 Created</code></pre></div><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>body与新建类似，但是首先你要通过拉取信息获取该文件sha值.</p><div class="hljs"><pre><code class="hljs json">&#123;    branch: $&#123;上传的分支&#125;,    message: $&#123;上传的信息&#125;,    content: $&#123;base64过的文件&#125;,     sha: "$&#123;此文件hash&#125;"&#125;</code></pre></div><p>接着使用<code>PUT</code>形式访问<code>RESTURL</code></p><p>更新成功后状态码应该返回：</p><div class="hljs"><pre><code class="hljs status">200 OK</code></pre></div><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>相对来说,删除就更简单了</p><div class="hljs"><pre><code class="hljs json">&#123;    branch: $&#123;删除文件的分支&#125;,    message: $&#123;删除的信息&#125;,    sha: "$&#123;此文件hash&#125;"&#125;</code></pre></div><p>hash这一步逃不掉,用<code>DELETE</code>形式访问<code>RESTURL</code>,返回<code>200</code>说明删除成功</p><h1 id="原理-CloudFlareWorkers"><a href="#原理-CloudFlareWorkers" class="headerlink" title="原理 - CloudFlareWorkers"></a>原理 - CloudFlareWorkers</h1><p>之前看过<a href="https://github.com/GitHub-Laziji/VBlog" target="_blank" rel="noopener">Laziji-VBlog</a>项目,这个项目新颖的一点是将文章发布在gists,然后用户通过api访问获取.</p><p>但这样有两个致命问题:</p><p>1.API没鉴权，每小时单个ip只能访问60次，一开就爆<br>2.在国内受干扰，不稳定</p><p>并且什么迁入迁出麻烦、token容易忘记等等问题</p><p>最最最早版本中,我是打算纯静态实现文章编辑和更改的，但很快我就遇到了和VBlog一样的缺陷，这逼使我切换了平台。</p><p>好诶，既然直连效果那么差，我们就选择中继。利用服务器中继我们首先排除【用Hexo基本就是贪无服务器】。目前比较流行的无服务器平台有Heroku、CloudFlareWorker和Vercel，Heroku支持了多种服务器语言，CFWorker基于GoogleV8，因为JSProxy在国内意外走红，Vercel在国内拥有较好的运营商线路。</p><p>我们第一个排除heroku，冷启动唤醒需要10s，并且无法绑定域名【这里其实也可用worker反代（bushi】。目光看向worker和vercel，又有一个新问题出来，自定义配置存哪？<img src="https://npm.elemecdn.com/chenyfan-oss@1.1.8/5896e6ec1d528.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>存变量里当然是个好主意，但是很难修改。外部存储也不是什么大问题，mongodb、firebase、<del>Leancloud</del>都可以上手，但我个人终究不喜欢为了查询而发送子请求。<img src="https://npm.elemecdn.com/chenyfan-oss@1.1.11/194.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>由于我是OIer【虽然很差】，习惯使用C++的逻辑，因为JS的逻辑和C++其实差不多，所以我更倾向用WorkerJS书写。</p><p>非常赞的是，去年11月，<a href="https://blog.cloudflare.com/workers-kv-free-tier/" target="_blank" rel="noopener">CloudFlare官方宣布KV在一定额度内免费</a>，并且免费额度喜人：</p><div class="hljs"><pre><code class="hljs undefined">存：<span class="hljs-number">1</span>GB大小读：<span class="hljs-number">10</span>W次/天【注：这里和Worker免费版本调用次数相同】写：<span class="hljs-number">1</span>k次/天删：<span class="hljs-number">1</span>k次/天列：<span class="hljs-number">1</span>k次/天单个限额：<span class="hljs-number">25</span>MB</code></pre></div><p>并且worker里面使用KV函数异常简单，绑定KVNAME后：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">FUNCNAME</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-keyword">await</span> KVNAME.get(INDEX) <span class="hljs-comment">//读</span><span class="hljs-keyword">await</span> KVNAME.put(INDEX,VALUE) <span class="hljs-comment">//写</span><span class="hljs-keyword">await</span> KVNAME.delete(INDEX) <span class="hljs-comment">//删</span>&#125;</code></pre></div><p>按照<a href="https://developers.cloudflare.com/workers/learning/how-kv-works" target="_blank" rel="noopener">官方文档</a>的说法，实际读取与读取静态页面差不多，我写了个简单测试函数，根据时间戳判断，单次读取只需要不超过2ms。</p><p>并且worker有非常赞的fetch函数，无痛自定义header，拉取后端无压力。</p><p>好，那么就开始吧。</p><h1 id="实现-迈出的第一步"><a href="#实现-迈出的第一步" class="headerlink" title="实现 - 迈出的第一步"></a>实现 - 迈出的第一步</h1><p>首先你要绑定个监听器：</p><div class="hljs"><pre><code class="hljs js">addEventListener(<span class="hljs-string">"fetch"</span>, event =&gt; &#123;  event.respondWith(handleRequest(event.request))&#125;)</code></pre></div><p>由于<code>fetch</code>只能在<code>async</code>函数执行,于是我们写个<code>async</code>:</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleRequest</span>(<span class="hljs-params">request</span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Response()&#125;</code></pre></div><p>可以，这样我们就简单实现了一个无服务器函数<img src="https://npm.elemecdn.com/chenyfan-oss@1.1.8/5c53d1904dcb2.gif" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>接下来的函数就应该在async这个主函数写。</p><p>然后是最基本的fetch，fetch应该说是worker里最特色的函数了。</p><p>如果直接返回，那么就不用加<code>await</code>,因为在<code>async</code>里面返回了一个<code>await</code></p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">return</span> fetch(<span class="hljs-string">'https://api.github.com/repos/ChenYFan/blog/contents/source/_posts'</span>)</code></pre></div><p>如果要拉回来做运算，那么要加<code>await</code>，毕竟<code>fetch</code>返回的是<code>promise</code></p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">'https://api.github.com/repos/ChenYFan/blog/contents/source/_posts'</span>)</code></pre></div><p>CFWorker能用<code>.text()</code>函数和<code>.json()</code>函数处理返回的内容：</p><blockquote><p>这地方我偷懒了,本来应该用<code>then</code>来获取<code>promise</code>的值,但是个人习惯了<code>await</code>嵌套写法,所以这地方写的其实不标准,轻喷<img src="https://npm.elemecdn.com/chenyfan-oss@1.1.11/285.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p></blockquote><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> first_name = <span class="hljs-keyword">await</span> <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-keyword">await</span>(<span class="hljs-keyword">await</span> fetch(<span class="hljs-string">'https://api.github.com/repos/ChenYFan/blog/contents/source/_posts'</span>)).text())[<span class="hljs-number">0</span>][<span class="hljs-string">"name"</span>]<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Response(first_name)</code></pre></div><p>这个其实等价下面的：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> first_name = (<span class="hljs-keyword">await</span>(<span class="hljs-keyword">await</span> fetch(<span class="hljs-string">'https://api.github.com/repos/ChenYFan/blog/contents/source/_posts'</span>)).json())[<span class="hljs-number">0</span>][<span class="hljs-string">"name"</span>]<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Response(first_name)</code></pre></div><p>当然显然是下面的好写,但我习惯测试方便都用上面的<img src="https://npm.elemecdn.com/chenyfan-oss@1.1.8/stick_18.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>我们也可以通过自定义方式来自定义header完成鉴权和UA设置:</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> getinit = &#123;          <span class="hljs-attr">method</span>: <span class="hljs-string">"GET"</span>,          <span class="hljs-attr">headers</span>: &#123;            <span class="hljs-string">"content-type"</span>: <span class="hljs-string">"application/json;charset=UTF-8"</span>,            <span class="hljs-string">"user-agent"</span>: <span class="hljs-string">`<span class="hljs-subst">$&#123;USERAGENT&#125;</span>`</span>,            <span class="hljs-string">"Authorization"</span>: <span class="hljs-string">`token <span class="hljs-subst">$&#123;TOKEN&#125;</span>`</span>          &#125;,&#125;<span class="hljs-keyword">const</span> first_name = <span class="hljs-keyword">await</span> <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-keyword">await</span>(<span class="hljs-keyword">await</span> fetch(<span class="hljs-string">'https://api.github.com/repos/ChenYFan/blog/contents/source/_posts'</span>,getinit)).text())[<span class="hljs-number">0</span>][<span class="hljs-string">"name"</span>]<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Response(first_name)</code></pre></div><p>那么接下来就很简单了。</p><h1 id="实现-面板的设计"><a href="#实现-面板的设计" class="headerlink" title="实现 - 面板的设计"></a>实现 - 面板的设计</h1><p>Worker支持返回数据的设置，我们可以通过修改<code>content-type</code>达到返回页面的效果,并且可以通过JS奇妙的语法完成PHP难以做到的事情。</p><p>首先先定义一个网页：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> re_html =  <span class="hljs-string">`&lt;h1&gt;Hello,World!&lt;/h1&gt;`</span></code></pre></div><p>然后要返回吧：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Response(re_html, &#123;    <span class="hljs-attr">headers</span>: &#123; <span class="hljs-string">"content-type"</span>: <span class="hljs-string">"text/html;charset=UTF-8"</span> &#125;&#125;)</code></pre></div><p>这个地方<code>content-type</code>务必要设置,不然默认返回是文本形式</p><p>然后打开预览就能看到了:</p><p><img src="https://npm.elemecdn.com/chenyfan-cdn@2.0.0/img/hpp_upload/1612929973000.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>然后关于拼接,其实完全不必用<code>+</code>连接，可以用``包裹,然后用<code>${变量名}</code>来代替</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> inner = <span class="hljs-string">`Hello,World!`</span><span class="hljs-keyword">const</span> re_html =  <span class="hljs-string">`&lt;h1&gt;<span class="hljs-subst">$&#123;inner&#125;</span>&lt;/h1&gt;`</span><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Response(re_html, &#123;    <span class="hljs-attr">headers</span>: &#123; <span class="hljs-string">"content-type"</span>: <span class="hljs-string">"text/html;charset=UTF-8"</span> &#125;&#125;)</code></pre></div><p><span class="heimu">这种写法帮我省下精力重看代码</span></p><p>面板怎么说,其实直接用<a href="https://www.creative-tim.com/product/material-dashboard" target="_blank" rel="noopener">material-dashboard</a>套的</p><h1 id="实现-后端API的设计"><a href="#实现-后端API的设计" class="headerlink" title="实现 - 后端API的设计"></a>实现 - 后端API的设计</h1><p>后端API本质上是一个中继,简单如我<img src="https://npm.elemecdn.com/chenyfan-oss@1.1.8/7EYyq1TcBKa3eQ2.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>废话不说直接上代码。</p><h2 id="问题解决-存储问题"><a href="#问题解决-存储问题" class="headerlink" title="问题解决 - 存储问题"></a>问题解决 - 存储问题</h2><p>KV是能存东西.配置是符合键的形式的,一个键名配对一个键值,这和KV的存储方式相同.但是这么多配置项,如果一个一个读过去,KV迟早比worker早读爆.缓存没用,还得赔一个清除缓存的APIKey,太亏了.</p><p>所以HPP将所有配置<code>JSON.stringify</code>后存储到了一个键名为<code>hpp_config</code>的键.</p><p>那关于账户密码,难道不能存KV吗?</p><p>能,当然能,但是问题是如果在登录页面还要读KV,那被打了怎么办<img src="https://npm.elemecdn.com/chenyfan-oss@1.1.11/67.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>况且,在粘贴代码完后到设置界面,中间有一段时间,万一有个人搞你咋办呢.<img src="https://npm.elemecdn.com/chenyfan-oss@1.1.11/5.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>所以HPP学习Twikoo进行强鉴权,在保证不被盗取的情况下还能减少KV读取量,岂不美哉<img src="https://npm.elemecdn.com/chenyfan-oss@1.1.8/stick_64.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><h2 id="问题解决-多层文件夹"><a href="#问题解决-多层文件夹" class="headerlink" title="问题解决 - 多层文件夹"></a>问题解决 - 多层文件夹</h2><p>默认情况下，访问无文件名的<code>RESTURL</code>会列出当前文件夹下的所有文件,但列不出文件夹下的文件.我们先看获取示例，以<code>https://api.github.com/repos/ChenYFan/blog/contents/source/_drafts?ref=master</code>为例子:</p><div class="hljs"><pre><code class="hljs json">[    &#123;        <span class="hljs-attr">"name"</span>: <span class="hljs-string">"TEST.md"</span>,        <span class="hljs-attr">"path"</span>: <span class="hljs-string">"source/_drafts/TEST.md"</span>,        <span class="hljs-attr">"sha"</span>: <span class="hljs-string">"3b12464976a5fd9e07d67dd7d5cf4f0f10188410"</span>,        <span class="hljs-attr">"size"</span>: <span class="hljs-number">4</span>,        <span class="hljs-attr">"url"</span>: <span class="hljs-string">"https://api.github.com/repos/ChenYFan/blog/contents/source/_drafts/TEST.md?ref=master"</span>,        <span class="hljs-attr">"html_url"</span>: <span class="hljs-string">"https://github.com/ChenYFan/blog/blob/master/source/_drafts/TEST.md"</span>,        <span class="hljs-attr">"git_url"</span>: <span class="hljs-string">"https://api.github.com/repos/ChenYFan/blog/git/blobs/3b12464976a5fd9e07d67dd7d5cf4f0f10188410"</span>,        <span class="hljs-attr">"download_url"</span>: <span class="hljs-string">"https://raw.githubusercontent.com/ChenYFan/blog/master/source/_drafts/TEST.md"</span>,        <span class="hljs-attr">"type"</span>: <span class="hljs-string">"file"</span>,        <span class="hljs-attr">"_links"</span>: &#123;            <span class="hljs-attr">"self"</span>: <span class="hljs-string">"https://api.github.com/repos/ChenYFan/blog/contents/source/_drafts/TEST.md?ref=master"</span>,            <span class="hljs-attr">"git"</span>: <span class="hljs-string">"https://api.github.com/repos/ChenYFan/blog/git/blobs/3b12464976a5fd9e07d67dd7d5cf4f0f10188410"</span>,            <span class="hljs-attr">"html"</span>: <span class="hljs-string">"https://github.com/ChenYFan/blog/blob/master/source/_drafts/TEST.md"</span>        &#125;    &#125;,    &#123;        <span class="hljs-attr">"name"</span>: <span class="hljs-string">"TEST"</span>,        <span class="hljs-attr">"path"</span>: <span class="hljs-string">"source/_drafts/TEST"</span>,        <span class="hljs-attr">"sha"</span>: <span class="hljs-string">"18391dac960bd390d4213818b7a79c63dcd2fb44"</span>,        <span class="hljs-attr">"size"</span>: <span class="hljs-number">0</span>,        <span class="hljs-attr">"url"</span>: <span class="hljs-string">"https://api.github.com/repos/ChenYFan/blog/contents/source/_drafts/TEST?ref=master"</span>,        <span class="hljs-attr">"html_url"</span>: <span class="hljs-string">"https://github.com/ChenYFan/blog/tree/master/source/_drafts/TEST"</span>,        <span class="hljs-attr">"git_url"</span>: <span class="hljs-string">"https://api.github.com/repos/ChenYFan/blog/git/trees/18391dac960bd390d4213818b7a79c63dcd2fb44"</span>,        <span class="hljs-attr">"download_url"</span>: <span class="hljs-literal">null</span>,        <span class="hljs-attr">"type"</span>: <span class="hljs-string">"dir"</span>,        <span class="hljs-attr">"_links"</span>: &#123;            <span class="hljs-attr">"self"</span>: <span class="hljs-string">"https://api.github.com/repos/ChenYFan/blog/contents/source/_drafts/TEST?ref=master"</span>,            <span class="hljs-attr">"git"</span>: <span class="hljs-string">"https://api.github.com/repos/ChenYFan/blog/git/trees/18391dac960bd390d4213818b7a79c63dcd2fb44"</span>,            <span class="hljs-attr">"html"</span>: <span class="hljs-string">"https://github.com/ChenYFan/blog/tree/master/source/_drafts/TEST"</span>        &#125;    &#125;]</code></pre></div><p>文件夹是<code>dir</code>,文件是<code>file</code>,甚至可以通过<code>self</code>往下找,连路径都不用拼接了,那事情就好办了,写个搜索递归吧.</p><blockquote><p>这个地方在群里我一直和<a href="https://noionion.top/" target="_blank" rel="noopener">2X</a>吵架,因为我觉得此处用广搜比较好,然后我一直想写BFS,结果写着写着就成DFS了,你甚至现在还能看到一个叫<code>fetch_bfs</code>的函数<img src="https://npm.elemecdn.com/chenyfan-oss@1.1.8/BnTMX35EPxleVmA.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p></blockquote><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetch_bfs</span>(<span class="hljs-params">arr, url, getinit</span>) </span>&#123; <span class="hljs-comment">//开始深搜</span>          <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">const</span> hpp_getlist = <span class="hljs-keyword">await</span> <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-keyword">await</span> (<span class="hljs-keyword">await</span> fetch(url, hpp_githubgetdocinit)).text()) <span class="hljs-comment">//拉取github列表</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; getJsonLength(hpp_getlist); i++) &#123; <span class="hljs-comment">//循环查找</span>              <span class="hljs-keyword">if</span> (hpp_getlist[i][<span class="hljs-string">"type"</span>] != <span class="hljs-string">"dir"</span>) &#123; <span class="hljs-comment">//如果不是文件夹</span>                arr.push(hpp_getlist[i])<span class="hljs-comment">//弹到目标数组末尾</span>              &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//否则</span>                <span class="hljs-keyword">await</span> fetch_bfs(arr, hpp_getlist[i][<span class="hljs-string">"_links"</span>][<span class="hljs-string">"self"</span>], getinit) <span class="hljs-comment">//进入该文件夹深搜</span>              &#125;            &#125;            <span class="hljs-keyword">return</span> arr;          &#125; <span class="hljs-keyword">catch</span> (e) &#123; <span class="hljs-keyword">return</span> &#123;&#125; &#125;&#125;</code></pre></div><p>代码本意很简单,传入一个空数组,抓取列表,循环递归,如果不是文件夹就扔到数组,是的话就向下搜索<span class="heimu">其实就是DFS嘛</span></p><p>用<code>try</code>的原因是因为莫些人没有草稿，不用try的话这个函数就会炸，没草稿返回空数组。</p><p>然后就试试呗，以获取草稿列表为例：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (path == <span class="hljs-string">"/hpp/admin/api/get_draftlist"</span>) &#123; <span class="hljs-comment">//判断路径</span>          <span class="hljs-keyword">let</span> hpp_doc_draft_list_index = <span class="hljs-keyword">await</span> KVNAME.get(<span class="hljs-string">"hpp_doc_draft_list_index"</span>) <span class="hljs-comment">//获取索引</span>          <span class="hljs-keyword">if</span> (hpp_doc_draft_list_index === <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//如果没有索引</span>            <span class="hljs-keyword">const</span> filepath = githubdocdraftpath.substr(<span class="hljs-number">0</span>, (githubdocdraftpath).length - <span class="hljs-number">1</span>) <span class="hljs-comment">//分离路径</span>            <span class="hljs-keyword">const</span> url = <span class="hljs-string">`https://api.github.com/repos/<span class="hljs-subst">$&#123;hpp_githubdocusername&#125;</span>/<span class="hljs-subst">$&#123;hpp_githubdocrepo&#125;</span>/contents<span class="hljs-subst">$&#123;filepath&#125;</span>?ref=<span class="hljs-subst">$&#123;hpp_githubdocbranch&#125;</span>`</span> <span class="hljs-comment">//拼接RESTURL</span>            hpp_doc_draft_list_index = <span class="hljs-keyword">await</span> <span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-keyword">await</span> fetch_bfs([], url, hpp_githubgetdocinit)) <span class="hljs-comment">//开始深搜</span>            <span class="hljs-keyword">await</span> KVNAME.put(<span class="hljs-string">"hpp_doc_draft_list_index"</span>, hpp_doc_draft_list_index) <span class="hljs-comment">//保存索引</span>          &#125;          <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Response(hpp_doc_draft_list_index, &#123; <span class="hljs-comment">//返回路径</span>            <span class="hljs-attr">headers</span>: &#123;              <span class="hljs-string">"content-type"</span>: <span class="hljs-string">"application/json;charset=UTF-8"</span>,              <span class="hljs-string">"Access-Control-Allow-Origin"</span>: hpp_cors            &#125;          &#125;)&#125;</code></pre></div><p>我们来做个小实验：</p><p><img src="https://npm.elemecdn.com/chenyfan-cdn@2.0.0/img/hpp_upload/1612936420000.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>结构如下：</p><div class="hljs"><pre><code class="hljs undefined">-<span class="ruby">source/_drafts</span>  ~TEST.md  -<span class="ruby">TEST</span>    ~TEST.md    -<span class="ruby">TEST</span>      ~TEST.md      -<span class="ruby">TEST</span>        ~TEST.md</code></pre></div><p>那么CloudFlareWorker会这样搜索:</p><p><img src="https://npm.elemecdn.com/chenyfan-cdn@2.0.0/img/hpp_upload/1612937339000.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p><del>其实我本来想这样的</del></p><p><img src="https://npm.elemecdn.com/chenyfan-cdn@2.0.0/img/hpp_upload/1612937329000.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>【考虑到大多数人都没有建立文件夹的习惯，本来bfs的效率会更高的(´இ皿இ｀)】</p><p>【但其实两者子请求数目是一样的】</p><p>我们去CloudFlare发一个请求啊，结果非常Amazing啊：</p><p><img src="https://npm.elemecdn.com/chenyfan-cdn@2.0.0/img/hpp_upload/1612938453000.gif" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>dfs完美解决嵌套问题。</p><h2 id="问题解决-缓存问题"><a href="#问题解决-缓存问题" class="headerlink" title="问题解决 - 缓存问题"></a>问题解决 - 缓存问题</h2><h3 id="手机端POST之谜"><a href="#手机端POST之谜" class="headerlink" title="手机端POST之谜"></a>手机端POST之谜</h3><p>之前开发网页的时候，我总是希望缓存越长越好，因为有些资源从来没有变过却要重复使用。于是，我给博客加上了<code>ServiceWorker</code><span class="heimu"><del>这就是我咕咕咕的理由</del></span></p><p>但hpp不能进行太强的缓存,否则可能造成获取文件不够及时.</p><p>于是，在文章获取这一块，我故意将<code>get</code>写成<code>post</code>,发送空值,电脑端乖乖的每次都把请求发出去,毫无异常.</p><p>然后手机端炸了<img src="https://npm.elemecdn.com/chenyfan-oss@1.1.8/5c53cee8422fc.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>万万没想到,safari会将post请求给缓存了<img src="https://npm.elemecdn.com/chenyfan-oss@1.1.8/5896ece29a8e0.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>缓存也就罢了,结果ajax连<code>onreadystatechange</code>都缓存了不返回,然后接下去的函数全炸了<img src="https://npm.elemecdn.com/chenyfan-oss@1.1.8/5896ece2a019f.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>没办法,只好在post里面加时间戳</p><div class="hljs"><pre><code class="hljs js">ajax.send(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime());</code></pre></div><h3 id="文章索引问题"><a href="#文章索引问题" class="headerlink" title="文章索引问题"></a>文章索引问题</h3><p>然后是索引问题【本质上是把结果缓存在KV里】，因为在文件夹众多的情况下dfs会将每个文件夹找过去，先不说时间这个问题（毕竟一次子请求大约在60ms-150ms徘徊，文件夹多的情况下也尚能忍受），主要是文件夹一多，子请求跟着多起来了，worker子请求超时是30s（10ms是运算时间，我寻思只要没有上亿篇文章，加个数组应该不会炸10ms时间），并且子请求算总请求，要是这么搞一次，worker怕是不够用了，所以得加个KV强缓存：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">await</span> KVNAME.put(<span class="hljs-string">"hpp_doc_list_index"</span>, hpp_doc_list_index)<span class="hljs-keyword">await</span> KVNAME.put(<span class="hljs-string">"hpp_doc_draft_list_index"</span>, hpp_doc_draft_list_index)</code></pre></div><p>在发布、删除等<strong>可能</strong>会导致缓存失效的情况下清除KV缓存：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">await</span> KVNAME.del(<span class="hljs-string">"hpp_doc_list_index"</span>)<span class="hljs-keyword">await</span> KVNAME.del(<span class="hljs-string">"hpp_doc_draft_list_index"</span>)</code></pre></div><h2 id="功能实现-自动更新"><a href="#功能实现-自动更新" class="headerlink" title="功能实现 - 自动更新"></a>功能实现 - 自动更新</h2><p>这怕是所有Worker程序里面第一个实现自动更新的程序了<del>【所以我最近发包很快啊】</del><img src="https://npm.elemecdn.com/chenyfan-cdn@2.0.0/img/hpp_upload/1612940443000.gif" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>其实刚开始没想到这么多，后来<a href="https://github.com/MCSeekeri" target="_blank" rel="noopener">@MCSeekeri </a>开了<a href="https://github.com/HexoPlusPlus/HexoPlusPlus/issues/21" target="_blank" rel="noopener">#21</a>,其中提到了这一点,然后我就开了<a href="https://github.com/HexoPlusPlus/HexoPlusPlus/issues/23" target="_blank" rel="noopener">#23</a>。</p><p>查一遍<a href="https://api.cloudflare.com/#worker-script-upload-worker" target="_blank" rel="noopener">CloudFlareAPI文档</a>，我们就会发现这做起来简直轻而易举：</p><p><img src="https://npm.elemecdn.com/chenyfan-cdn@2.0.0/img/hpp_upload/1612941346000.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><div class="hljs"><pre><code class="hljs curl">curl -X PUT &quot;https://api.cloudflare.com/client/v4/accounts/9a7806061c88ada191ed06f989cc3dac/workers/scripts/this-is_my_script-01&quot; \     -H &quot;X-Auth-Email: user@example.com&quot; \     -H &quot;X-Auth-Key: c2547eb745079dac9320b638f5e225cf483cc5cfdda41&quot; \     -H &quot;Content-Type: application/javascript&quot; \--data &quot;addEventListener(&apos;fetch&apos;, event =&gt; &#123; event.respondWith(fetch(event.request)) &#125;)&quot;</code></pre></div><p>curl,我寻思fetch也能做到.</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> update_script = <span class="hljs-keyword">await</span> (<span class="hljs-keyword">await</span> fetch(<span class="hljs-string">`https://raw.githubusercontent.com/HexoPlusPlus/HexoPlusPlus/main/index.js`</span>)).text() <span class="hljs-comment">//获取更新脚本</span><span class="hljs-keyword">const</span> up_init = &#123;            <span class="hljs-attr">body</span>: update_script,<span class="hljs-comment">//更新脚本内容</span>            <span class="hljs-attr">method</span>: <span class="hljs-string">"PUT"</span>,<span class="hljs-comment">//method是put</span>            <span class="hljs-attr">headers</span>: &#123;              <span class="hljs-string">"content-type"</span>: <span class="hljs-string">"application/javascript"</span>,<span class="hljs-comment">//content-type和文档一样</span>              <span class="hljs-string">"X-Auth-Key"</span>: hpp_CF_Auth_Key,<span class="hljs-comment">//GlobalKey,账户最高Token</span>              <span class="hljs-string">"X-Auth-Email"</span>: hpp_Auth_Email<span class="hljs-comment">//登录邮箱</span>            &#125;&#125;          <span class="hljs-keyword">const</span> update_resul = <span class="hljs-keyword">await</span> (<span class="hljs-keyword">await</span> fetch(<span class="hljs-string">`https://api.cloudflare.com/client/v4/accounts/<span class="hljs-subst">$&#123;hpp_account_identifier&#125;</span>/workers/scripts/<span class="hljs-subst">$&#123;hpp_script_name&#125;</span>`</span>, up_init)).text()<span class="hljs-comment">//拼接workerid,请求url,上传</span>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Response(<span class="hljs-built_in">JSON</span>.parse(update_resul)[<span class="hljs-string">"success"</span>])<span class="hljs-comment">//查询更新状态</span></code></pre></div><p>OK那没问题了,手动更新完成.</p><p>那自动更新呢?</p><p>目前自动更新理论上可以实现,使用CronJob每天定时执行函数.<br>但我懒<img src="https://npm.elemecdn.com/chenyfan-oss@1.1.8/5896e8a408253.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>其实你也可以用其它什么能定时访问的带上cookie访问<code>/hpp/admin/api/update</code>就行<img src="https://npm.elemecdn.com/chenyfan-oss@1.1.8/5896ece29a8e0.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><h2 id="功能实现-文章管理-amp-草稿"><a href="#功能实现-文章管理-amp-草稿" class="headerlink" title="功能实现 - 文章管理&amp;草稿"></a>功能实现 - 文章管理&amp;草稿</h2><p>其实就是上传文件<img src="https://npm.elemecdn.com/chenyfan-oss@1.1.11/92.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>当然因为是hexo，本来就有<code>/source/_posts</code>和<code>/source/_drafts</code>两个草稿分区,所以在<code>1.1.0</code>版本,将<code>docpath</code>改为了<code>docroot</code>,通过定位hexo根目录来实现全站自适应管理.</p><h2 id="功能实现-图床"><a href="#功能实现-图床" class="headerlink" title="功能实现 - 图床"></a>功能实现 - 图床</h2><p>我知道有很多人还是困扰于图床这个问题,PicGo虽然能实现上传,但是配置一大堆,麻烦,并且配置不能随意迁移;PicX也使用Github+JSD做图床,但是没有中继速度慢,国内难以上传.</p><p>其实还是上传文件<img src="https://npm.elemecdn.com/chenyfan-oss@1.1.11/162.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>但是我们必须知道,CFWorker单次执行最多10ms,正常图片三四百KB,在worker里base64,这能不超时我把CF吃了.</p><p>没办法,我们只能在前端进行base64,然后将编码后的值直接上传,用Worker中继.</p><h2 id="功能实现-说说"><a href="#功能实现-说说" class="headerlink" title="功能实现 - 说说"></a>功能实现 - 说说</h2><p>这个最早受<a href="https://artitalk.js.org/" target="_blank" rel="noopener">Artitalk</a>影响，在artitalk官方群里<del>潜伏了</del>一年，我明确知道说说这一块的用户需求是多么大，并且大多数都是小白，不想用太多配置。</p><p>于是，HPP_TALK诞生了。诞生的初衷就是简化发布和配置流程，在1.1.2版本版本中自带了一个预览页面，实现了无域名也能使用说说。</p><p><img src="https://npm.elemecdn.com/chenyfan-cdn@2.0.0/img/hpp_upload/1612945005000.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt="&#39;说说发布页面&#39;"></p><p><img src="https://npm.elemecdn.com/chenyfan-cdn@2.0.0/img/hpp_upload/1612945225000.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt="&#39;用户查看界面&#39;"></p><p>甚至支持自定义主题：</p><p><img src="https://npm.elemecdn.com/chenyfan-cdn@2.0.0/img/hpp_upload/1612945296000.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt="&#39;由2X开发的说说主题&#39;"></p><p>HPPTALK配置也简单，后端配置可以直接缺省发布，而前段也只要传递4个变量。</p><p>【但是我但是傻乎乎用了cookie记录，下次绝壁用LocalStr】</p><h2 id="功能实现-TwikooPlus"><a href="#功能实现-TwikooPlus" class="headerlink" title="功能实现 - TwikooPlus"></a>功能实现 - TwikooPlus</h2><blockquote><p>其实这个东西写的很粗糙,大家就看看行了哈</p></blockquote><p>Twikoo首次匿名登录实在把我看傻了,6个请求,放国外不得炸掉.</p><p>然后就看,实际上只有前面几个有效的,后面其实是获取配置.</p><p>首先规定一下<code>RESTURL</code>=<code>https://tcb-api.tencentcloudapi.com/web?env=${ENVID}</code></p><p>三步走:</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-number">1.</span>空手拉refresh_token<span class="hljs-number">2.</span>用refresh_token套access_token<span class="hljs-number">3.</span>用access_token套评论</code></pre></div><p>其中refresh_token两小时有效,access_token30天有效</p><p>那就很有意思了同学们:</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get_refresh_token</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-comment">/*第一步获得refresh_token*/</span>        <span class="hljs-keyword">const</span> step_1_body = &#123;          <span class="hljs-attr">action</span>: <span class="hljs-string">"auth.signInAnonymously"</span>,          <span class="hljs-attr">anonymous_uuid</span>: <span class="hljs-string">""</span>,          <span class="hljs-attr">dataVersion</span>: <span class="hljs-string">"1970-1-1"</span>,          <span class="hljs-attr">env</span>: env_id,          <span class="hljs-attr">refresh_token</span>: <span class="hljs-string">""</span>,          <span class="hljs-attr">seqId</span>: <span class="hljs-string">""</span>        &#125;        <span class="hljs-keyword">const</span> step_1 = &#123;          <span class="hljs-attr">body</span>: <span class="hljs-built_in">JSON</span>.stringify(step_1_body),          <span class="hljs-attr">method</span>: <span class="hljs-string">"POST"</span>,          <span class="hljs-attr">headers</span>: &#123;            <span class="hljs-string">"content-type"</span>: <span class="hljs-string">"application/json;charset=UTF-8"</span>          &#125;        &#125;        <span class="hljs-comment">/*refresh_token到手*/</span>        <span class="hljs-comment">//console.log(step_1_body)</span>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-keyword">await</span> (<span class="hljs-keyword">await</span> fetch(url, step_1)).text())[<span class="hljs-string">"refresh_token"</span>]      &#125;      <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get_access_token</span>(<span class="hljs-params">refresh_token</span>) </span>&#123;        <span class="hljs-keyword">const</span> step_2_body = &#123;          <span class="hljs-attr">action</span>: <span class="hljs-string">"auth.fetchAccessTokenWithRefreshToken"</span>,          <span class="hljs-attr">anonymous_uuid</span>: <span class="hljs-string">""</span>,          <span class="hljs-attr">dataVersion</span>: <span class="hljs-string">"1970-1-1"</span>,          <span class="hljs-attr">env</span>: env_id,          <span class="hljs-attr">refresh_token</span>: refresh_token,          <span class="hljs-attr">seqId</span>: <span class="hljs-string">""</span>        &#125;        <span class="hljs-keyword">const</span> step_2 = &#123;          <span class="hljs-attr">body</span>: <span class="hljs-built_in">JSON</span>.stringify(step_2_body),          <span class="hljs-attr">method</span>: <span class="hljs-string">"POST"</span>,          <span class="hljs-attr">headers</span>: &#123;            <span class="hljs-string">"content-type"</span>: <span class="hljs-string">"application/json;charset=UTF-8"</span>          &#125;        &#125;        <span class="hljs-comment">/*access_token到手*/</span>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-keyword">await</span> (<span class="hljs-keyword">await</span> fetch(url, step_2)).text())[<span class="hljs-string">"access_token"</span>];      &#125;      <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get_comment</span>(<span class="hljs-params">access_token, path, before</span>) </span>&#123;        <span class="hljs-keyword">const</span> re_data = &#123; <span class="hljs-string">"event"</span>: <span class="hljs-string">"COMMENT_GET"</span>, <span class="hljs-string">"url"</span>: path, <span class="hljs-string">"before"</span>: before &#125;        <span class="hljs-keyword">const</span> step_3_body = &#123;          <span class="hljs-attr">access_token</span>: access_token,          <span class="hljs-attr">action</span>: <span class="hljs-string">"functions.invokeFunction"</span>,          <span class="hljs-attr">dataVersion</span>: <span class="hljs-string">"1970-1-1"</span>,<span class="hljs-comment">//开始时间</span>          <span class="hljs-attr">env</span>: env_id,          <span class="hljs-attr">function_name</span>: <span class="hljs-string">"twikoo"</span>,          <span class="hljs-attr">request_data</span>: <span class="hljs-built_in">JSON</span>.stringify(re_data),          <span class="hljs-attr">seqId</span>: <span class="hljs-string">""</span>        &#125;        <span class="hljs-keyword">const</span> step_3 = &#123;          <span class="hljs-attr">body</span>: <span class="hljs-built_in">JSON</span>.stringify(step_3_body),          <span class="hljs-attr">method</span>: <span class="hljs-string">"POST"</span>,          <span class="hljs-attr">headers</span>: &#123;            <span class="hljs-string">"content-type"</span>: <span class="hljs-string">"application/json;charset=UTF-8"</span>          &#125;        &#125;        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">await</span> (<span class="hljs-keyword">await</span> fetch(url, step_3)).text())      &#125;</code></pre></div><p>这里要注意以下,套评论的时候要传递两个参数<code>path</code>和<code>before</code>,<code>path</code>是当前文章路径,<code>before</code>是上一条评论的创建时间戳<code>CreatedAt</code></p><p>然后使用的时候来一波:</p><div class="hljs"><pre><code class="hljs js">refresh_token = <span class="hljs-keyword">await</span> get_refresh_token()access_token = <span class="hljs-keyword">await</span> get_access_token(refresh_token)val = <span class="hljs-keyword">await</span> get_comment(access_token, path, before)</code></pre></div><p>同时用KV缓存</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">await</span> KVNAME.put(<span class="hljs-string">"hpp_comment_refresh_token"</span>, refresh_token)<span class="hljs-keyword">await</span> KVNAME.put(<span class="hljs-string">"hpp_comment_access_token"</span>, access_token)</code></pre></div><p>OK起飞</p><h2 id="问题解决-EditorMD移动端问题"><a href="#问题解决-EditorMD移动端问题" class="headerlink" title="问题解决 - EditorMD移动端问题"></a>问题解决 - EditorMD移动端问题</h2><p>本来HPP开始写的时候就是用EditorMD的,好康,功能多.</p><p>但是很快手机端就炸出问题了:</p><p>安卓:打一个字换一行<br>苹果:打一个字复制一遍</p><p>非常有问题,原仓库有一个Close的issues说把codemirror更新到最新版本就行,但是我更新到5.x最后一个版本问题仍复发.</p><p>Github上面大多数编辑器也用的是CodeMirror.</p><p>然后找了半天实在没有解决方案，就<strong>花一个下午时间手写了一个编辑器</strong></p><p>用的是最基础的<strong>textarea</strong>，这能出兼容性问题我把<strong>Github整个吃了</strong></p><p>预览功能是靠markedjs通过调整<code>display</code>在一个<code>div</code>里面预览,在1.1.0版本支持了代码高亮.</p><p><del>话说手写一个很多功能就很好集成了诶</del></p><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>还有很多开发细节想不起来了,先水到这里了,<span class="heimu">滚回去修bug了</span></p><p><a href="https://jq.qq.com/?_wv=1027&k=JPokmJdL" target="_blank" rel="noopener">QQ群:467731779</a></p><p>最后加一句，用HPP时CI强烈建议使用GithubAction并公开，<del>我是也不明白我Travis-CI怎么把积分耗完的</del></p><p>预计会添加的功能：</p><ul><li>Hexo、主题配置修改</li><li>输入框粘贴上传图片</li><li>友链系统</li><li>基于KV/IPFS的自动保存功能</li><li>列表分页功能</li><li>博主工具箱</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;我一直都习惯在线写作，但因为口袋里没钱，不能买服务器用动态博客，使用Hexo，即使实现了集成部署，想要在github上直接书写，尤其是出门在外有所灵感，国内手机登陆github真的是极其糟糕的体验。博客本就是碎片化写作和高质量文章发布处，使用hexo却使我无法发挥博客的用处。&lt;/p&gt;</summary>
    
    
    
    <category term="好方法" scheme="https://blog.cyfan.top/categories/好方法/"/>
    
    
    <category term="Hexo" scheme="https://blog.cyfan.top/tags/Hexo/"/>
    
    <category term="集成部署" scheme="https://blog.cyfan.top/tags/集成部署/"/>
    
  </entry>
  
  <entry>
    <title>PanList：ServerLess百度网盘列表直链程序</title>
    <link href="https://blog.cyfan.top/p/32883f0c.html"/>
    <id>https://blog.cyfan.top/p/32883f0c.html</id>
    <published>2021-01-06T13:44:55.000Z</published>
    <updated>2022-01-16T12:23:54.551Z</updated>
    
    <content type="html"><![CDATA[<div class="note note-success">            <h3 id="警告"><a href="#警告" class="headerlink" title="警告"></a>警告</h3><p>本篇文章在panlist发布后两天内写成，panlist尚处于高速迭代状态，本篇教程随时会失效！</p>          </div><blockquote><p> <del>百度网盘2021年最新不限速下载方式是怎么回事呢？百度网盘相信大家都很熟悉，但是百度网盘2021年最新不限速下载方式是怎么回事呢，下面就让小编带大家一起了解吧。</del><br><del>百度网盘2021年最新不限速下载方式，其实就是PandownloadCloudFlareWorkers版本，大家可能会很惊讶百度网盘怎么会2021年最新不限速下载方式呢？但事实就是这样，小编也感到非常惊讶。</del><br><del>这就是关于百度网盘2021年最新不限速下载方式的事情了，大家有什么想法呢，欢迎在评论区告诉小编一起讨论哦！</del></p></blockquote><p>之前写过<a href="/p/74e90c90.html">GoogleDrive</a>、<a href="/p/4fb070ca.html">OneDrive</a> 的CloudFlare列表程序，这两个有个共同点，那就是国内都无法很好的下载，所以用CloudFlareWorkers作为中间件转发流量。</p><p>比较讽刺的是，CloudFlareWorkers用的都是国外节点，但以上两个运行于此的目录列表程序支持的下载速度却远远大于国内有节点的百度网盘，不说是移动BGP走香港有多好，至少我在『电信』网络环境下的下载速度都远远大于百度网盘。很显然，百度网盘作为垄断国内网盘市场的资本，既然已经度过了烧钱的时间，那么现在自然是能剩多少省多少，这就是『吃相难看』。</p><p>两年前，当微博上的人们开始质问突然『诈尸』的百度网盘微博账号，网友们才纷纷意识到自己的百度网盘被恶意限速了，紧接着，破解百度网盘限速的方式层出不穷。只是后来，这些方式一点一点被打压下去，最终戛然而止。</p><p>最近这几天因为在写<a href="https://github.com/HexoPlusPlus/HexoPlusPlus" target="_blank" rel="noopener">HexoPlusPlus: A ServerLess Hexo Dashboard</a> 正在努力学习CloudFlareWorkers。由于评论模块需要数据结构有关知识，可惜这一块知识大都都被一些所谓白嫖CloudFlareWorkers的教程所淹没：</p><p><img src="https://npm.elemecdn.com/chenyfan-oss@1.1.5/101043.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt="&quot;Google上CloudFlareWorkers搜索结果&quot;"></p><p>在查询有关资料的时候，Github上一颗冉冉新星引起了我的注意，<a href="https://github.com/teardr0p/PanList" target="_blank" rel="noopener">PanList</a> ,根据其Commit显示,这个仓库仅仅是两天前刚刚开辟的,但是本文写是就有61Star和21Fork 【当然我也有Star】，可见其热门程度。不过简单的翻看了一下我就明白其为何如此热门，第一，它是专门对付令人头疼的百度网盘，第二，它是构建于CloudFlareWorkers。</p><h1 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h1><p>电脑登录百度网盘：</p><p><img src="https://npm.elemecdn.com/chenyfan-oss@1.1.5/101056.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt="&quot;百度网盘&quot;"></p><p>按下F12进入开发者模式，选择<code>Application</code>模块，点击<code>Cookies</code>:</p><p><img src="https://npm.elemecdn.com/chenyfan-oss@1.1.5/101101.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt="&quot;Cookies&quot;"></p><p>在这里，我们需要获取两个Cookie：<code>BDUSS</code>和<code>STOKEN</code></p><h1 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h1><table><thead><tr><th>Github</th><th>JSDelivr</th></tr></thead><tbody><tr><td><a href="https://raw.githubusercontent.com/teardr0p/PanList/master/index.js" target="_blank" rel="noopener">原版Github下载地址</a></td><td><a href="https://cdn.jsdelivr.net/gh/teardr0p/PanList@master/index.js" target="_blank" rel="noopener">原版JSDelivr下载地址</a></td></tr></tbody></table><p>修改前面四行代码，分别为</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> BDUSS = <span class="hljs-string">''</span><span class="hljs-keyword">const</span> STOKEN = <span class="hljs-string">''</span><span class="hljs-keyword">const</span> USERNAME = <span class="hljs-string">''</span><span class="hljs-keyword">const</span> PASSWORD = <span class="hljs-string">''</span></code></pre></div><p>将获取到的Cookie复制到第一行和第二行。第三、四行是登录后台所需的账号密码。</p><blockquote><p>AnyWay，你也可以将这些写入到后台变量</p></blockquote><p>新建一个Worker，将处理好的代码直接复制进去：</p><p><img src="https://npm.elemecdn.com/chenyfan-oss@1.1.5/101307.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt="复制代码"></p><p>保存并部署，确定。</p><h1 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h1><p><img src="https://npm.elemecdn.com/chenyfan-oss@1.1.5/101107.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt="绑定域名"></p><p>路由：<code>{待绑定的域名}/*</code> [后面*的原理是覆盖该路径下所有文件]<br>Worker：你新建的Worker名字</p><h1 id="评测"><a href="#评测" class="headerlink" title="评测"></a>评测</h1><p>登陆界面：</p><p><img src="https://npm.elemecdn.com/chenyfan-oss@1.1.5/101115.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt="login"></p><p>打开后：</p><p><img src="https://npm.elemecdn.com/chenyfan-oss@1.1.5/101118.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><blockquote><p>挺讽刺的是，去除了百度网盘原始界面乱七八糟的东西，CloudFlareWorkers的国外服务器打开速度都比百度网盘快</p></blockquote><p>Chrome直接下载速度</p><p><img src="https://npm.elemecdn.com/chenyfan-oss@1.1.5/101447.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>传递Cookie后IDM下载速度：</p><p><img src="https://npm.elemecdn.com/chenyfan-oss@1.1.5/101120.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>注：单线程下载速率最终取决于百度网盘的限制，也就是说无论如何你也无法逃避百度网盘对源头的遏制，就在我下完<code>Soul</code>这部将近2GB的电影后，我的账号就被百度拉入黑名单，现在即使用IDM也只有80kb/s <span class="heimu">但是还是比原来的客户端快</span></p><h1 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h1><p>本质上panlist无非就是通过baidu没有公开的API通过Cookie鉴权来获取文件列表和下载，虽然依旧没有突破单线程下载限速，但至少实现了直链下载和多线程下载的功能，并且部署在CloudFlareWorkers上的方式确实大开眼界，无服务器应用的范围又扩展了一步，我十分看好这个项目。</p><p>另外，本人也在努力开发一款同样基于CloudFlareWorkers的评论系统，以下是截图：</p><p><img src="https://npm.elemecdn.com/chenyfan-oss@1.1.5/101127.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>最后，来一句姗姗来迟的新年祝福：</p><p><img src="https://npm.elemecdn.com/chenyfan-oss@1.1.5/happy.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;note note-success&quot;&gt;
            &lt;h3 id=&quot;警告&quot;&gt;&lt;a href=&quot;#警告&quot; class=&quot;headerlink&quot; title=&quot;警告&quot;&gt;&lt;/a&gt;警告&lt;/h3&gt;&lt;p&gt;本篇文章在panlist发布后两天内写成，panli</summary>
      
    
    
    
    <category term="好方法" scheme="https://blog.cyfan.top/categories/好方法/"/>
    
    
    <category term="CloudFlare" scheme="https://blog.cyfan.top/tags/CloudFlare/"/>
    
    <category term="网盘" scheme="https://blog.cyfan.top/tags/网盘/"/>
    
    <category term="百度网盘" scheme="https://blog.cyfan.top/tags/百度网盘/"/>
    
    <category term="CloudFlareWorkers" scheme="https://blog.cyfan.top/tags/CloudFlareWorkers/"/>
    
    <category term="薅羊毛" scheme="https://blog.cyfan.top/tags/薅羊毛/"/>
    
  </entry>
  
  <entry>
    <title>无服务器搭建Artalk评论系统后端</title>
    <link href="https://blog.cyfan.top/p/480ab6ed.html"/>
    <id>https://blog.cyfan.top/p/480ab6ed.html</id>
    <published>2020-10-01T08:57:09.000Z</published>
    <updated>2022-01-16T12:23:54.551Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这篇的无服务器部署Artalk，指的是NoServer而不是Serverless</p></blockquote><blockquote><p>这篇所写的是部署后端，关于前端部署十分简单，这里不多阐述</p></blockquote><p><a href="https://artalk.js.org/" target="_blank" rel="noopener">Artalk</a>，一款简洁有趣的自托管评论系统。此时，Valine作为老大哥就不得不跳出来了。但是，作为Valine的Leancloud作为第三方托管，数据放在别人那里总是不舒服的，譬如<a href="https://status.leancloud.cn/" target="_blank" rel="noopener">2020/9/24Leancloud华北节点云引擎被 DDoS 攻击</a><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/5c53d1e2ad89f.jpg?q=45" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/20201001071558.png?q=45" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt="image-20201001071514956"></p><p>或者说LeanCloud将开发版限额一限在限，亦或者leancloud多次宕机,作为自由开放的我自然不舒服。加上leancloud开发版的SLA实在令人担忧【不包括休眠时间，一个月内宕机超过20次（不过leancloud开发版确实没有保证SLA）】，以及比较严重的管理员冒充。我一直再找一个能用自己服务器托管评论系统，真巧，我找到了Artalk。Artalk的优点：</p><ul><li><p>轻量简洁 (~23kB gzipped)</p></li><li><p>有趣有爱</p></li><li><p>自托管</p></li><li><p>Markdown</p></li><li><p>表情自定</p></li><li><p>滑稽表情包</p></li><li><p><strong>管理员密码，防冒名</strong></p></li><li><p>验证码，提交频率限制</p></li><li><p><strong>通知中心</strong>，邮件提醒</p></li><li><p>自定义某些页面<strong>仅管理员可评论</strong></p></li><li><p>无限层级回复</p></li><li><p>滚动加载更多</p></li><li><p><strong>评论折叠</strong></p></li><li><p>一页多个评论</p></li><li><p>TypeScript</p></li><li><p><strong>提交频繁验证码</strong></p></li><li><p><strong>无数据库</strong></p><p><span class="heimu">当然没有垃圾评论检测就很蛋疼</span></p></li></ul><p>有服务器部署起来相当简单，宝塔【虽然被炸0day，不过修修补补还能用】+Artalk能实现5分钟部署完毕<a href="https://blog.jalenchuh.cn/posts/artalk-api-php/" target="_blank" rel="noopener">【Jalen的Artalk 自托管评论系统的后端部署】</a>，但是，习惯Valine的群友一看到后端部署就立刻皱起了眉头：我没有服务器，怎么办？<img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/BnTMX35EPxleVmA.jpg?q=45" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>Artalk的后端是PHP的，虽然作者也承诺了会开发别的后端<code>Go API / Node API / Python API</code>，但迟迟没有写出来，考虑到<a href="https://github.com/qwqcode" target="_blank" rel="noopener">QWQCODE</a>是个学生【我也是】，那么咕咕咕就情有可原了。<img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/5c53d78c3f4a5.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>实际上，我用的是Euserv白嫖的，至少SLA还是过的去【&gt;=99%】，但是无论是申请还是部署都非常麻烦。此时，我就在想，既然有免费的php托管商，何苦不用呢？<img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/5896e9712a3c1.gif" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>目前找到两个：Gearhost和000webhost</p><blockquote><p>注意，heroku虽然也有免费容器部署php，但是heroku是沙盒制度，一个评论存储为文件后会删除，所以heroku并不适合作为artalk后端。</p></blockquote><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="设置Artalk"><a href="#设置Artalk" class="headerlink" title="设置Artalk"></a>设置Artalk</h2><p>与其它评论系统不同，artalk本身并没有做到开箱即用这一特点，所以，你还要做一些事先准备。</p><h3 id="GithubAction-Composer安装"><a href="#GithubAction-Composer安装" class="headerlink" title="GithubAction+Composer安装"></a>GithubAction+Composer安装</h3><p>Artalk为了缩小原文件大小，并没有安装好依赖，依赖需要你自己安装。</p><p>如果你本地有composer，那就直接克隆本地运行composer。但不论其便携性还是效率都不高【composer安装起来比较麻烦】，所以，我建议此处用GithubAction实现composer安装。当然你有composer环境就可以直接clone在本地安装。<img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/5896ece29d8a5.gif" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>进入<a href="https://github.com/qwqcode/Artalk-API-PHP" target="_blank" rel="noopener">原项目</a>，Fork到你自己的账户</p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/20201001073813.png?a=45" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt="image-20201001073812407"></p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/20201001073914.png?q=45" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt="image-20201001073913581"></p><p>新建一个文件，文件名为：<code>.github/workflows/composer.yml</code></p><p>内容为：</p><div class="hljs"><pre><code class="hljs yml"><span class="hljs-attr">name:</span> <span class="hljs-string">composer</span><span class="hljs-attr">on:</span>   <span class="hljs-attr">push:</span>    <span class="hljs-attr">branches:</span>       <span class="hljs-bullet">-</span> <span class="hljs-string">master</span> <span class="hljs-comment"># build master branch only</span><span class="hljs-attr">jobs:</span>  <span class="hljs-attr">download:</span>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span>    <span class="hljs-attr">steps:</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Checkout</span>      <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v2</span>      <span class="hljs-attr">with:</span>        <span class="hljs-attr">ref:</span> <span class="hljs-string">master</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span>      <span class="hljs-attr">run:</span> <span class="hljs-string">|        npm install composer        composer install</span>                    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span>      <span class="hljs-attr">uses:</span> <span class="hljs-string">peaceiris/actions-gh-pages@v3</span>      <span class="hljs-attr">with:</span>        <span class="hljs-attr">github_token:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.TOKEN</span> <span class="hljs-string">&#125;&#125;</span>        <span class="hljs-attr">publish_dir:</span> <span class="hljs-string">./</span></code></pre></div><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/20201001074024.png?q=45" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt="image-20201001074023800"></p><p>设置Secret，NAME为<code>TOKEN</code>,内容为你的GithubTOKEN.【Token的获取与这篇文章关联不大】，请自行百度。</p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/20201001081903.png?q=45" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt="image-20201001081902077"></p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/20201001081942.png?q=45" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt="image-20201001081941932"></p><p>回到仓库，<strong>新建一个空白的<code>.htaccess 文件夹，里面什么都不写</code></strong><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="此处不写.htaccess，gearhost就会莫名其妙炸500错误">[1]</span></a></sup>，并删除根目录底下的<code>.gitignore</code>触发GithubAction<img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/%E6%83%B3%E4%B8%80%E6%83%B3.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><blockquote><p>此处必须删除<code>.gitignore</code>【或者你自行修改】，否则接下来出错一律不管</p></blockquote><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/20201001082247.png?q=45" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>稍后即部署完毕</p><h3 id="本地修改配置文件"><a href="#本地修改配置文件" class="headerlink" title="本地修改配置文件"></a>本地修改配置文件</h3><p>Clone你的仓库，指定为gh-pages分支</p><div class="hljs"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> -b gh-pages https://github.com/ChenYFan-Tester/Artalk-API-PHP.git</code></pre></div><blockquote><p>-b是强制指定分支的意思</p></blockquote><blockquote><p>速度慢试试github.com.cnpmjs.org，阿里github镜像</p></blockquote><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/20201001082654.png?q=45" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt="image-20201001082653387"></p><p>打开并修改<code>Config.example.php</code> 具体参照<a href="https://github.com/qwqcode/Artalk-API-PHP" target="_blank" rel="noopener">官方文档</a></p><p>完毕后退出，将<code>Config.example.php</code>重命名为<code>Config.php</code></p><p>此时,你的artalk安装终于告一段落,但是,你还没有将他们部署上去.</p><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><h2 id="Gearhost"><a href="#Gearhost" class="headerlink" title="Gearhost"></a>Gearhost</h2><p>Gearhost其实是一个小有名气的托管商，Free计划提供了最高一线程、每小时256MB内存、每小时5%CPU周期和每月1GB流量，作为评论托管是完全足够的。并且不需要信用卡。</p><p>进入<a href="https://www.gearhost.com/" target="_blank" rel="noopener">Gearhost</a>注册一个账号,新建一个免费的CloudSite。</p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/20201001083231.png?q=45" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt="image-20201001083231112"></p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/20201001083259.png?q=45" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt="image-20201001083258674"></p><p>构建完毕后稍等片刻，进入面板设置：</p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/20201001083743.png?q=45" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt="image-20201001083743275"></p><p>PHP版本设置为7.1</p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/20201001085603.png?q=45" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt="image-20201001085602629"></p><p><code>Virtual Directories</code>网址设置为<code>/</code>路径设置为<code>site\wwwroot\public\</code></p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/20201001084000.png?q=45" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt="image-20201001083959803"></p><p>进入<code>Publish</code>选项卡，勾选<code>Local Git</code>，<code>Activate</code>这个方式</p><blockquote><p>注意，我强烈不推荐你使用FTP上传，FTP看起来有图形化很方便，但是请注意，Composer后的文件将近<strong>300+</strong>，FTP最致命的上传方式是<strong>每上传一个文件就会握一次手</strong>，这样子会严重浪费你的时间。而是用Github链接的同学我就要考虑你的危险的想法了，如果<strong>没有</strong>将仓库设置为Private，那么用Github链接是一个非常<strong>不明智</strong>的选择</p></blockquote><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/20201001084334.png?q=45" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt="image-20201001084334323"></p><p>绑定git，上传三步走，<code>git init &amp;&amp; git add . &amp;&amp; git commit -m &quot;OHH&quot; &amp;&amp; git push website master</code></p><p>绑定域名什么不多说了，建议套一层CloudFlare。</p><p>Gearhost所用的共享ip，来自美国 科罗拉多州 丹佛，三网优化都不好。当然回源CloudFlare还是不错的。</p><p>DEMO：<code>https://artalk-pub1.cyfan.top/</code></p><p>SLA：还在测试，大约95%，你可以前往<a href="https://status.cyfan.top" target="_blank" rel="noopener">https://status.cyfan.top</a>查看详情<img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/5c53d1904dcb2.gif" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>在页面id为12345有几个测试评论，你可以去测试一下，跨域均设置为’*‘。</p><p>管理员用户名：admin</p><p>管理员邮箱：<a href="mailto:admin@admin.admin" target="_blank" rel="noopener">admin@admin.admin</a></p><p>管理员密码：admin</p><h2 id="000webhost"><a href="#000webhost" class="headerlink" title="000webhost"></a>000webhost</h2><p><a href="https://www.000webhost.com/" target="_blank" rel="noopener">000webhost</a>也是个著名的免费php托管商，虽然早年的种种行为看着十分恶心，但是好歹也是个能白嫖的托管商。000webhost提供了每个账户一个免费的容器，每个容器每月3GB流量、300MB空间、1w个文件和每天25次邮箱发送。</p><p>000webhost的部署相对简单些，直接将所有文件拖拽上传【因为它不支持git上传】，稍等即可</p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/20201001150747.png?q=45" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt="image-20201001150747082"></p><p>上传至<code>public_html</code>子文件夹下：</p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/20201001151010.png?q=45" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt="image-20201001151009729"></p><p>000webhost不支持设置运行目录，这意味着data文件夹将会被曝光，但是我们可以设置000webhost的但目录密码保护：</p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/20201001151720.png?q=45" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt="image-20201001151719382"></p><p>这样，当有人试图访问<code>data/comments.data.json</code> 时，就会遭到密码拦截。</p><h4 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h4><p>由于000webhost域名验证需要一段时间，请先前往域名托管商设置记录。比如我的app名字是XXX.000webhostapp.com，我要绑定的是artalk-pub2.cyfan.top，就应该这样设置：</p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/20201001152945.png?q=45" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt="image-20201001152944348"></p><blockquote><p>请注意000webhost验证域名是通过dns记录来验证的，在验证完毕前请不要开启CDN！</p></blockquote><p>绑定域名，请鼠标移至卡片上，点击QuickActions，点击Details</p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/20201001152258.png?q=45" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt="image-20201001152257105"></p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/20201001152417.png?q=45" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt="image-20201001152417027"></p><p>点击My Domains,进入设置界面：</p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/20201001153113.png?q=45" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt="image-20201001153112150"></p><p>点击Add domain</p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/20201001153038.png?q=45" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt="image-20201001153038499"></p><p>选择PointDomain【毕竟把ns改到000webhost是不可能的】</p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/20201001153224.png?q=45" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt="image-20201001153224077"></p><p>如实填写，稍等即可。</p><p>DEMO:<a href="https://artalk-pub2.cyfan.top/public/" target="_blank" rel="noopener">https://artalk-pub2.cyfan.top/public/</a></p><p>SLA：还在测试，大约90%，你可以前往<a href="https://status.cyfan.top" target="_blank" rel="noopener">https://status.cyfan.top</a>查看详情</p><p>000webhost默认线路烂的和shit一样，强烈建议套CloudFlare</p><p>和另一个demo一样在页面id为12345有几个测试评论，你可以去测试一下，跨域为’*‘。</p><p>管理员用户名：admin</p><p>管理员邮箱：<a href="mailto:admin@admin.admin" target="_blank" rel="noopener">admin@admin.admin</a></p><p>管理员密码：admin</p><p>000webhost对于这些不能展现他的广告徽标的账户可能会存在限制处理，请注意【老恶心了】。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>国庆作业有点多，这篇要不是被我<del>亲爱</del>的群友催的要紧，我也不会水这一篇啊呜呜呜。<img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/5896ece2a019f.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>如果你的artalk卡在了转圈圈的问题上，你可以在html前面加上这一句</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://XXX.XXX.XXX/index.php"</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"preconnect"</span> <span class="hljs-attr">crossorigin</span>&gt;</span></code></pre></div><p><code>preconnect</code>可以强制在渲染页面试并发一个请求，可以有效解决5s超时问题和并发过多不稳定导致cancel问题。</p><p>另外你也可以用我的artalk脚本：</p><div class="hljs"><pre><code class="hljs http">https://cdn.jsdelivr.net/gh/ChenYFan-Tester/Artalk@gh-pages/Artalk.jshttps://cdn.jsdelivr.net/gh/ChenYFan-Tester/Artalk@gh-pages/Artalk.css</code></pre></div><ul><li>修改超时时间为60s</li><li>掩盖artalk标识</li><li><strong>杰哥</strong>提示语</li></ul><p>如果你觉得不放心，你可以亲自检查<a href="https://github.com/ChenYFan-Tester/Artalk/commits/master" target="_blank" rel="noopener">我做了什么</a>，我会尽量保证与原仓库同步。</p><p><del>国庆快乐！</del>写作业去了<img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/5c53dbe510bcf.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>此处不写.htaccess，gearhost就会莫名其妙炸500错误<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这篇的无服务器部署Artalk，指的是NoServer而不是Serverless&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;这篇所写的是部署后端，关于前端部署十分简单，这里不多阐述&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p</summary>
      
    
    
    
    <category term="随心记" scheme="https://blog.cyfan.top/categories/随心记/"/>
    
    
    <category term="评论" scheme="https://blog.cyfan.top/tags/评论/"/>
    
    <category term="Artalk" scheme="https://blog.cyfan.top/tags/Artalk/"/>
    
    <category term="无服务器" scheme="https://blog.cyfan.top/tags/无服务器/"/>
    
  </entry>
  
  <entry>
    <title>图床的千层套路</title>
    <link href="https://blog.cyfan.top/p/eb490c73.html"/>
    <id>https://blog.cyfan.top/p/eb490c73.html</id>
    <published>2020-09-12T13:27:41.000Z</published>
    <updated>2022-01-16T12:23:54.551Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 博客最近在细心打磨终于上95分了，其中我认为图片功劳不可没。<img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/cUEQrVYGFiDjqhy.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p></blockquote><p>2020年8月9日<a href="https://github.com/jsdelivr/jsdelivr/pull/18247/files" target="_blank" rel="noopener">Jsdelivr发布了一次使用政策：Create Acceptable Use Policy</a>，其中第4条Prohibited Use引起了众多议论：</p><div class="hljs"><pre><code class="hljs markdown"><span class="hljs-bullet">4. </span>Prohibited UseThe following behavior is prohibited:<span class="hljs-bullet"> 1. </span>Hosting or accessing content that:<span class="hljs-bullet">     - </span>contains malware or harmful code in any form,<span class="hljs-bullet">     - </span>violates proprietary rights of others,<span class="hljs-bullet">     - </span>is sexually explicit,<span class="hljs-bullet">     - </span>is potentially illegal in the EU or the USA.<span class="hljs-bullet"> 2. </span>Abusing the service and its resources, or using jsDelivr as a general-purpose<span class="hljs-code">    file or media hosting service. This includes, for example:</span><span class="hljs-bullet">     - </span>running an image hosting website and using jsDelivr as a storage for all<span class="hljs-code">       uploaded images,</span><span class="hljs-bullet">     - </span>hosting videos, file backups, or other files in large quantities.<span class="hljs-code">    We recognize that there are legitimate projects that consist of a large number</span><span class="hljs-code">    of files, and these are not considered abuse. For example: icons packs, apps,</span><span class="hljs-code">    or games with a large number of assets.</span></code></pre></div><p>其中<code>running an image hosting website and using jsDelivr as a storage for all uploaded images</code> 这一句相当的有歧义，要多少的图片才能算是图站？博客里面图片放里面算吗？上传的图片怎样才不行？<img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/TlAGjm6IvJSMVpq.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>反观网上流传的白嫖Github做图床，基本点进去都是<code>https://cdn.jsdelivr.net/gh/</code> 这样子的图床，这种行为，我不敢妄加评论。但是，jsdelivr诞生的意义似乎并不是为了图床而生的，这种行为也很难判断成滥用。<img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/5896ece29a8e0.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>使用政策发布之后，一时间，QQ群、v2ex、知乎上立刻就炸了锅。很多人猜测jsdelivr是不是滥用过度而禁止将其作为图床？免费图床的白嫖日子要结束了吗？更多的人，是在哭诉和询问那里还有像jsd一样优秀的<strong>图床</strong>可以白嫖，微博炸了，那里还有免费图床啊？</p><p>实际上，我一般采用的是<code>BackBlaze+CloudFlare</code> 但是自从八月底移动开始改道，从原先优秀的CMI绕路LAX后，国内CloudFlare访问质量再次暴跌，这不得不使我将博客迁至Vercel。好在八月份我有幸申请到了<code>doegdoge图床</code>使用权限，获得了国内较高速的图床.</p><p>但是，对于哪些没有没有图床的人来说，免费图床真的这么难以获得吗？</p><p>不好意思，<strong>免费图床非常多</strong>，只是你不会用而已，这篇文章，就是拯救面前陷入图床危机的你【当然是面向小白，大佬也可以在底下给我提意见鸭】。<img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/stick_56.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><h1 id="公益图床"><a href="#公益图床" class="headerlink" title="公益图床"></a>公益图床</h1><h2 id="sm-ms"><a href="#sm-ms" class="headerlink" title="sm.ms"></a>sm.ms</h2><p><a href="https://sm.ms" target="_blank" rel="noopener">https://sm.ms</a></p><p>推荐程度：★</p><p>首先推荐的是这个图床，loli.net域名经典重现。三年前此图床域名还有备案采用的是国内CDN，可惜后来因为滥用吊销备案号而被迫迁移国外，用的是CloudFlare。实际使用效果面向国内确实不太好，建议备用。</p><p>你不需要注册，拖拽直接上传，只要不违反大陆和香港法律，他就能永久保留你的图片</p><p><img src="https://i.loli.net/2020/09/12/OxvnMBwd3VA8uyD.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>可搭配PicGo</p><h2 id="Imgur"><a href="#Imgur" class="headerlink" title="Imgur"></a>Imgur</h2><p><a href="https://imgur.com" target="_blank" rel="noopener">https://imgur.com</a></p><p>推荐程度：★★</p><p>国外一家牛逼的图片托管服务商，你可以选择注册或不注册，同样的，拖拽上传，永久保留，其SLA有着相当高的保证。</p><p>然而很可惜的是，这种网站很早就在国内被<strong>DNS域名污染</strong>，也就意味着访客无法正常加载你的图片。这也就是被打为两颗星的原因。<img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/%E4%B8%8D%E8%AF%B4%E8%AF%9D.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>当然，你也可以通过<a href="#图像缓存服务">#图像缓存服务</a> 从而实现国内访问。</p><p>可搭配PicGo【需注册】</p><h2 id="去不图床"><a href="#去不图床" class="headerlink" title="去不图床"></a>去不图床</h2><p><a href="https://7bu.top/" target="_blank" rel="noopener">https://7bu.top/</a></p><p>推荐程度：★★★★</p><p>由<a href="https://dusays.com/241/" target="_blank" rel="noopener">杜老师</a>提供的个人公益图床，存储于阿里和腾讯的COS，官方保证SLA&gt;=99%，是一个不错的选择，当然，7bu毕竟是个人维护的图床，能不能永久撑下去还是个问题，我也没有做过深度评测，无法表明其可用性。</p><p>可搭配PicGo。</p><div class="hljs"><pre><code class="hljs yml"><span class="hljs-string">接口地址：https://7bu.top/api/upload</span><span class="hljs-string">post参数：image</span><span class="hljs-string">回调json：data.url</span></code></pre></div><p><a href="https://7bu.top/index/api.html" target="_blank" rel="noopener">更准确的API文档</a></p><p><img src="https://7.dusays.com/2020/09/13/aa555748a9f38.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><blockquote><p><del>而且，就在我上传测试图片的时候，明明已经表明图片已经上传，打开却发现COS提示404，这一点我不得陷入思考，个人维持的公益项目真的能保证SLA吗？<img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/%E4%BE%BF%E4%BE%BF.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></del></p></blockquote><blockquote><p>昨天上传的时候撞上服务器维修了，很抱歉做出了不够恰当的评价.7bu采用的是全国腾讯云CDN加速，国内访问速度十分优良。然而请注意，7bu刚开始建立的目的并不是面向全球【仅面对中国大陆游客】，这导致其大陆以外基本解析至国内西藏腾讯，访问效果并不好。并且，这是通过腾讯云的鉴黄，可能会存在误杀行为。具体使用请个人斟酌【不过作为开发环境还是可行的】。</p></blockquote><h1 id="白嫖的"><a href="#白嫖的" class="headerlink" title="白嫖的"></a>白嫖的</h1><h2 id="阿里图床"><a href="#阿里图床" class="headerlink" title="阿里图床"></a>阿里图床</h2><p><del>推荐程度：★★★★</del></p><p><del>我个人搭建的API：<a href="https://picbed.cyfan.top" target="_blank" rel="noopener">https://picbed.cyfan.top</a> 不保证上传SLA<img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/5c53ce897ab55.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></del></p><p><del>由于小鸡联通国内网络不太好，很有可能无法正常上传，<a href="https://github.com/ChenYFan-Tester/Alibaba_pic" target="_blank" rel="noopener">原项目已经开源</a> ，你完全可以通过在国内的机子或者是本地搭建以获得更佳体验。</del></p><p><del>如果上传成功了，图片将会托管于阿里云的CDN，无论是速度还是延迟都相当的优秀。</del></p><p><del>官方大厂，下载SLA有保障。</del></p><p><del>可搭配PicGo。</del></p><div class="hljs"><pre><code class="hljs yml"><span class="hljs-string">接口地址：https://picbed.cyfan.top/update.php</span><span class="hljs-string">post参数：file</span><span class="hljs-string">回调json：data.url</span></code></pre></div><p><strong>已失效，切勿使用</strong></p><h2 id="DogeDoge图床"><a href="#DogeDoge图床" class="headerlink" title="DogeDoge图床"></a>DogeDoge图床</h2><p>推荐程度：★★★★★</p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/20200912192303.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt="TEST"></p><p>其实很早就看到<a href="https://v2ex.com/t/659652" target="_blank" rel="noopener">V2EX的那篇征文了</a>：</p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/20200912190301.png?q=45" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>可是当时我不够优秀啊<span class="heimu">虽然现在同样不优秀</span>，博客也没满一年啊，于是白嫖的心态搁浅了。<img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/5896e8a408253.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>后来突然看到<a href="https://blog.jalenchuh.cn/" content="nofollow" target="_blank" rel="noopener">Jalen的博客</a>也用了DogeDoge图床，这才突然意识到原来我已经满一年了。于是抱着试试看的心态向doge官方邮箱发送了邮件，结果真过了。。。</p><p>dogedoge拥有着国内相当不错的CDN，国内访问飞快，但是国外的访问质量的确不如人意。【反正此博客面向中国大陆】</p><p>而且，DogeDoge拥有着很良心的处理参数：</p><div class="hljs"><pre><code class="hljs yml"><span class="hljs-string">w：宽</span><span class="hljs-string">h：高</span><span class="hljs-string">mode：模式</span> <span class="hljs-bullet">-</span> <span class="hljs-string">crop</span> <span class="hljs-string">裁剪、clip</span> <span class="hljs-string">缩略</span><span class="hljs-string">fmt：格式</span> <span class="hljs-bullet">-</span> <span class="hljs-string">jpg、png、webp（原图为</span> <span class="hljs-string">gif，且没有</span> <span class="hljs-string">frame</span> <span class="hljs-string">参数时，不做任何裁切、缩略处理）</span><span class="hljs-string">frame：1</span> <span class="hljs-bullet">-</span> <span class="hljs-string">EOF帧，默认为</span> <span class="hljs-number">1</span> <span class="hljs-string">（对动画有效）</span><span class="hljs-string">q：压缩质量</span> <span class="hljs-bullet">-</span> <span class="hljs-number">1</span> <span class="hljs-bullet">-</span> <span class="hljs-number">100</span><span class="hljs-string">（默认</span> <span class="hljs-number">90</span> <span class="hljs-string">）</span><span class="hljs-string">rect：指定位置裁剪</span> <span class="hljs-bullet">-</span> <span class="hljs-string">top,left,w,h（若与</span> <span class="hljs-string">w</span> <span class="hljs-string">/</span> <span class="hljs-string">h</span> <span class="hljs-string">参数同时存在，则</span> <span class="hljs-string">会在</span> <span class="hljs-string">rect</span> <span class="hljs-string">裁剪过后，继续按照</span> <span class="hljs-string">w</span> <span class="hljs-string">/</span> <span class="hljs-string">h</span> <span class="hljs-string">的要求缩略）</span><span class="hljs-string">pos：（配合</span> <span class="hljs-string">w</span> <span class="hljs-string">/</span> <span class="hljs-string">h</span> <span class="hljs-string">）裁剪位置</span> <span class="hljs-bullet">-</span> <span class="hljs-string">top-left、top、top-right、left、center、right、bottom-left、bottom、bottom-right，默认为center</span><span class="hljs-string">pos</span> <span class="hljs-string">还有一个特殊的值</span> <span class="hljs-string">auto，该值目前为</span> <span class="hljs-string">alpha</span> <span class="hljs-string">状态，可以根据图片重点来进行</span> <span class="hljs-string">pos</span> <span class="hljs-string">的位置取舍。</span></code></pre></div><p>话说回来，DogeDoge也可以搭配PicGo使用。</p><div class="hljs"><pre><code class="hljs yml"><span class="hljs-string">接口地址：https://www.dogedoge.com/tools/upload/&#123;Your_Token&#125;</span><span class="hljs-string">post参数：file</span><span class="hljs-string">回调json：data.o_url</span></code></pre></div><p>当然，现在的Doge图床还是处于免费的试用期【Creater】，不过好在试用期过后价格也比较合理，一般的tester也足够使用，目前看来SLA还是不错的。</p><p>不过，申请不到dogedoge图床也没关系，看下去你就会发现，白嫖的路千千万万，何必执着于一条。<img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/stick_34.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/20200912205753.png?q=45" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><h2 id="BackBlaze"><a href="#BackBlaze" class="headerlink" title="BackBlaze"></a>BackBlaze</h2><p>推荐程度：★★★</p><p>具体可以看看<a href="/p/ce240368.html">这篇文章</a></p><h2 id="千奇百怪的"><a href="#千奇百怪的" class="headerlink" title="千奇百怪的"></a>千奇百怪的</h2><h2 id="Github-JSDelivr"><a href="#Github-JSDelivr" class="headerlink" title="Github+JSDelivr"></a>Github+JSDelivr</h2><p>正如我所说的，这种组合已经被广大博主所采纳，并且网上教程已经泛滥了，在这里不再阐述。</p><h2 id="npm-JSDelivr-amp-amp-Zhimg-amp-amp-bdstatic-amp-amp-自定义镜像"><a href="#npm-JSDelivr-amp-amp-Zhimg-amp-amp-bdstatic-amp-amp-自定义镜像" class="headerlink" title="npm+JSDelivr&amp;&amp;Zhimg&amp;&amp;bdstatic&amp;&amp;自定义镜像"></a>npm+JSDelivr&amp;&amp;Zhimg&amp;&amp;bdstatic&amp;&amp;自定义镜像</h2><p>推荐程度：★★★★★</p><p>为什么很多文章都没有提到用npm做图床？我想其中很大的原因是，白嫖jsd做图床的，很多都是小白【或者不愿花时间在于此的大佬】，同样的，这些文章面向的都是这些人，毕竟，以拖拽方式上传的Github和命令行方式上传，我想，大都数人会选择前者吧。</p><p>可是，你们没有想到的是，github文件镜像【github.com.cnpmjs.org是站点镜像】只有jsd一个，npm镜像可远远不止这一个啊！</p><p>让我们看看分别镜像在jsd、zhimg、bdstatic的文件怎么样：</p><p><img src="https://npm.elemecdn.com/chenyfan-oss@0.0.1/1.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p><img src="https://npm.elemecdn.com/chenyfan-oss@0.0.1/2.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p><img src="https://code.bdstatic.com/npm/chenyfan-oss@0.0.1/3.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>【unpkg镜像用的是CloudFlare，国内加速效果不好，暂时不写】</p><p>jsd就不必多说了，国内拥有强劲的网宿节点支撑【虽然以前出现过网宿下游投毒】，速度丝滑无比，国外也有强劲的CloudFlare上岗，可谓国内外两不误。而且，jsd对于npm的package单文件没有大小限制，也就是说泡个视频也不是问题。</p><p>zhimg是知乎的unpkg镜像，也是一个不错的选择【阿里CDN】，知乎官方也未对此做出限制，日常使用是可以的。</p><p>bdstatic是百度的内用npm镜像，速度也很好【百度CDN】，但是请注意，bdstatic作为内用cdn，其拉取频率较慢，经常出现无法及时更新。</p><p>啊哈？不会上传？<br><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/stick_31.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt>去<a href="https://npmjs.org" target="_blank" rel="noopener">npm</a><br>官网注册个账号去,然后先：</p><div class="hljs"><pre><code class="hljs bash">npm login</code></pre></div><p>接着：</p><div class="hljs"><pre><code class="hljs bash">npm initnpm publish</code></pre></div><p>请注意，如果你之前用过淘宝镜像，那么请先手动切回源：</p><div class="hljs"><pre><code class="hljs bash">npm config <span class="hljs-built_in">set</span> registry https://registry.npmjs.org</code></pre></div><p>每一次发布图片后，你可以将原来的图片删除，更改<code>package.json</code> 版本号【向上增加】,然后<code>npm publish</code>即可</p><p>这个似乎可以搭配picgo，不过好像没这个插件，写起来也麻烦。。。</p><p>unpkg的国内镜像其实远远不止这些，包括七牛、饿了么、腾讯都有，不过这个就要自己找了。<img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/7DgSoyqwtYBxchE.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>一些推荐的npm【or unpkg镜像】：</p><div class="hljs"><pre><code class="hljs markdown">【jsd出品，网宿国内节点】https://npm.elemecdn.com/【知乎出品，网宿国内节点】https://npm.elemecdn.com/【百度出品，网宿国内节点】https://code.bdstatic.com/npm/【饿了么出品，网宿国内节点，回源是Unpkg，建议用这个】https://npm.elemecdn.com/【饿了么出品，网宿国内节点，回源是JSdelivr，貌似可以用github，但是我用的时候大多无法正常回源，只能获取几个已缓存的热门库】https://shadow.elemecdn.com/npm/【怎么都是网宿的】</code></pre></div><p>或者说，你还可以自建unpkg镜像。</p><p>啊，你说你没有服务器反向代理unpkg？</p><p>其实，七牛的对象存储，腾讯的COS和阿里的OSS都是支持镜像回源的鸭！</p><p>七牛http流量每月免费10GB，腾讯的国内免费60GB6个月，作为自用完全足够了！</p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/L6LVJL_1ZUM2ISQ%5D10R%7B3HF.png?q=45" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><h2 id="ipfs"><a href="#ipfs" class="headerlink" title="ipfs"></a>ipfs</h2><p>我曾经<a href="/2020/04/07/IPFS-CloudFlare-ServerLessWebPage/">写过关于ipfs的讲解</a> ,作为一个去中心化的存储系统拿来做公开图床其实挺不错的。</p><p>我个人搭建的ipfs镜像【托管于CloudFlareWorkers】：<a href="https://ipfs.cyfan.top" target="_blank" rel="noopener">https://ipfs.cyfan.top</a> <img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/5c53d78c3f4a5.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>我个人搭建的ipfs上传API：<a href="https://ipfsupload.cyfan.top" target="_blank" rel="noopener">https://ipfsupload.cyfan.top</a></p><p>基于Vercel+CloudFlare<del>【我也不知道worker为什么死活上传不上去】</del></p><div class="hljs"><pre><code class="hljs yml"><span class="hljs-string">接口地址：https://ipfsupload.cyfan.top/api/v0/add?pin=true</span><span class="hljs-string">post参数：file</span><span class="hljs-string">回调json：Hash</span></code></pre></div><blockquote><p>此处Hash获得的是文件的Qmhash，你还要依托ipfs镜像，如<a href="https://ipfs.cyfan.top/ipfs/{QmHash}" target="_blank" rel="noopener">https://ipfs.cyfan.top/ipfs/{QmHash}</a></p></blockquote><p><img src="https://ipfs.cyfan.top/ipfs/QmctXmCyxkN72nzoHMAgw1geR7u9XvK7sLo72W4bDZsCm2" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>顺便收录一些ipfs网关【可访问】：</p><div class="hljs"><pre><code class="hljs html">【北京 阿里云】https://hashnews.k1ic.com/【香港 阿里云】https://ipfs.jbb.one/【美国 DigitalOcean】https://ipfs.telos.miami/【Amazon】https://ipfs.oceanprotocol.com/</code></pre></div><p>你可以在<a href="https://ipfs.github.io/public-gateway-checker/" target="_blank" rel="noopener">https://ipfs.github.io/public-gateway-checker/</a>找到更多</p><h1 id="图片缓存服务"><a href="#图片缓存服务" class="headerlink" title="图片缓存服务"></a>图片缓存服务</h1><p>正如<a href="##Imgur">##Imgur</a>所说的，imgur在国内已经无法访问了，但是，图片缓存服务可以啊！</p><p><img src="https://search.pstatic.net/common/?src=https://i.imgur.com/Usdr0IT.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>收集了一些图片缓存服务：</p><div class="hljs"><pre><code class="hljs http">【国内网宿节点，只能加载特定图床图片如imgur】https://search.pstatic.net/common/?src=【Akamai节点，没有使用限制】https://imageproxy.pimg.tw/resize?url=【CloudFlare节点】https://images.weserv.nl/?url=【CloudFlare节点】https://pic1.xuehuaimg.com/proxy/</code></pre></div><h1 id="PicGo的搭配使用"><a href="#PicGo的搭配使用" class="headerlink" title="PicGo的搭配使用"></a>PicGo的搭配使用</h1><p>PicGo默认已经集成了部分图床，其拖拽上传、自动复制剪贴板实在赢得了无数人的心。但是，对于一些冷门的图床支持似乎就不太好，这时候你需要用自定义web图床实现这一切：</p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/20200912205225.png?q=45" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>我在上方介绍的图床如果支持web端上传，基本上就会写一个post请求，你可以依葫芦画瓢填写进去</p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/20200912205449.png?q=45" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>这样子你就可以实现较为丝滑的上传图片了：</p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/20200912210009.jpg?q=45" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/20200912210420.gif?q=45" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>【为了压缩方便删除了部分帧】</p><h1 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h1><p>实际上最保险的莫过于使用各大厂商的对象存储，当然这笔钱不大好使。<br>你也可以用自己的VPS搭建Chevereto，当然前提是你有VPS<img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/5c53de1a4d14d.gif" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt; 博客最近在细心打磨终于上95分了，其中我认为图片功劳不可没。&lt;img src=&quot;https://rmt.dogedoge.com/fetch/hi-c-oss/storage/cUEQrVYGFiDjqhy.jpg&quot; srcset=&quot;https:</summary>
      
    
    
    
    <category term="随心记" scheme="https://blog.cyfan.top/categories/随心记/"/>
    
    
    <category term="白嫖" scheme="https://blog.cyfan.top/tags/白嫖/"/>
    
    <category term="图床" scheme="https://blog.cyfan.top/tags/图床/"/>
    
    <category term="PicGo" scheme="https://blog.cyfan.top/tags/PicGo/"/>
    
    <category term="JSDelivr" scheme="https://blog.cyfan.top/tags/JSDelivr/"/>
    
  </entry>
  
  <entry>
    <title>多域名线程并发与DNS预解析</title>
    <link href="https://blog.cyfan.top/p/6ce8a474.html"/>
    <id>https://blog.cyfan.top/p/6ce8a474.html</id>
    <published>2020-08-24T13:08:38.000Z</published>
    <updated>2022-01-16T12:23:54.551Z</updated>
    
    <content type="html"><![CDATA[<p>军训结束,感想不多,就一句话</p><blockquote><p>【这就是个无限循环，每天重复训练一套动作，直到结束为止，毫无意义】</p></blockquote><p>回家之后我帮父母看店,顺便点开了浏览器,浏览器卡死了30s,终于完全加载出了一个花花绿绿的主页,是大名鼎鼎的2345主页.</p><p>虽然我很反感这种杂七杂八的傻逼导航,我也试图将主页换成magi或dogedoge,但是父亲就很不习惯,原因很难以接受:</p><div class="hljs"><pre><code class="hljs undefined">儿子啊，这样我怎么看天气啊。</code></pre></div><p>。。。</p><p>于是我顺手右键点开了源代码，闲着无聊看看，结果却刚看看就找到了好<del>康</del>看的东西：</p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/2020-08-24%20175355.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><div class="hljs"><pre><code class="hljs undefined">&lt;link <span class="hljs-attribute">rel</span>=<span class="hljs-string">"dns-prefetch"</span> <span class="hljs-attribute">href</span>=<span class="hljs-string">"https://union2.50bang.org"</span>&gt;&lt;link <span class="hljs-attribute">rel</span>=<span class="hljs-string">"dns-prefetch"</span> <span class="hljs-attribute">href</span>=<span class="hljs-string">"//h.2345cdn.net"</span>&gt;&lt;link <span class="hljs-attribute">rel</span>=<span class="hljs-string">"dns-prefetch"</span> <span class="hljs-attribute">href</span>=<span class="hljs-string">"//image.2345.com"</span>&gt;&lt;link <span class="hljs-attribute">rel</span>=<span class="hljs-string">"dns-prefetch"</span> <span class="hljs-attribute">href</span>=<span class="hljs-string">"//00imgmini.eastday.com"</span>&gt;&lt;link <span class="hljs-attribute">rel</span>=<span class="hljs-string">"dns-prefetch"</span> <span class="hljs-attribute">href</span>=<span class="hljs-string">"//01imgmini.eastday.com"</span>&gt;&lt;link <span class="hljs-attribute">rel</span>=<span class="hljs-string">"dns-prefetch"</span> <span class="hljs-attribute">href</span>=<span class="hljs-string">"//02imgmini.eastday.com"</span>&gt;&lt;link <span class="hljs-attribute">rel</span>=<span class="hljs-string">"dns-prefetch"</span> <span class="hljs-attribute">href</span>=<span class="hljs-string">"//03imgmini.eastday.com"</span>&gt;&lt;link <span class="hljs-attribute">rel</span>=<span class="hljs-string">"dns-prefetch"</span> <span class="hljs-attribute">href</span>=<span class="hljs-string">"//04imgmini.eastday.com"</span>&gt;&lt;link <span class="hljs-attribute">rel</span>=<span class="hljs-string">"dns-prefetch"</span> <span class="hljs-attribute">href</span>=<span class="hljs-string">"//05imgmini.eastday.com"</span>&gt;&lt;link <span class="hljs-attribute">rel</span>=<span class="hljs-string">"dns-prefetch"</span> <span class="hljs-attribute">href</span>=<span class="hljs-string">"//pos.baidu.com"</span>&gt;&lt;link <span class="hljs-attribute">rel</span>=<span class="hljs-string">"dns-prefetch"</span> <span class="hljs-attribute">href</span>=<span class="hljs-string">"//p.tanx.com"</span>&gt;&lt;link <span class="hljs-attribute">rel</span>=<span class="hljs-string">"dns-prefetch"</span> <span class="hljs-attribute">href</span>=<span class="hljs-string">"//gma.alicdn.com"</span>&gt;</code></pre></div><p>欸，<code>dns-prefetch</code> 是什么?</p><p>好吧，看起来你我都不懂.</p><h2 id="多并发请求"><a href="#多并发请求" class="headerlink" title="多并发请求"></a>多并发请求</h2><p>请问，一号网页和二号网页哪个加载更快？</p><blockquote><p>假设每张图片的大小为无限小,传输速度为无限大,<code>exmple1.com</code>是 <code>exmple.com</code> 的镜像</p></blockquote><p>一号：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-meta">&lt;!doctype <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://exmple.com/1.jpg"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://exmple.com/2.jpg"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://exmple.com/3.jpg"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://exmple.com/4.jpg"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://exmple.com/5.jpg"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://exmple.com/6.jpg"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://exmple.com/7.jpg"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://exmple.com/8.jpg"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://exmple.com/9.jpg"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://exmple.com/10.jpg"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://exmple.com/11.jpg"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://exmple.com/12.jpg"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>二号：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-meta">&lt;!doctype <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://exmple.com/1.jpg"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://exmple.com/2.jpg"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://exmple.com/3.jpg"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://exmple.com/4.jpg"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://exmple.com/5.jpg"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://exmple.com/6.jpg"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://exmple1.com/7.jpg"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://exmple1.com/8.jpg"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://exmple1.com/9.jpg"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://exmple1.com/10.jpg"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://exmple1.com/11.jpg"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://exmple1.com/12.jpg"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>好了公布答案了,很显然<span class="heimu">二</span>号加载更快。</p><p>这时候有人就会问了，凭什么啊！不是说图片无限小吗？右边的反而会增加dns解析时间，难道不会更慢吗？</p><p>好吧好吧，实际上，你以为的加载时间是这样的</p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/2020-08-24%20180740.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>可是实际上是这样子的：</p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/2020-08-24%20200044.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>欸这就很有意思了同学们，为什么最后六张会出现Pending状态？</p><p>实际上，浏览器是有并发请求数目限制【通常是2-8个】，虽然这种比较坑人，但这也是为了避免同时大量并发导致资源占用过度，并且只针对同一个域名的（例如向cdn.jsdelivr.net发送请求）。即一时间针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞并进入Pending状态。</p><p>从用户的角度来说，浏览器不可能无限量的并发请求，因此衍生出来了并发限制和HTTP/1.1的Keep alive。 所以，IE6/7在HTTP/1.1下的并发才<strong>2</strong>，但HTTP/1.0却是<strong>4</strong>。 而随着技术的发展，负载均衡和各类NoSQL的大量应用，基本已经足以应对C10K的问题。 但却并不是每个网站都懂得利用domain hash也就是多域名来加速访问。因此，新的浏览器加大了并发数的限制，但却仍控制在8以内。</p><p>然而从服务器的角度来讲，我们也可以窥见，无限制的并发请求无异于一次小型CC，对于保护服务器和优化用户体验还是相当重要的。</p><p>从网站上入手，实际上这一点相当容易理解,2345一打开就是少则五十多张图片同时加载,甚至那些下拉箭头为了兼容ie都还是图片而非fontawesome,如果不绕过并发限制,岂不是一片空白.</p><p>那么问题来了，如何避免堵塞？</p><p>答案显然易见,多换几个域名不就行了??这样图片分别从两个域名获取，直接避免恼火的Pending，</p><p>2345主页中 <code>00imgmini.eastday.com</code> 至 <code>05imgmini.eastday.com</code> 五个域名均是拿来绕开并发限制的。</p><h2 id="Cookie-Free"><a href="#Cookie-Free" class="headerlink" title="Cookie Free"></a>Cookie Free</h2><p>每请求一次资源，就会生成一次新的Cookie。如果网站每个资源cookie有1 KB、网站首页共150个资源时，用户在请求过程中需要发送150 KB的cookie信息，在512 Kbps的常见上行带宽下，需要长达3秒左右才能全部发送完毕。 尽管这个过程可以和页面下载不同资源的时间并发，但毕竟对速度造成了影响。 而且这些信息在js/css/images/html等静态资源上，几乎是没有任何必要的。</p><p> 解决方案是启用和主站不同的域名来放置静态资源，也就是cookie free。</p><blockquote><p>注意此处所指的是主域名而非子域名，子域名的Cookie会和主域名共存</p></blockquote><p>但是这样，就孪生出一个极其严重的问题，多个域名，必然会加重<strong>DNS解析时间</strong>和<strong>SSL的握手时间</strong></p><h2 id="避免DNS拥堵"><a href="#避免DNS拥堵" class="headerlink" title="避免DNS拥堵"></a>避免DNS拥堵</h2><p>一旦采用<strong>多域名的方式绕开并发量限制</strong>，就会导致浏览器在请求时必须一个一个解析过去，从<code>00imgmini.eastday.com</code>至<code>05imgmini.eastday.com</code>，然而DNS解析时间虽然短，但是多个解析必然导致严重拖慢速度，此时我们就需要进行预解析。</p><blockquote><p>请注意，预解析在部分主流浏览器中支持，但是并不是所有页面和条件下都支持。</p></blockquote><p>正常情况下打开一个网页，浏览器会做出以下动作：</p><ol><li><p>浏览器向请求网址发起DNS解析</p></li><li><p>浏览器向服务器一个GET请求，拉起进入Pending</p></li><li><p>浏览器解析html，完成初步CSS渲染【此时标题栏显示标题】</p></li><li><p>进行js解析，并请求额外的资源</p></li></ol><p>DNS解析时间的浪费主要阻塞在第四步，为避免解析时间的阻塞，我们采用<code>dns-prefetch</code>进行优化.</p><p>在html头添加</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"x-dns-prefetch-control"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"on"</span> /&gt;</span></code></pre></div><p>向浏览器表明我需要预解析。</p><p>接着【建议】在<code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code> 后添加</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"dns-prefetch"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"//exmple.com"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"dns-prefetch"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"//exmple1.com"</span>&gt;</span></code></pre></div><p>表明强制解析这些域名。并且以后会一直记住这个域名的解析结果直到关闭为止。</p><p>//开始是为了适配 <code>https</code> 和 <code>http</code> 。就是当前请求链接是https ，那么这个//前面自动补充https ，反则补充http 。</p><h1 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h1><p>切记 <code>dns-prefetch</code> 不能滥用，它虽然能一定提升网页打开速度，但也会对浏览器产生一定负担。</p><p>这边的建议是，作为个人，我并不推荐将此方法运用于个人博客。原因很简单，你博客一次能有几张图片？如果你是开图站的，那么这个方法刚好可以运用到你的网站里，只要进行多域名分开并dns欲解析就可以进一步提升网站体验了。</p><p>最后上生肉：</p><blockquote><p>DNS prefetching is an attempt to resolve domain names before a user tries to follow a link. This is done using the computer’s normal DNS resolution mechanism; no connection to Google is used. Once a domain name has been resolved, if the user does navigate to that domain, there will be no effective delay due to DNS resolution time. The most obvious example where DNS prefetching can help is when a user is looking at a page with many links to various domains, such as a search results page. When we encounter hyperlinks in pages, we extract the domain name from each one and resolving each domain to an IP address. All this work is done in parallel with the user’s reading of the page, using minimal CPU and network resources. When a user clicks on any of these pre-resolved names, they will on average save about 200 milliseconds in their navigation (assuming the user hadn’t already visited the domain recently). More importantly than the average savings, users won’t tend to experience the “worst case” delays for DNS resolution, which are regularly over 1 second.</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;军训结束,感想不多,就一句话&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;【这就是个无限循环，每天重复训练一套动作，直到结束为止，毫无意义】&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;回家之后我帮父母看店,顺便点开了浏览器,浏览器卡死了30s,终于完全加载出了一个花花绿绿的主页</summary>
      
    
    
    
    <category term="好方法" scheme="https://blog.cyfan.top/categories/好方法/"/>
    
    
    <category term="DNS" scheme="https://blog.cyfan.top/tags/DNS/"/>
    
    <category term="预解析" scheme="https://blog.cyfan.top/tags/预解析/"/>
    
    <category term="优化" scheme="https://blog.cyfan.top/tags/优化/"/>
    
  </entry>
  
  <entry>
    <title>CFWorker-ODIndex中文文档&amp;使用教程</title>
    <link href="https://blog.cyfan.top/p/4fb070ca.html"/>
    <id>https://blog.cyfan.top/p/4fb070ca.html</id>
    <published>2020-08-14T01:51:23.000Z</published>
    <updated>2022-01-16T12:23:54.551Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>写在最前面</strong><br>自从这篇博文发布后，OneIndex迎来了一次重大更新，去除了FireBase依赖，转用KV存储刷新令牌。本片教程已过时，具体会在春节前后更新最新版本。</p></blockquote><p>OneDrive，相信大家都不陌生，微软家的网盘，虽说有类似于OneManager一样的目录列表程序，但是直连海外总是会遭受严重的丢包，得到极其糟糕的体验。这时候CLoudFlare作为不那么好使的CDN就排上用场了，项目<a href="https://github.com/spencerwooo/onedrive-cf-index" target="_blank" rel="noopener">onedrive-cf-index</a> 解决了这个问题,但是据我观察,这个仓库作者应该是个中国人,但是readme文档可不是中文,这对一些使用者造成了一定的困扰,而且文档相当<strong>言简意赅</strong><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/%E4%B8%AD%E6%9E%AA.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt>,这一篇文章相当于文档的中文翻译和使用教程.</p><blockquote><p><strong>使用前言</strong><br>部署此项目较为麻烦,请确保你满足以下俩个及以上想法后,才继续往下读:</p><ol><li>我非常需要搭建于CloudFlare的OneDrive目录列表吗?<img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/%E5%B0%8F%E7%9C%BC%E7%9D%9B.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></li><li>我非常需要这个版本的目录列表吗?<img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/%E8%82%BF%E5%8C%85.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></li><li>我有这个耐心吗?<img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/%E6%83%B3%E4%B8%80%E6%83%B3.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt><br>如果没有,那么我们建议你可以使用另一个功能和UI稍差的cf目录列表<a href="https://github.com/heymind/OneDrive-Index-Cloudflare-Worker" target="_blank" rel="noopener">OneDrive-Index-Cloudflare-Worker</a> 这个版本有不是很详尽的中文文档,并且较为简单,或者试试一步生成的GDIndex,可以参考我之前写的<a href="https://blog.cyfan.top/2020/03/18/%E5%85%8D%C2%B7%E7%88%AC%C2%B7%E5%9F%8E%C2%B7%E5%9B%BD%E5%86%85%E7%AE%A1%E7%90%86%E5%88%86%E4%BA%ABGoogleDrive/">GDIndex部署参考</a></li></ol></blockquote><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><strong>新功能</strong></p><ul><li>新设计： spencer.css。</li><li>根据文件类型呈现的文件图标。</li><li>使用“Font Awesome icons” 图标代替材料设计图标（以获得更好的设计一致性）。</li><li>使用github-markdown-css进行README.md渲染</li><li>添加Cookie以更好地进行目录导航。</li><li>支持文件预览：</li><li>图片：.png，.jpg，.gif</li><li>纯文本：.txt</li><li>文档：.md，.mdown，.markdown</li><li>代码：.js，.py，.c，.json。</li><li>PDF：延迟加载，加载进度和内置的PDF查看器</li><li>音乐/音频： .mp3，.aac，.wav，.oga</li><li>视频： .mp4，.flv，.webm，.m3u8</li></ul><p>…</p><ul><li>代码语法以GitHub样式突出显示。（使用PrismJS。）</li><li>图像预览支持中型缩放效果。</li><li>使用Google Firebase实时数据库缓存和刷新令牌。（对于那些负担不起Cloudflare Workers KV存储的人。 😢）</li><li>在Turbolinks®的帮助下进行延迟加载。（从folder转到时有些问题file preview，但不会降低用户体验。）<br>…</li></ul><p>在这表面下:</p><ul><li>一直以来都是CSS动画。</li><li>使用wrangler和webpack打包源代码。</li><li>转换所有CDN以使用jsDelivr加载。</li><li>没有外部JS脚本，所有脚本都已通过webpack加载！（除了某些库。）</li></ul><p>…<br>所有其他功能</p><p>请参阅：<a href="https://github.com/heymind/OneDrive-Index-Cloudflare-Worker#-%E6%96%B0%E7%89%B9%E6%80%A7-v11" target="_blank" rel="noopener">新功能| OneDrive-Index-Cloudflare-Worker</a>。</p><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><h2 id="导入此项目"><a href="#导入此项目" class="headerlink" title="导入此项目"></a>导入此项目</h2><blockquote><p><strong>请注意!</strong><br>请不要Fork此项目<img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/stick_4.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt>,<br>在这个过程中你将会获取到数串token,fork的仓库无法转为私有仓库,这将会对你的数据造成威胁.</p></blockquote><p>点击右上角的 <code>+</code> 号选择Import项目</p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/2020-08-14065738.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>原先仓库地址填写<a href="https://github.com/spencerwooo/onedrive-cf-index" target="_blank" rel="noopener">https://github.com/spencerwooo/onedrive-cf-index</a>,新仓库名称随意,仓库类型必须改为Private私人,最后导入</p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/2020-08-14065831.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>导入成功,进入repo:</p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/2020-08-14065940.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><h2 id="获取Token"><a href="#获取Token" class="headerlink" title="获取Token"></a>获取Token</h2><p>进入<a href="https://heymind.github.io/tools/microsoft-graph-api-auth" target="_blank" rel="noopener">https://heymind.github.io/tools/microsoft-graph-api-auth</a> 开始准备你所需要的东西：</p><p>进入<a href="https://portal.azure.com/#blade/Microsoft_AAD_RegisteredApps/ApplicationsListBlade" target="_blank" rel="noopener">https://portal.azure.com/#blade/Microsoft_AAD_RegisteredApps/ApplicationsListBlade</a>，注册一个新app【使用微软账号】</p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/2020-08-14070907.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>几番跳转后，来到这样的界面：</p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/2020-08-14071032.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><blockquote><p>注意，我们强烈建议用英文界面，中文界面可能存在翻译错误产生误导</p></blockquote><p>点击OneIndex，进入应用详情</p><p>点击 <code>Redirect URIs</code> 修改跳转链接:</p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/2020-08-14071305.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>将此处改为 <code>https://heymind.github.io/tools/microsoft-graph-api-auth</code></p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/2020-08-14071416.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>设置API：</p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/2020-08-14091941.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>至少选择 <code>offline_access, Files.Read, Files.Read.All .</code></p><p>返回，获取 <code>Application (client) ID</code></p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/2020-08-14071558.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>在这里填上复制的client id，并点击AUTHORIZE验证</p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/2020-08-14071904.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>你会发现跳转一段时间后又回到了拉取界面,不过多了一个提示框,上面写着已经获取到Code</p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/2020-08-14072357.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>接着我们获取Secrets,点击 <code>Certificates &amp; secrets</code>,进入该选项卡:</p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/2020-08-14080315.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>新增一个:</p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/2020-08-14080233.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>名字随意,期限为永久:</p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/2020-08-14080315.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>复制生成的密钥,请注意此处密钥仅<strong>出现一次</strong>,以后就不会再出现了</p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/2020-08-14080438.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>将获得密钥粘贴进第五步:</p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/2020-08-14080508.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>点击GetToken,将跳转至如下界面:</p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/2020-08-14080438.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><blockquote><p>此处若失败，请重试第四步</p></blockquote><p>将获得字段的refresh_token写入，重新制得token：</p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/2020-08-14082011.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>取得token：</p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/2020-08-14081337.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>妥善保管，接下来我们会用到。</p><p>OneDriveToken完毕，接下来进入FireBase教程：</p><blockquote><p>作为数据库存储，原本采用的是cloudFlareKV存储，但考虑到大部分用户没有这个钱去买KV，于是采用了第三方存储。</p></blockquote><p>进入<a href="https://firebase.google.com/" target="_blank" rel="noopener">https://firebase.google.com/</a></p><p>开始创建项目：</p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/2020-08-14082334.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>项目名字随意，下一步</p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/2020-08-14082421.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>一直下一步，稍后将进入管理界面</p><p>选择Database，将其设置为发布模式，禁用写入权限，在数据一栏中添加key，名字为<code>value</code>,值为 <code>https://项目名.firebaseio.com/auth.json</code> ，如我的：<br><code>https://oneindex-chenyfan.firebaseio.com/auth.json</code></p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/2020-08-14082523.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>点击右上角的小齿轮-项目设置-服务账号-旧版凭据-数据库账号-显示密钥，复制密钥。</p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/2020-08-14082614.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>FireBase教学完毕。</p><h2 id="配置CloudFlare"><a href="#配置CloudFlare" class="headerlink" title="配置CloudFlare"></a>配置CloudFlare</h2><p>登录你的CloudFlare，点击右上角，账户设置：</p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/2020-08-14083511.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>选择API令牌选项卡，生成新的API：</p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/2020-08-14083707.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>选择自定义令牌：</p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/2020-08-14083741.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>配置至少如下，可以选择增加</p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/2020-08-14083836.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>点击获取API令牌</p><p>接着还要获取账户ID和区域ID</p><p>进入任意一域名，右侧拦里头会有俩ID，复制：</p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/2020-08-14083918.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>到这里，你获取了以下所有密钥：</p><ul><li>Azure-refresh_token</li><li>Azure-client_id</li><li>Azure-client_secret</li><li>GoogleFireBase-firebase_url</li><li>GoogleFireBase-firebase_token</li><li>CloudFlare-APIToken</li><li>CloudFlare-ZoneID</li><li>CloudFlare-AccountID</li></ul><p>八个Token，切勿丢失<img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/%E5%92%BD%E6%B0%94.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt> 累死我了</p><h2 id="配置OneDrive"><a href="#配置OneDrive" class="headerlink" title="配置OneDrive"></a>配置OneDrive</h2><p>用微软账户登录OneDrive，新建文件夹，名字为“Public”</p><h2 id="本地wrangler部署"><a href="#本地wrangler部署" class="headerlink" title="本地wrangler部署"></a>本地wrangler部署</h2><blockquote><p>由于此篇教程具体将GithubAction实现无服务器部署，本块内容一笔带过，请直接看到GithubAction部署一块</p></blockquote><p>本地安装依赖环境</p><div class="hljs"><pre><code class="hljs undefined">yarn <span class="hljs-keyword">global</span> <span class="hljs-keyword">add</span> <span class="hljs-title">@cloudflare</span>/wrangleryarn install</code></pre></div><p>用wrangler登录CloudFlare</p><div class="hljs"><pre><code class="hljs undefined">wrangler <span class="hljs-built_in">config</span></code></pre></div><p><code>wrangler.toml</code>  修改</p><div class="hljs"><pre><code class="hljs undefined">name: The draft worker<span class="hljs-comment">'s name, your worker will be published at <span class="hljs-doctag">&lt;name&gt;</span>.<span class="hljs-doctag">&lt;worker_subdomain&gt;</span>.workers.dev.</span>account_id: Your Cloudflare Account ID.zone_id: Your Cloudflare Zone ID.</code></pre></div><p><code>src/config/default.js</code> 修改:</p><div class="hljs"><pre><code class="hljs undefined">client_id: Your client_id <span class="hljs-keyword">from</span> <span class="hljs-keyword">above</span>.base: Your base path <span class="hljs-keyword">from</span> <span class="hljs-keyword">above</span>.firebase_url: Your firebase_url <span class="hljs-keyword">from</span> <span class="hljs-keyword">above</span>.</code></pre></div><p>添加环境变量:</p><div class="hljs"><pre><code class="hljs undefined">wrangler<span class="hljs-built_in"> secret </span>put REFRESH_TOKENwrangler<span class="hljs-built_in"> secret </span>put CLIENT_SECRETwrangler<span class="hljs-built_in"> secret </span>put FIREBASE_TOKEN</code></pre></div><p>部署命令:</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attribute">wrangler publish</span></code></pre></div><h2 id="GithubAction部署"><a href="#GithubAction部署" class="headerlink" title="GithubAction部署"></a>GithubAction部署</h2><h3 id="GithubAction部署-1"><a href="#GithubAction部署-1" class="headerlink" title="GithubAction部署"></a>GithubAction部署</h3><p>进入你导入的仓库，点击 <code>wrangler.toml</code> </p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/2020-08-14084906.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><ul><li><code>name</code> ==&gt; 默认生成为&lt;#name&gt;.&lt;#User&gt;.workers.dev，随意</li><li><code>account_id</code> ==&gt; CloudFlare-AccountID</li><li><code>zone_id</code> ==&gt; CloudFlare-ZoneID</li></ul><p>进入<code>/src/config/default.js</code></p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/2020-08-14085133.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><ul><li>refresh_token ==&gt; Azure-refresh_token</li><li>client_id ==&gt; Azure-client_id</li><li>client_secret ==&gt; Azure-client_secret</li><li>redirect_uri ==&gt; ‘<a href="https://heymind.github.io/tools/microsoft-graph-api-auth&#39;" target="_blank" rel="noopener">https://heymind.github.io/tools/microsoft-graph-api-auth&#39;</a></li><li>firebase_url ==&gt; GoogleFireBase-firebase_url</li></ul><h4 id="修改样式"><a href="#修改样式" class="headerlink" title="修改样式"></a>修改样式</h4><p><code>src/render/htmlWrapper.js</code> : 修改标题</p><p><code>src/folderView.js</code> : 修改介绍</p><h4 id="设置密钥"><a href="#设置密钥" class="headerlink" title="设置密钥"></a>设置密钥</h4><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/2020-08-14092907.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>密钥名：<code>CF_API_TOKEN</code></p><p>内容: ==&gt; CloudFlare-APIToken</p><h4 id="激活Action："><a href="#激活Action：" class="headerlink" title="激活Action："></a>激活Action：</h4><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/2020-08-14085647.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><h3 id="设置CloudFlare变量"><a href="#设置CloudFlare变量" class="headerlink" title="设置CloudFlare变量"></a>设置CloudFlare变量</h3><p>进入新创建的Worker：</p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/2020-08-14090207.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/2020-08-14090302.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><ul><li>CLIENT_SECRET ==&gt; Azure-client_secret</li><li>FIREBASE_TOKEN ==&gt; GoogleFireBase-firebase_token</li><li>REFRESH_TOKEN ==&gt; Azure-refresh_token</li></ul><p>部署，发布，绑定域名【可选】：</p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/2020-08-14090933.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>成品：</p><p><img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/2020-08-14091129.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>Demo:<a href="https://onedrive.cyfan.top" target="_blank" rel="noopener">https://onedrive.cyfan.top</a> <img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/huaji.gif" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><h1 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h1><p>其实默认才5GB，还不如GoogleDrive香，但是据说白嫖E5开发者还不错。</p><p>OK就到这了，还不懂的欢迎评论区，或者去官方github地址发issues。<img src="https://rmt.dogedoge.com/fetch/hi-c-oss/storage/%E6%AC%A2%E5%91%BC.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;写在最前面&lt;/strong&gt;&lt;br&gt;自从这篇博文发布后，OneIndex迎来了一次重大更新，去除了FireBase依赖，转用KV存储刷新令牌。本片教程已过时，具体会在春节前后更新最新版本。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="撸羊毛" scheme="https://blog.cyfan.top/categories/撸羊毛/"/>
    
    
    <category term="CloudFlare" scheme="https://blog.cyfan.top/tags/CloudFlare/"/>
    
    <category term="Workers" scheme="https://blog.cyfan.top/tags/Workers/"/>
    
    <category term="目录列表" scheme="https://blog.cyfan.top/tags/目录列表/"/>
    
  </entry>
  
  <entry>
    <title>打造一个可国内访问的Blogger（Blogspot）方法</title>
    <link href="https://blog.cyfan.top/p/620f3e8d.html"/>
    <id>https://blog.cyfan.top/p/620f3e8d.html</id>
    <published>2020-07-29T02:43:19.000Z</published>
    <updated>2022-01-16T12:23:54.551Z</updated>
    
    <content type="html"><![CDATA[<p>Blog‍‌‍‌​‌‌‌‌​‌​‍‌​‍‌‍‍​‌‌‍‌​‌‍​‍‌​​‍‌‌‌​‌‍‌‌​‍‍‍​‍‍‌​​‍‌‍‌​‍‌‍‍​‌‌‍‌​‌‍​‍‌​​‍​‍‍‍​‌‍‍‌ger,一个干爽、免费的博客发布平台，作为主流的发布，提供免费的托管，免去了Typecho&amp;Wordpress高昂的服务器费用，避免了Hexo&amp;Jekyll静态博客无后台的缺陷，与CSDN、简书相比，可以绑定域名，界面干净，无广告【当然可以自己放自己的广告】。</p><p>实际上，当今写博客的软件数不胜数，主要分为一下三类：</p><ul><li>服务器部署：典型代表：Wordpress\Typecho</li><li>无服务器托管：典型代表：Hexo\Jekyll\Gidea\Hugo\Hola等等</li><li>集成型网站：Blogger、简书、CSDN、cnblog、wodemo等等</li></ul><p>上面所有软件，优缺点都有，具体看个人选择</p><p>当然，个人认为Typecho适合做个人博客，Hexo可以作为要求不高的人。集成性网站最主要的是只要安安心心写文章，不用管后端乱七八糟的代码。当然，最有问题的是大多数都不支持绑定域名，而且经常往网站上塞广告，自定义范围也不够。</p><p>接下来，我们扯扯集成博客中的一股清流：Blogger</p><blockquote><p>Blogger.com是由Pyra Labs公司创立，是目前全球用户数量最多的个人网志服务提供商。Pyra Labs和Blogger.com均被Google公司收购，成为其旗下的一项服务内容。<br>Blogger提供免费主机Blogspot.com存放博客，用户不必写任何代码或者安装服务器软件或脚本，通过所见即所得界面轻松地创建、发布、维护和修改自己的网志。<br>Blogger允许有经验的用户自行设计博客界面，其模板支持使用HTML和CSS进行编辑</p></blockquote><p><img src="https://npm.elemecdn.com/chenyfan-oss@1.0.1/2020-07-29%20084428.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>实际上，由于Blogger托管于谷歌，写作域名 <code>www.blogger.com</code> 和托管域名 <code>*.blogspot.com</code> 均被MainLand所Ban。但是接下来来，我会讲讲如何打造一个能在国内大陆访问的Blogger</p><h1 id="1-注册Blogger"><a href="#1-注册Blogger" class="headerlink" title="1. 注册Blogger"></a>1. 注册Blogger</h1><blockquote><p>众所周知，请善用技术上网。</p></blockquote><p>用谷歌账号登录 (<a href="https://www.blogger.com" target="_blank" rel="noopener">https://www.blogger.com</a>) ，没有？不是⑧不是吧不是扒，都0202年了，还不会去注册一个谷歌账号？</p><p>进入控制台，新建一个博客：</p><p><img src="https://npm.elemecdn.com/chenyfan-oss@1.0.1/2020-07-29%20084652.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>绑定域名,这一步随意,因为我们还要绑定一个自定义域名.</p><p><img src="https://npm.elemecdn.com/chenyfan-oss@1.0.1/2020-07-29%20084847.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>点击确定,一个博客就搭建好了!快吧?</p><p><img src="https://npm.elemecdn.com/chenyfan-oss@1.0.1/2020-07-29%20085021.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>这时候,我们<strong>善用技术上网</strong>访问之前的域名,我这里是: <code>cyfblogger.blogspot.com</code>，打开：</p><p><img src="https://npm.elemecdn.com/chenyfan-oss@1.0.1/2020-07-29%20085021.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>搞定！搞完之后才知道，Blogger真正做到了什么叫1分钟创建一个博客，但这还不够，中国访客实际上还是打不开这个网站<a href="大多被污染到莫名其妙的ip去了,例如Facebook和Twitter">1</a>。所以，接下来，我们要让这个网站能在中国访问。</p><p>目前我们有一下思路:</p><ul><li>选择一个未被官方屏蔽的Blogger节点,此方法几年前还是可用的,最近不大灵光了,被屏蔽的差不多了</li><li>使用服务器反向代理Blogger,不推荐,有这个闲工夫你还不如直接用Typecho呢</li><li>CloudFlareCDN反向代理,这似乎是唯一一个解决的办法.</li></ul><h1 id="2-绑定自定义域名"><a href="#2-绑定自定义域名" class="headerlink" title="2.绑定自定义域名"></a>2.绑定自定义域名</h1><p>由于 <code>*.blogspot.com</code> 泛域名被屏蔽,所以你必须要有一个自己的域名.</p><p>不推荐免费域名，因为免费域名无法自选CF节点，当然你也可以换别的方式。</p><p>这里推荐一个买域名的好网站：<code>https://namebeta.com/</code> namebeta并不是购买域名的地方,但是它可以帮你货比三家,让你跳出更优惠的方案,并且自带各种温馨提示,包括能不能备案,有没有被注册等等,比较适合刚入门想买域名的小白.</p><p><img src="https://npm.elemecdn.com/chenyfan-oss@1.0.1/2020-07-29%20090113.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>购买绑定NS不在谈论范围内,有域名的看下去</p><p>以下演示方便在CloudFlare官网里进行,采用免费域名演示,实际用笨牛CNAME解析为好.</p><p><img src="https://npm.elemecdn.com/chenyfan-oss@1.0.1/2020-07-29%20091514.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>点击【设置】-【正在发布】-【自定义域名】</p><p>接着会报错：</p><p><img src="https://npm.elemecdn.com/chenyfan-oss@1.0.1/2020-07-29%20092548.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>提示没验证，没关系，去CloudFlare加上CNAME，注意验证过程中切记把橙色云朵点灰<a href="实际上下面那条记录是为了验证你有没有主域名控制权。">2</a>：</p><p><img src="https://npm.elemecdn.com/chenyfan-oss@1.0.1/2020-07-29%20092736.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>回去，点击确定，勾选HTTPS可用性。</p><p>谷歌SSL验证和办法真的慢，没办法，喝杯茶，写点作业，过了10min，显示颁发成功：</p><p><img src="https://npm.elemecdn.com/chenyfan-oss@1.0.1/2020-07-29%20093118.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>回到CloudFlare，把访客访问的那条记录点亮橙色云朵，作为验证的记录不点亮.</p><p>国内访问试试？</p><p><img src="https://npm.elemecdn.com/chenyfan-oss@1.0.1/2020-07-29%20094026.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>这时候我们发现，虽然国内能直连了，但是背景图加载不出来，整个网页加载缓慢。控制台以下，我们就会发现，Blogspot请求了国外谷歌边缘节点的内容，包括背景图片和部分js。</p><p>所以，我们还要对博客主题进行加工。</p><h1 id="3-更改主题"><a href="#3-更改主题" class="headerlink" title="3.更改主题"></a>3.更改主题</h1><blockquote><p>演示方便，用Contempo Light主题<br>实际上用其它主题也差不多的，注意替换掉外链即可</p></blockquote><p><img src="https://npm.elemecdn.com/chenyfan-oss@1.0.1/2020-07-29%20094333.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>点击备份，下载主题:</p><p>用Notepad++打开，方便处理</p><h2 id="屏蔽加载"><a href="#屏蔽加载" class="headerlink" title="屏蔽加载"></a>屏蔽加载</h2><p>将<code>&lt;head&gt;</code>替换为<code>&amp;lt;!--&lt;head&gt;--&amp;gt;&amp;lt;head&amp;gt;</code></p><p>将<code>&lt;/head&gt;</code>替换为<code>&amp;lt;/head&amp;gt;&amp;lt;!--&lt;/head&gt;--&amp;gt;</code></p><p>将<code>&lt;/body&gt;</code>替换为<code>&amp;lt;!--&lt;/body&gt;--&amp;gt;&amp;lt;/body&amp;gt;</code></p><h2 id="替换背景"><a href="#替换背景" class="headerlink" title="替换背景"></a>替换背景</h2><p>在49行左右，有这么一段代码：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Variable</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"body.background"</span> <span class="hljs-attr">description</span>=<span class="hljs-string">"Background"</span>      <span class="hljs-attr">color</span>=<span class="hljs-string">"$(body.background.color)"</span>      <span class="hljs-attr">type</span>=<span class="hljs-string">"background"</span>      <span class="hljs-attr">default</span>=<span class="hljs-string">"$(color) none repeat scroll top left"</span>  <span class="hljs-attr">value</span>=<span class="hljs-string">"$(color) url(https://themes.googleusercontent.com/image?id=L1lcAxxz0CLgsDzixEprHJ2F38TyEjCyE3RSAjynQDks0lT1BDc1OxXKaTEdLc89HPvdB11X9FDw) no-repeat scroll top center /* Credit: Michael Elkan (http://www.offset.com/photos/394244) */;"</span>/&gt;</span></code></pre></div><p>将其中的</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-symbol">https:</span><span class="hljs-comment">//themes.googleusercontent.com/image?id=L1lcAxxz0CLgsDzixEprHJ2F38TyEjCyE3RSAjynQDks0lT1BDc1OxXKaTEdLc89HPvdB11X9FDw</span></code></pre></div><p>替换为背景外链.</p><h2 id="必要的JS替换"><a href="#必要的JS替换" class="headerlink" title="必要的JS替换"></a>必要的JS替换</h2><p>打开F12,我们会发现,有一个资源阻塞了请求:</p><p><code>https://resources.blogblog.com/blogblog/data/res/2629068285-indie_compiled.js</code></p><p>但这个是必须的,我们要保留,搜索 <code>&lt;b:template-script async=&#39;true&#39; name=&#39;indie&#39; version=&#39;1.0.0&#39;/&gt;</code> 并删除,将其替换成:<br><code>&lt;script async=&#39;async&#39; src=&#39;https://cdn.jsdelivr.net/gh/chenyfan/chenyfan.github.io/1468123664-indie_compiled.js&#39;&gt;&lt;/script&gt;</code></p><blockquote><p>当然你也可以用自己的链接.</p></blockquote><h2 id="解决缩略图问题"><a href="#解决缩略图问题" class="headerlink" title="解决缩略图问题"></a>解决缩略图问题</h2><p>【感谢阿虚同学的博客解决此方法】</p><p>将 此JS 代码放置于  标签前：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">b:if</span> <span class="hljs-attr">cond</span>=<span class="hljs-string">'data:blog.pageType in &#123;"index","searchQuery","searchLabel","archive"&#125;'</span>&gt;</span> <span class="hljs-comment">&lt;!--如果当前页是首页，搜索页，标签页，那么代码继续执行--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">defer</span>=<span class="hljs-string">'defer'</span>&gt;</span><span class="javascript">        <span class="hljs-comment">//&lt;![CDATA[</span>        <span class="hljs-keyword">var</span> postThumbnails = <span class="hljs-built_in">document</span>.getElementsByClassName(<span class="hljs-string">"post-thumbnail"</span>);        <span class="hljs-keyword">var</span> postContents = <span class="hljs-built_in">document</span>.getElementsByClassName(<span class="hljs-string">"post-text"</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;postContents.length;i++)        &#123;            <span class="hljs-keyword">var</span> postContent = postContents[i].innerText;            <span class="hljs-keyword">var</span> imgReg = <span class="hljs-regexp">/&lt;img.*?(?:&gt;|\/&gt;)/gi</span>;            <span class="hljs-keyword">var</span> srcReg = <span class="hljs-regexp">/src=[\'\"]?([^\'\"]*)[\'\"]?/i</span>;            <span class="hljs-keyword">var</span> imgTags = postContent.match(imgReg);            imgSrcs = imgTags[<span class="hljs-number">0</span>].match(srcReg);            imgSrc = imgSrcs[<span class="hljs-number">1</span>];            postThumbnails[i].setAttribute(<span class="hljs-string">'src'</span>, imgSrc);        &#125;        <span class="hljs-comment">//]]&gt;</span>    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">b:if</span>&gt;</span></code></pre></div><p>修改模板，搜索data:post.featuredImage，在缩略图处改成下代码：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">b:if</span> <span class="hljs-attr">cond</span>=<span class="hljs-string">'data:post.featuredImage'</span>&gt;</span>  <span class="hljs-comment">&lt;!--判断文章内是否有图片，有则代码继续执行--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">'snippet-thumbnail'</span>&gt;</span>  <span class="hljs-comment">&lt;!--创建一个 div 容器，缩略图放置在这里--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">class</span>=<span class="hljs-string">'post-thumbnail'</span> <span class="hljs-attr">sizes</span>=<span class="hljs-string">'(max-width: 800px) 20vw, 128px'</span> <span class="hljs-attr">src</span>=<span class="hljs-string">'https://ae01.alicdn.com/kf/HTB1Gb7LUmzqK1RjSZFL5jcn2XXac.gif'</span>/&gt;</span>  <span class="hljs-comment">&lt;!--预先放置一个加载图片，增强用户体验--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">class</span>=<span class="hljs-string">'post-text'</span> <span class="hljs-attr">style</span>=<span class="hljs-string">'display:none;'</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">data:post.body.escaped</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span> <span class="hljs-comment">&lt;!--这里放置文章全文，图片从中提取，样式设置为不显示--&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">b:if</span>&gt;</span></code></pre></div><h2 id="头像、icon设置"><a href="#头像、icon设置" class="headerlink" title="头像、icon设置"></a>头像、icon设置</h2><p>搜索 <code>profile-img</code> 约3899行：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">class</span>=<span class="hljs-string">'profile-img'</span> <span class="hljs-attr">expr:alt</span>=<span class="hljs-string">'data:messages.myPhoto'</span> <span class="hljs-attr">expr:height</span>=<span class="hljs-string">'data:authorPhoto.height'</span> <span class="hljs-attr">expr:src</span>=<span class="hljs-string">'data:authorPhoto.image'</span> <span class="hljs-attr">expr:width</span>=<span class="hljs-string">'data:authorPhoto.width'</span>/&gt;</span></code></pre></div><p>将其直接改成</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">class</span>=<span class="hljs-string">'profile-img'</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"你的头像外链地址"</span>&gt;</span></code></pre></div><h2 id="字体问题"><a href="#字体问题" class="headerlink" title="字体问题"></a>字体问题</h2><p>我测试时没有发现字体相关问题，请求字体的网址gstatic.com在国内可以访问，虽然部分地区莫名其妙解析到澳大利亚facebook，但大多数都正确解析时国内谷翔。</p><h2 id="评论问题"><a href="#评论问题" class="headerlink" title="评论问题"></a>评论问题</h2><p>默认的Google评论肯定时不行的，留着还拖慢加载，推荐用DiqusJS或Valine.</p><p>修改主题，搜索 <code>&lt;b:includable id=&#39;comments&#39; var=&#39;post&#39;&gt;</code> 约3453行至 <code>&lt;/b:includable&gt;</code> 3511行,全部删除,将以下代码填写回原处</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-tag">&lt;<span class="hljs-name">b:includable</span> <span class="hljs-attr">id</span>=<span class="hljs-string">'comments'</span> <span class="hljs-attr">var</span>=<span class="hljs-string">'post'</span>&gt;</span>                      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">'disqus_thread'</span>/&gt;</span>                      <span class="hljs-tag">&lt;/<span class="hljs-name">b:includable</span>&gt;</span></code></pre></div><p>在末端 <code>&amp;lt;!--&lt;/body&gt;--&amp;gt;&amp;lt;/body&amp;gt;</code> 前添加:</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript"><span class="hljs-keyword">var</span> dsqjs = <span class="hljs-keyword">new</span> DisqusJS(&#123;    shortname: <span class="hljs-string">''</span>,    siteName: <span class="hljs-string">''</span>,    identifier: <span class="hljs-string">''</span>,    url: <span class="hljs-string">''</span>,    title: <span class="hljs-string">''</span>,    api: <span class="hljs-string">''</span>,    apikey: <span class="hljs-string">''</span>,    admin: <span class="hljs-string">''</span>,    adminLabel: <span class="hljs-string">''</span>&#125;);</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p>以上代码具体配置前往  [<a href="https://github.com/SukkaW/DisqusJS#%E4%BD%BF%E7%94%A8" target="_blank" rel="noopener">https://github.com/SukkaW/DisqusJS#%E4%BD%BF%E7%94%A8</a> ] 配置</p><p>完</p><p>Demo&amp;&amp;以后的日记本:[<a href="https://moe.cyfan.top" target="_blank" rel="noopener">https://moe.cyfan.top</a> ]</p><hr><p>推荐自选CDN加速.</p><p>注意以后写文章图片必须是外链,可以试试sm.ms</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Blog‍‌‍‌​‌‌‌‌​‌​‍‌​‍‌‍‍​‌‌‍‌​‌‍​‍‌​​‍‌‌‌​‌‍‌‌​‍‍‍​‍‍‌​​‍‌‍‌​‍‌‍‍​‌‌‍‌​‌‍​‍‌​​‍​‍‍‍​‌‍‍‌ger,一个干爽、免费的博客发布平台，作为主流的发布，提供免费的托管，免去了Typecho&amp;amp;</summary>
      
    
    
    
    <category term="好方法" scheme="https://blog.cyfan.top/categories/好方法/"/>
    
    
    <category term="Blogger" scheme="https://blog.cyfan.top/tags/Blogger/"/>
    
    <category term="Blogspot" scheme="https://blog.cyfan.top/tags/Blogspot/"/>
    
    <category term="谷歌" scheme="https://blog.cyfan.top/tags/谷歌/"/>
    
    <category term="博客" scheme="https://blog.cyfan.top/tags/博客/"/>
    
  </entry>
  
  <entry>
    <title>白嫖！10GB免流海外BackBlaze对象存储【可套CDN】</title>
    <link href="https://blog.cyfan.top/p/ce240368.html"/>
    <id>https://blog.cyfan.top/p/ce240368.html</id>
    <published>2020-07-09T01:37:00.000Z</published>
    <updated>2022-01-16T12:23:54.551Z</updated>
    
    <content type="html"><![CDATA[<p>腾讯云的COS就是个暗坑，进去的时候大肆宣扬用户前六个月免费，但实际上免费仅针对于存储于国内的bucket，而存储于国外的阶梯定价又极不合理，我的COS在一个月走了流量1.6GB。按照官方定价</p><p><img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/postpic/2020-07-09%20094557.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p><img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/postpic/2020-07-09%20094840.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>大概就是0.7左右。</p><p>但是，腾讯云从来就是不满1GB按1GB计算的jier，我瞟了一下账单：</p><p><img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/postpic/2020-07-09%20095520.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>不是吧啊Sir，一个月一块多，那我为什么要用你的东西啊<img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/moji/%E5%90%90.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt>！</p><p>很难让人理解，我CDN设置为一个月的超长缓存，但腾讯还是给我计价1GB，和回源没什么区别。</p><p>后来F12看了一下，腾讯悄悄地在header里添加max-cache为43200s，12个小时强制清除缓存。Asir，赚钱不带这么玩吧。<img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/moji/%E4%B8%AD%E6%9E%AA.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>最让我憋屈的是，<code>cyfan.top</code> 是没有备案的，使用国内的bucket就不给绑定域名，害的我只能用香港，但是香港的绑定域名是不给SSL的，偏要套一层CDN才行。可***腾讯云默认CDN是亚马逊的，速度渣的很，用来用去还是用回CloudFlare。可是，既然有CloudFlare，那我为什么不用免费的Github服务啊！<img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/moji/%E5%93%AD%E6%B3%A3.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>这就是逼着我要换一个图床啊么<img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/moji/qgbf.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt>。</p><p>后来twitter上有人发推推荐 <code>backblaze</code> 的海外存储，使用了一下，发现完全满足需求。<img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/moji/stick_27.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><h1 id="Backblaze"><a href="#Backblaze" class="headerlink" title="Backblaze"></a>Backblaze</h1><p>2015年9月，Backblaze推出了新产品B2 Cloud Storage。作为基础架构即服务（IaaS），它的目标是软件集成（尽管也提供Web前端和API）。它直接与类似服务Amazon S3，Microsoft Azure和Google Cloud竞争。在2018年4月，Backblaze宣布了云计算合作伙伴关系，它将直接将Backblaze的数据中心与其合作伙伴Packet和ServerCentral连接起来，为存储在B2 Cloud Storage中的数据提供高性能的云计算，而无需支付任何费用。</p><p>B2 Cloud Storage非常客气，有以下优点：</p><ul><li>用户永久免费<strong>10GB</strong>直链存储</li><li>每天<strong>1GB</strong>下行流量</li><li>无限量的上传流量</li><li>每天下载请求<strong>2500</strong>次免费</li><li>每天上传请求<strong>2500</strong>次免费</li><li>基于CloudFlareCDN</li></ul><p>而且超出免费额度的价钱也十分合理【不过我不会往里头冲一分钱的！】 <img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/postpic/2020-07-09%20100931.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/postpic/2020-07-09%20100931.jpg"></p><p>然而我偶然得知，Backblaze加入了CloudFlare的 <a href="https://www.cloudflare.com/bandwidth-alliance/" target="_blank" rel="noopener">带宽联盟（ Bandwidth Alliance）</a> Backblaze与CloudFlare之间的流量直接免费，也就是每天<strong>无限量</strong>下行流量，配上CloudFlare超长缓存，每天下载请求无限次免费。<img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/moji/%E5%BE%97%E6%84%8F.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>而且这样与我用COS的速度是差不多的，那我何必用付费的COS呢？</p><h1 id="注册："><a href="#注册：" class="headerlink" title="注册："></a>注册：</h1><p>去<a href="https://www.backblaze.com/zh_CN/cloud-storage.html" target="_blank" rel="noopener">B2 云存储</a>注册，可以用Google快捷登录：</p><p><img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/postpic/2020-07-09%20101845.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>注册之后可能会要求你绑定手机号，乖乖的绑定自己的中国手机号吧【可能会产生短信费用，大概0.1￥】，不要想什么歪门邪道<br>，毕竟很多公开的手机号是不能用的，而且GoogleVoice也被拒绝了。</p><p>新建一个桶，设置为公开：</p><p>上传一个文件，点击右边的信息按钮，我们要在这里获取一些信息：</p><p><img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/postpic/2020-07-09%20102255.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p><img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/postpic/2020-07-09%20102940.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>看到那个友好链接吗，这就是CloudFlare加速的链接，但这个不是我们想要的链接，我们要自定义域名，毕竟默认的加速相当蛋疼。</p><h1 id="自定义域名"><a href="#自定义域名" class="headerlink" title="自定义域名"></a>自定义域名</h1><p>这一步需要你有个域名，开个子域给图床：</p><p>由于我是bnxb接入的CloudFlare，所以我首先要去 <code>cdn.bnxb.com</code> ，将 <code>assets.cyfan.top</code> 指向 <code>f000.backblazeb2.com</code> 【每个人都可能不一样，自己看情况】，并开启CDN，然后在DNSPOD里CNAME负载均衡一下，这里就不放图了。<img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/moji/%E6%9C%9F%E5%BE%85.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><h1 id="缩短链接"><a href="#缩短链接" class="headerlink" title="缩短链接"></a>缩短链接</h1><p>默认即使绑定域名后，链接大概是这样滴：</p><div class="hljs"><pre><code class="hljs undefined">https:<span class="hljs-regexp">//</span>assets.cyfan.top<span class="hljs-regexp">/file/</span>CYF-PicBed<span class="hljs-regexp">/pic/</span>postpic<span class="hljs-regexp">/2020-07-09%20102255.jpg</span></code></pre></div><p>可以看到,中间多了 <code>/file/CYF-PicBed/</code> ,这并不是我所需要的,所以我们要把它变成这样:</p><div class="hljs"><pre><code class="hljs undefined">https:<span class="hljs-regexp">//img</span>.cyfan.top<span class="hljs-regexp">/pic/</span>postpic<span class="hljs-regexp">/2020-07-09%20102255.jpg</span></code></pre></div><p>你要知道，我有一大堆图片都是直接以 <code>https://img.cyfan.top</code> 存在底下的，NotePad++可以批量改，但是我在外链也放了很多啊.所以只能改域名。<img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/moji/%E5%90%90%E8%A1%80%E5%80%92%E5%9C%B0.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>前往CloudFlare,设置页面规则,进行301转发:</p><p><img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/postpic/2020-07-09%20103634.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>其中 <code>$1</code> 是CloudFlare的匹配符号，此规则意思是将所有的 <code>https://img.cyfan.top/*</code> 跳转向 <code>https://assets.cyfan.top/file/CYF-PicBed/*</code> </p><p>去 <code>cdn.bnxb.com</code> ，将 <code>img.cyfan.top</code> 指向 任意一ip,比如 <code>1.0.0.1</code> 并开启CDN，然后在DNSPOD里CNAME。</p><p>此后,所有访问图片都会在里头跳转一下,外面基本看不出来有什么差别.</p><p><img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/postpic/2020-07-09%20104238.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><h1 id="开启CORS-加长缓存时间"><a href="#开启CORS-加长缓存时间" class="headerlink" title="开启CORS|加长缓存时间"></a>开启CORS|加长缓存时间</h1><p>就这样结束了么？没有，你会发现访问的链接里所有的资源都是MISS，这是因为Backblaze默认不缓存<img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/moji/stick_65.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt>。</p><p>所以，自己设置呗！</p><p>点击桶，进入桶设定：</p><p><img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/postpic/2020-07-09%20104802.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>里头写上:</p><div class="hljs"><pre><code class="hljs undefined">&#123;<span class="hljs-attr">"cache-control"</span>:<span class="hljs-string">"max-age=43200000"</span>&#125;</code></pre></div><p>这个意思是强制缓存 <code>43200000</code> ,大约是50天.然而这里注意一下，时间太长有个问题，你修改一张图片，外面可以能要50天才能更改，这样只能通过手动清除缓存做到了。</p><p>点击CORS设置,选择:</p><div class="hljs"><pre><code class="hljs undefined">与所有HTTPS来源共享此存储桶中的所有内容。</code></pre></div><p>即可.</p><h1 id="实测"><a href="#实测" class="headerlink" title="实测"></a>实测</h1><p><img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/postpic/2020-07-09%20105402.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>免费额度基本用不完.</p><p>可惜PicGo没有支持Backblaze，我只能通过网页端上传<img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/moji/%E8%A3%85%E5%A4%A7%E6%AC%BE.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt>。</p><p>然而有一件事情非常蛋疼，你丫的根目录上传的时候是不会创建文件夹的，一次上传会把文件夹里的图片全部上传到根目录。所以，我只能手动创建文件夹，这个痛苦我真的是，<img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/moji/tx.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt>。</p><p>嗯，用了一个晚上，感觉还是挺香的，鹅厂的COS收费确实不合理，也要学学外面人家收费啊！</p><hr><p>溜了溜了，作业还没写完呢<img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/moji/%E9%82%AA%E9%AD%85%E4%B8%80%E7%AC%91.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;腾讯云的COS就是个暗坑，进去的时候大肆宣扬用户前六个月免费，但实际上免费仅针对于存储于国内的bucket，而存储于国外的阶梯定价又极不合理，我的COS在一个月走了流量1.6GB。按照官方定价&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://npm.elemecdn.co</summary>
      
    
    
    
    <category term="爱分享" scheme="https://blog.cyfan.top/categories/爱分享/"/>
    
    
    <category term="图床" scheme="https://blog.cyfan.top/tags/图床/"/>
    
    <category term="COS" scheme="https://blog.cyfan.top/tags/COS/"/>
    
    <category term="对象存储" scheme="https://blog.cyfan.top/tags/对象存储/"/>
    
    <category term="免流" scheme="https://blog.cyfan.top/tags/免流/"/>
    
  </entry>
  
  <entry>
    <title>怎么才能让GoogleAdsense不拖慢速度</title>
    <link href="https://blog.cyfan.top/p/3854592e.html"/>
    <id>https://blog.cyfan.top/p/3854592e.html</id>
    <published>2020-07-06T06:19:00.000Z</published>
    <updated>2022-01-16T12:23:54.551Z</updated>
    
    <content type="html"><![CDATA[<p>GoogleAdsense嘛，著名的赚钱大师，<span class="heimu">虽然只给我40美分，但毕竟我没有做很好的优化嘛，这也不怪谷歌</span>。由于以前用的是 <code>.ga</code> 的免费域名,在上一年将近4个月荒凉,基本日PV在没有和1之间徘徊.后来过年的时候买了一个 <code>.top</code> 总算撑起一层牌面,但是由于 <code>COVID19</code> ,嗯,所以每次提交2星期就给我来这么一出:</p><p><img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/postpic/20200706143949.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>嗯,<img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/moji/%E5%8F%A3%E5%90%90%E8%8A%B3%E8%A8%80.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>后来呢,六月初提交了一次,结果显示,到第13天,百度统计才接收到来自台湾的Google流量,一天之后审核完毕.</p><p>真的懒啊， <img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/moji/stick_60.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>然而呢，GoogleAdsense也是著名的拖慢加载速度的JS。一年前的GoogleAdsense的js获取是链接美国，谷歌嘛，连不上也是正常的，现在基本解析都是上海和北京的谷翔，速度还行，但是加载广告的速度依旧难以忍受【实际也就6s的速度】。</p><p>欸，博客快满一周年了，当时建站的时候根本不管速度如何，能加载就成，不像现在，为了几百毫秒的事情纠结。<img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/moji/%E5%B0%8F%E7%9C%BC%E7%9D%9B.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><h1 id="GoogleAdsense在后台偷偷加载的事情："><a href="#GoogleAdsense在后台偷偷加载的事情：" class="headerlink" title="GoogleAdsense在后台偷偷加载的事情："></a>GoogleAdsense在后台偷偷加载的事情：</h1><p><img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/postpic/20200706154324.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>可以看到，一个1.1kb的网页（上面的文字是通过js自动生成的），谷歌广告加载，需要将近10s加载完毕，加载大小将近1.5MB。</p><p>最夸张的是，我是通过海外代理访问的，如果放在大陆打开，这甚至好几次加载失败。</p><p>虽然谷歌拥有所谓的【异步加载】，可仍然会严重拖慢速度,并且，当用户没有打算看广告时，广告仍然会加载：</p><p><img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/postpic/20200706154831.gif" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>简单统计了一下，我打开网页用了1s，剩下9s我的浏览器上方一直在转【表示加载】，这种情况非常的讽刺，因为谷歌在PageSpeedLight中口口声声说需要降低js的渲染速度和外部链接加载。</p><p>实际上呢，刚刚的广告，谷歌向服务器发送了57次请求，其中26次js加载，总渲染达到3.87秒，接着是图片，总共将近9个，总大小1.4MB。</p><p>这种地步，已经让我无法忍耐了，可以想象，在打开博客，最开始跳出来的不是博文的内容，而是毫不相关的广告，这种情况，访客好感度能好才怪呢。<img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/moji/%E5%86%85%E4%BC%A4.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>那么，怎么解决？</p><h1 id="万物皆可懒加载！"><a href="#万物皆可懒加载！" class="headerlink" title="万物皆可懒加载！"></a>万物皆可懒加载！</h1><p><img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/postpic/20200706155515.gif" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>访客在上方浏览时，广告不加载，直到划到最底下，广告才开始加载，这样大大提升好感【虽然总加载速度和时间还是这个样，但是在访客看来就很舒服】</p><p>应该给广告挑个好位置，那么在哪里最好呢？就我个人而言，我最希望看完博文和评论之后，在移动鼠标到下一篇的间隙稍微看看别的东西。就比如说那种3.3￥/月的主机广告我就忍不住想点一下【当然，发布者是不能点击自己的广告的】。那么，我就可以把广告代码扔在Valine评论框以下即可。</p><p>我们可以顺手拿一个谷歌广告实例开刀,我的博客广告单元是这样的;</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">async</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ins</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"adsbygoogle"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"display:block"</span> <span class="hljs-attr">data-ad-client</span>=<span class="hljs-string">"ca-pub-1878991317600808"</span> <span class="hljs-attr">data-ad-slot</span>=<span class="hljs-string">"6517667779"</span> <span class="hljs-attr">data-ad-format</span>=<span class="hljs-string">"auto"</span> <span class="hljs-attr">data-full-width-responsive</span>=<span class="hljs-string">"true"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ins</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">     (adsbygoogle = <span class="hljs-built_in">window</span>.adsbygoogle || []).push(&#123;&#125;);</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p>可以看到 <code>https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js</code> 即核心js,那么我们只要把这个js压住懒加载,直到划到底下才显示即可</p><p>那么问题来了,怎么压?</p><p>答: <code>window.addEventListener</code></p><div class="hljs"><pre><code class="hljs undefined"> <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">downloadJSAtOnload</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">var</span> element = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"script"</span>);element.src = <span class="hljs-string">"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"</span>;<span class="hljs-built_in">document</span>.body.appendChild(element);&#125;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.addEventListener)<span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">"load"</span>, downloadJSAtOnload, <span class="hljs-literal">false</span>);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.attachEvent)<span class="hljs-built_in">window</span>.attachEvent(<span class="hljs-string">"onload"</span>, downloadJSAtOnload);<span class="hljs-keyword">else</span> <span class="hljs-built_in">window</span>.onload = downloadJSAtOnload;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p>所以,简单的就这么做:</p><p>修改  <code>Valine.ejs</code> ，末端填上</p><div class="hljs"><pre><code class="hljs html"> <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">downloadJSAtOnload</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">var</span> element = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"script"</span>);element.src = <span class="hljs-string">"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"</span>;<span class="hljs-built_in">document</span>.body.appendChild(element);&#125;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.addEventListener)<span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">"load"</span>, downloadJSAtOnload, <span class="hljs-literal">false</span>);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.attachEvent)<span class="hljs-built_in">window</span>.attachEvent(<span class="hljs-string">"onload"</span>, downloadJSAtOnload);<span class="hljs-keyword">else</span> <span class="hljs-built_in">window</span>.onload = downloadJSAtOnload;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-comment">&lt;!-- ADs-in-Blog-Under-Valine --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ins</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"adsbygoogle"</span>     <span class="hljs-attr">style</span>=<span class="hljs-string">"display:block"</span>     <span class="hljs-attr">data-ad-client</span>=<span class="hljs-string">"ca-pub-1878991317600808"</span>     <span class="hljs-attr">data-ad-slot</span>=<span class="hljs-string">"6517667779"</span>     <span class="hljs-attr">data-ad-format</span>=<span class="hljs-string">"auto"</span>     <span class="hljs-attr">data-full-width-responsive</span>=<span class="hljs-string">"true"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ins</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">     (adsbygoogle = <span class="hljs-built_in">window</span>.adsbygoogle || []).push(&#123;&#125;);</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p><img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/postpic/20200706163849.gif" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>就比如现在这样【诶呀，顺手捞一把嘛】</p> <script type="text/javascript">function downloadJSAtOnload() {var element = document.createElement("script");element.src = "https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js";document.body.appendChild(element);}if (window.addEventListener)window.addEventListener("load", downloadJSAtOnload, false);else if (window.attachEvent)window.attachEvent("onload", downloadJSAtOnload);else window.onload = downloadJSAtOnload;</script><!-- ADs-in-Blog-Under-Valine --><p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-1878991317600808" data-ad-slot="6517667779" data-ad-format="auto" data-full-width-responsive="true"></ins></p><script>     (adsbygoogle = window.adsbygoogle || []).push({});</script><hr><blockquote><p>好了,我相信很多营销号【如果有】，绝对会把我上面的文章直接抄走。嗯，我非常讨厌营销号，对的，我在这里提前鄙视你们。以下是我关于这件事情的很多想法，如果你就是想简单优化，这就足够了，如果你有兴趣了解，你可以继续：</p></blockquote><h1 id="关于更多的优化"><a href="#关于更多的优化" class="headerlink" title="关于更多的优化"></a>关于更多的优化</h1><p>谷歌论坛上有人提到过，懒加载谷歌广告是否合规，标题是这样的：<strong>Lazy Load Adsense fine with the policies?</strong></p><p><a href="https://support.google.com/adsense/thread/31438569?hl=en" target="_blank" rel="noopener">原文</a>如下：</p><div class="hljs"><pre><code class="hljs undefined">Many have already been asked, but unfortunately they have <span class="hljs-keyword">not</span> received an answer. :-(I <span class="hljs-keyword">like</span> <span class="hljs-keyword">to</span> optimize site speed <span class="hljs-keyword">in</span> the browser, <span class="hljs-keyword">not</span> AMP.My questions are:- <span class="hljs-keyword">Is</span> lazy load <span class="hljs-keyword">for</span> ads below the fold usefull?- <span class="hljs-keyword">Is</span> it fine <span class="hljs-keyword">with</span> the policies? I<span class="hljs-comment">'ve seen some pieces of code to implement it (https://css-tricks.com/lazy-loading-responsive-adsense-ads/, https://betterstudio.com/blog/lazy-load-google-adsense-wordpress/, https://gulshankumar.net/setup-lazy-loading-google-adsense-ad-units/). Are such examples allowed code to implement AdSense lazy loading?</span>Thanks!</code></pre></div><p>噫,好,又是<del>生肉</del>.</p><p>简单的说,这位用户的担忧确实很值得思考,确实,AMP对于我来说就是个鸡肋，尤其是想我一样面向中国大陆访客，<strong>AMP需要你能访问国外谷歌</strong>。担忧的理由也写的很清楚，一是能不能起作用，二是违不违反政策。</p><p>可惜，所谓的QuickResponse依旧很答非所问，印证了用户的 <strong>Many have already been asked, but unfortunately they have not received an answer</strong></p><p>嗯， <strong>it makes sense NOT to have lazy loading on them</strong> 、 <strong>There is no “yes” or “no” answer to this in the policies</strong> ，用户问有没有违反，可你只能回答【没有确切答案？】、【不需要懒加载？】</p><p>这谷歌客服<span class="heimu">一事无成</span>，像极了我的人生</p><p>不过说回来，有一件事情确实意思：</p><div class="hljs"><pre><code class="hljs undefined">As such, it could be argued that behaviour draws attention <span class="hljs-keyword">to</span> those elements. Drawing attention <span class="hljs-keyword">to</span> ads is a<span class="hljs-built_in"> policy </span>violation.所以，这可以说这种行为吸引了人们对这些要素变化的关注。请注意这种吸引用户关注行为是违反政策。</code></pre></div><p>所以，这就解释了我为何不用 <code>onscroll</code> 和 <code>IntersectionObserver API</code> ,<br>而采用不那么灵敏的 <code>window.addEventListener</code> 。</p><p>实际上，在刚刚的论坛问答里，提到了很多的lazyload方法，以 [<a href="https://css-tricks.com/lazy-loading-responsive-adsense-ads/]" target="_blank" rel="noopener">https://css-tricks.com/lazy-loading-responsive-adsense-ads/]</a> 这篇文章为例子:</p><p><img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/postpic/20200706163646.gif" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>这种方法在谷歌广告商增加一个遮罩层,加载网页时先加载遮罩,广告不加载;当滚动完成时,遮罩层消失,加载广告.可惜，此方法已失效，加载的时候谷歌检测到有遮罩层就会拒绝加载。</p><p>无论怎么说，懒加载广告，速度<del>咻</del>一下上去了，口袋里零花钱也多了。钱速双收，何为不乐乎？</p><p>最后，我瞟了一眼，看到了广告：</p><p><img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/postpic/20200706164523.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>阿里支付宝什么时候沦落到要打广告了？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;GoogleAdsense嘛，著名的赚钱大师，&lt;span class=&quot;heimu&quot;&gt;虽然只给我40美分，但毕竟我没有做很好的优化嘛，这也不怪谷歌&lt;/span&gt;。由于以前用的是 &lt;code&gt;.ga&lt;/code&gt; 的免费域名,在上一年将近4个月荒凉,基本日PV在没有和1之间徘</summary>
      
    
    
    
    <category term="好方法" scheme="https://blog.cyfan.top/categories/好方法/"/>
    
    
    <category term="Google" scheme="https://blog.cyfan.top/tags/Google/"/>
    
    <category term="Adsense" scheme="https://blog.cyfan.top/tags/Adsense/"/>
    
    <category term="LazyLoad" scheme="https://blog.cyfan.top/tags/LazyLoad/"/>
    
    <category term="赚钱" scheme="https://blog.cyfan.top/tags/赚钱/"/>
    
  </entry>
  
  <entry>
    <title>利用Travis-CI实现在线更新Hexo</title>
    <link href="https://blog.cyfan.top/p/e626cb30.html"/>
    <id>https://blog.cyfan.top/p/e626cb30.html</id>
    <published>2020-06-29T05:31:00.000Z</published>
    <updated>2022-01-16T12:23:54.551Z</updated>
    
    <content type="html"><![CDATA[<p>Hexo作为静态博客，好处相当明显，开销少，并且对于那种DDosS和CC套上CDN毅然不动。当然，最蛋疼的莫过于更新了，每次在自己电脑上辛辛苦苦码好字，一个push，hexo绿色光芒在命令提示符上闪烁着光芒，突然发现把仓库名字 <code>ChenYFan</code> 打成 <code>CehnYFan</code> <span class="heimu">真实事件</span> ，异或着是用手机查看自己的博客，突然发现：</p><p><img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/postpic/20200629135012.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p><img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/moji/stick_7.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>由于hexo基于nodejs+git，手机无法更新；同时如果换了台电脑，hexo就要重装。这种事情hexo用户应该体会得到，我也就不多说了。<img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/moji/%E4%B8%AD%E5%88%80.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>那么，hexo用户如何进行在线更新呢？</p><p>正常来讲，<strong>服务器法</strong> 最直接，但也是最没用的。用服务器就意味着丧失了hexo的最优点-节省开支。当然，Hexo+Nginx+HexoAdmin确实可以实现很棒的书写环境，但是与其这么麻烦你还不如直接用Typecho&amp;Wordpress呢。<img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/moji/%E4%B8%8D%E9%AB%98%E5%85%B4.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>曾经在 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo官方</a> 上看过 <a href="https://hexo.io/zh-cn/docs/github-pages" target="_blank" rel="noopener">利用Travis-ci自动部署GithubPages</a> 不过我一看到这么多步骤直接 <del><strong>萎缩</strong></del> <img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/moji/%E6%8A%95%E9%99%8D.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt> </p><p><img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/postpic/20200629140241.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>后来,促使我改变主意的,是我得知中考之后放假三天接着上课[高中],我***,然后突然想起来博客不方便更新,接着手一抖,把博客的Repo删掉了.</p><p>…</p><p>既然删了，那么就这么干吧。</p><p>其实后来发现这并不困难，只是我刚开始想多了而已。</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>Travis CI是在软件开发领域中的一个在线的，分布式的持续集成服务，用来构建及测试在GitHub托管的代码。这个软件的代码同时也是开源的，可以在GitHub上下载到，</p></blockquote><p>实际上你会发现，当你把博客Push到Github上时，你的计算机会在NodeJS环境下生成静态文件，然后push到Github。这些步骤其实完全可以用Travis CI做到。</p><p>最好在 <code>source</code> 下新建一个 <code>CNAME</code> 文件,并将绑定的域名写进去,不然直接在 <code>gh-page</code> 分支里弄Travis-ci会覆盖掉的.</p><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><h2 id="本地搭建环境"><a href="#本地搭建环境" class="headerlink" title="本地搭建环境"></a>本地搭建环境</h2><p>这一步必不可少，额具体方法网上一搜一大堆，这里就不说了。请注意，最好事先选好主题和插件，配置完成后自己测试一下。完毕后进入下一步。这里不在演示了【毕竟搭建环境与此博文几乎无关】</p><h2 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h2><p>默认情况下，直接在hexo博客根目录上链接repo上传，不会把 <code>node_modules/</code> 上传上去，因为 <code>.gitignore</code> 中包含这么一行：</p><p><img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/postpic/20200629140732.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>但是当时以为我拓展是不能上传的，于是手一滑，删掉那一行，上传上去了。</p><p>结果后来发现这就是个错误的选择。</p><ol><li><p><code>node_modules/</code> 中，文件比较小</p></li><li><p><code>node_modules/</code> 中，文件比较多</p></li></ol><p>所以：</p><ol start="3"><li><code>node_modules/</code> 中，文件比较碎</li></ol><p>嗯，<img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/moji/stick_38.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p><img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/postpic/20200629141017.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>我 <code>git add .</code> 了一下,它运算了半小时, <code>git commit</code> 又花了半小时,幸好<code>git push</code> 是打包上去的,不然我估计又要花半个小时.</p><p><img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/postpic/20200629141259.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>结果戏剧性的是,当我去看travis-ci部署记录时,我发现:</p><p><img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/postpic/20200629141542.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p><img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/moji/tx.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><blockquote><p>所以,还没用Travis-ci的同学,请不要手贱删掉 <code>.gitignore</code> 中的 <code>node_modules/</code></p></blockquote><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><blockquote><p>这里暂时不说私有怎么部署,这里讲的是PublicRepo.</p></blockquote><h3 id="1-注册travis-ci-org"><a href="#1-注册travis-ci-org" class="headerlink" title="1.注册travis-ci.org"></a>1.注册travis-ci.org</h3><p>前往 [<a href="https://travis-ci.org]" target="_blank" rel="noopener">https://travis-ci.org]</a> 用Github账号注册 <strong>注意了啊,注意了啊,</strong> 是 <code>.org</code> 而不是 <code>.com</code> ! 鬼知道我在这上面浪费了多少时间! <code>travis-ci.org</code> 是免费给公开repo部署的,<code>travis-ci.com</code> 是收费的,但是 <code>travis-ci.com</code> 却是可以绑定并免费部署公开Repo的.最有问题的是这两个网站其中一个绑定repo后,另一个就不能绑定了!! 害得我以为是缓存搞出来的事,搞了半天没解决,一看地址栏人都傻了.<img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/moji/tx.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><h3 id="2-绑定travis"><a href="#2-绑定travis" class="headerlink" title="2.绑定travis"></a>2.绑定travis</h3><p> 前往 [<a href="https://github.com/marketplace/travis-ci]" target="_blank" rel="noopener">https://github.com/marketplace/travis-ci]</a> 绑定travis-ci到你的github后 继续前往 <a href="https://github.com/settings/installations" target="_blank" rel="noopener">GitHub 的 Applications settings</a> ,点击 <code>Travis CI</code>配置你的repo能被TravisCI访问 </p><p><img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/postpic/20200629142607.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><h3 id="3-新建Token"><a href="#3-新建Token" class="headerlink" title="3.新建Token"></a>3.新建Token</h3><p>前往 GitHub <a href="https://github.com/settings/tokens" target="_blank" rel="noopener">新建 Personal Access Token</a> </p><p>新建一个Token:</p><p><img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/postpic/20200629142812.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>然而请注意,官方文档里说只需勾选 <code>repo</code> 全部权限即可,但是据我测试,<strong>只勾选则会导致401验证错误</strong>.似乎还要勾选 <code>read:public_key</code> 和 <code>read:user</code> ,当然如果你足够懒,你也可以全勾上, <strong>但请不要把Token泄露出去</strong>,否则你的Github就不太好使了.</p><p>点击生成Token：</p><p><img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/postpic/20200629143305.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>记得复制下来保存！不然下次你就看不到你的Token了！</p><h3 id="4-修改Repo"><a href="#4-修改Repo" class="headerlink" title="4.修改Repo"></a>4.修改Repo</h3><p>进入Repo的 <strong>Master</strong> 分支，新建一个 <code>.travis.yml</code> ，里面塞上：</p><div class="hljs"><pre><code class="hljs yml"><span class="hljs-attr">sudo:</span> <span class="hljs-literal">false</span><span class="hljs-attr">language:</span> <span class="hljs-string">node_js</span><span class="hljs-attr">node_js:</span>  <span class="hljs-bullet">-</span> <span class="hljs-number">10</span> <span class="hljs-comment"># use nodejs v10 LTS</span><span class="hljs-attr">cache:</span> <span class="hljs-string">npm</span><span class="hljs-attr">branches:</span>  <span class="hljs-attr">only:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">master</span> <span class="hljs-comment"># build master branch only</span><span class="hljs-attr">script:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">hexo</span> <span class="hljs-string">generate</span> <span class="hljs-comment"># generate static files</span><span class="hljs-attr">deploy:</span>  <span class="hljs-attr">provider:</span> <span class="hljs-string">pages</span>  <span class="hljs-attr">skip-cleanup:</span> <span class="hljs-literal">true</span>  <span class="hljs-attr">github-token:</span> <span class="hljs-string">$GH_TOKEN</span>  <span class="hljs-attr">keep-history:</span> <span class="hljs-literal">true</span>  <span class="hljs-attr">on:</span>    <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span>  <span class="hljs-attr">local-dir:</span> <span class="hljs-string">public</span></code></pre></div><p>对,改都不要改,就这么塞进去.</p><h3 id="5-Token导入Travis-ci"><a href="#5-Token导入Travis-ci" class="headerlink" title="5.Token导入Travis-ci"></a>5.Token导入Travis-ci</h3><p>Token很重要,你必须要告诉Travis-ci,因为它要获取对你的repo的写入权,但你也不能明文写在Repo里面,因为别人看得到.</p><p>所以,在 [### 4.修改Repo] 中,<code>github-token:</code> 后面跟着的不是明文,而是变量  <code>$GH_TOKEN</code>.</p><p>进入 [<a href="https://travis-ci.org/github/{用户名}/{仓库名}/settings]" target="_blank" rel="noopener">https://travis-ci.org/github/{用户名}/{仓库名}/settings]</a> 中,看到 <strong>Environment Variables</strong> ,Name选择 <code>GH_TOKEN</code> ,Value把[### 3.新建Token] 中的Token粘贴到里面去.BRANCH直接默认.</p><p><strong>特别注意!,将后面DISPLAY VALUE IN BUILD LOG弄成灰色,不然你的Token将会公开!</strong>,如果你不慎公开Token,请前往GithubPersonalToken删除并重新生成一个Token!</p><p>最终应该是这样子的:</p><p><img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/postpic/20200629145235.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>在日志里面,搜索Token,应该是这样子的:</p><div class="hljs"><pre><code class="hljs undefined">$ ex<span class="hljs-keyword">port</span> GH_TOKEN=[secure]</code></pre></div><h3 id="6-打开触发器"><a href="#6-打开触发器" class="headerlink" title="6.打开触发器"></a>6.打开触发器</h3><p>前往 <a href="https://travis-ci.org/account/repositories" target="_blank" rel="noopener">https://travis-ci.org/account/repositories</a>,打开目标Repo后面的按钮:</p><p><img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/postpic/20200629145630.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><h3 id="7-触发Travis-ci"><a href="#7-触发Travis-ci" class="headerlink" title="7.触发Travis-ci"></a>7.触发Travis-ci</h3><p>修改文件或新建Readme,让Travis-ci触发并开始工作.</p><p>比如说我更新 <code>留言板.md</code> ,Github上一更新,Travis-ci自动开始工作:</p><p><img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/postpic/20200629150414.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p><img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/postpic/20200629150525.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p><img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/postpic/20200629150600.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt="麻烦无视左上角的亮度调节"></p><p><img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/postpic/20200629152935.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>本次日志地址 <a href="https://api.travis-ci.org/v3/job/703061869/log.txt" target="_blank" rel="noopener">https://api.travis-ci.org/v3/job/703061869/log.txt</a></p><h3 id="8-以后"><a href="#8-以后" class="headerlink" title="8.以后"></a>8.以后</h3><p>更新博客直接在Github上更改，或者写好之后直接上传，或者pull到本地写好后push到Github，此后操作用户无需本地使用Hexo，也不用调整Travis-ci，安心写博客吧！</p><h1 id="草稿问题"><a href="#草稿问题" class="headerlink" title="草稿问题"></a>草稿问题</h1><p>其实这个比较简单，在修改时新建一个branch，名字叫 <code>drafts</code> ,由于 <code>.travis.yml</code> 规定只捕获 <code>master</code> ,草稿分支不会触发，修改的时候全部在drafts上修改，修改好了直接PullRequest，完事！</p><p>*<em>这么干以后,一定要注意,以后所有修改无论大小,都必须先在  <code>drafts</code> 里修改,然后发起PR,然后合并.不然直接在 <code>master</code> 里修改有可能会导致无法合并! *</em></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>总之，这样就可以安心用手机或者在学校更新Blog了！</p><p><img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/moji/stick_54.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Hexo作为静态博客，好处相当明显，开销少，并且对于那种DDosS和CC套上CDN毅然不动。当然，最蛋疼的莫过于更新了，每次在自己电脑上辛辛苦苦码好字，一个push，hexo绿色光芒在命令提示符上闪烁着光芒，突然发现把仓库名字 &lt;code&gt;ChenYFan&lt;/code&gt; 打</summary>
      
    
    
    
    <category term="好方法" scheme="https://blog.cyfan.top/categories/好方法/"/>
    
    
    <category term="Hexo" scheme="https://blog.cyfan.top/tags/Hexo/"/>
    
    <category term="Travis-CI" scheme="https://blog.cyfan.top/tags/Travis-CI/"/>
    
    <category term="在线更新" scheme="https://blog.cyfan.top/tags/在线更新/"/>
    
    <category term="奇淫巧计" scheme="https://blog.cyfan.top/tags/奇淫巧计/"/>
    
  </entry>
  
  <entry>
    <title>通过CloudFlareAPI获取用户侧信息</title>
    <link href="https://blog.cyfan.top/p/a7d0d7f8.html"/>
    <id>https://blog.cyfan.top/p/a7d0d7f8.html</id>
    <published>2020-06-28T00:30:00.000Z</published>
    <updated>2022-01-16T12:23:54.551Z</updated>
    
    <content type="html"><![CDATA[<p>噫，中考结束了，心中一块大石头总算碎了。虽然说考上提前批中考考不考无所谓，但是回去一次模拟考直接把我考傻了，太烂了<img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/moji/%E8%82%BF%E5%8C%85.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt>,以前初一不学习的时候都没有这么烂。啊么学习两星期，中考一考，今年理科超级简单，欸，这样理科分数拉不开了，啧啧啧，理科生的末日。</p><p>因为人大多数时间在学校，不太方便用自带hexopush到Github，一是博客文件同步不方便，二是如果有个小错误就很抓狂，所以呢，以前的打算是部署到vps，通过hexo+nginx实现访问，不过可能是人比较傻，一直没搞好，而且这种免费小鸡说炸就炸，不保险，还是跟着<a href="https://hexo.io/zh-cn/docs/github-pages" target="_blank" rel="noopener">hexo官方文档</a> 用Travis-ci+Github实现在线自动部署,以后更新也方便点<img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/moji/%E5%9D%90%E7%AD%89.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>好了好了，不说了，今天简单讲一下如何用CloudFlare自带的API获取用户信息。</p><h1 id="cdn-cgi-trace"><a href="#cdn-cgi-trace" class="headerlink" title="/cdn-cgi/trace"></a>/cdn-cgi/trace</h1><p>刚开始建立博客的时候，也是想过显示用户ip地址的，但网上的教程大多都是用搜狐新浪的js，而且很早就过期了。所以也就搁着迟迟没有解决。</p><p>后来偶然间知道CloudFlare有个比较神奇的技术，在部署在CloudFlare上的网站，域名后面加上<code>/cdn-cgi/trace</code>就可以获得用户侧信息，例如<code>https://blog.cyfan.top/cdn-cgi/trace</code>：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attr">fl</span>=<span class="hljs-number">23</span>f2**<span class="hljs-attr">h</span>=blog.cyfan.top<span class="hljs-attr">ip</span>=<span class="hljs-number">39.182</span>.***.***<span class="hljs-attr">ts</span>=<span class="hljs-number">15933078</span>**.***<span class="hljs-attr">visit_scheme</span>=https<span class="hljs-attr">uag</span>=Mozilla/<span class="hljs-number">5.0</span> (Windows NT <span class="hljs-number">10.0</span><span class="hljs-comment">; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36</span><span class="hljs-attr">colo</span>=HKG<span class="hljs-attr">http</span>=http/<span class="hljs-number">2</span><span class="hljs-attr">loc</span>=CN<span class="hljs-attr">tls</span>=TLSv1.<span class="hljs-number">3</span><span class="hljs-attr">sni</span>=plaintext<span class="hljs-attr">warp</span>=<span class="hljs-literal">off</span></code></pre></div><p>[对于部分隐私替换掉，请见谅]</p><p>差不多都全了，<code>ip</code>、<code>uag</code>、<code>colo</code>、<code>loc</code>、<code>tls</code>这些数据都是我们所需要的，那么，怎么把这些数据迁移到网页上呢？</p><h1 id="答案是：JavaScript"><a href="#答案是：JavaScript" class="headerlink" title="答案是：JavaScript"></a>答案是：JavaScript</h1><p>首先要引入Jquery，如果你的网页上已经有Jquery，那么就不必再次引入：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://npm.elemecdn.com/jquery@3.2.1/dist/jquery.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p>接着加入JS[需在Jquery以下,否则会报错]:</p><div class="hljs"><pre><code class="hljs js">&lt;script&gt;getCDNinfo = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;$.ajax(&#123;<span class="hljs-attr">url</span>: <span class="hljs-string">"https://cdn.cyfan.top/cdn-cgi/trace"</span>,<span class="hljs-attr">success</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data, status</span>) </span>&#123;<span class="hljs-keyword">let</span> areas = <span class="hljs-string">"Antananarivo, Madagascar - (TNR);Cape Town, South Africa - (CPT);Casablanca, Morocco - (CMN);Dar Es Salaam, Tanzania - (DAR);Djibouti City, Djibouti - (JIB);Durban, South Africa - (DUR);Johannesburg, South Africa - (JNB);Kigali, Rwanda - (KGL);Lagos, Nigeria - (LOS);Luanda, Angola - (LAD);Maputo, MZ - (MPM);Mombasa, Kenya - (MBA);Port Louis, Mauritius - (MRU);Réunion, France - (RUN);Bangalore, India - (BLR);Bangkok, Thailand - (BKK);Bandar Seri Begawan, Brunei - (BWN);Cebu, Philippines - (CEB);Chengdu, China - (CTU);Chennai, India - (MAA);Chittagong, Bangladesh - (CGP);Chongqing, China - (CKG);Colombo, Sri Lanka - (CMB);Dhaka, Bangladesh - (DAC);Dongguan, China - (SZX);Foshan, China - (FUO);Fuzhou, China - (FOC);Guangzhou, China - (CAN);Hangzhou, China - (HGH);Hanoi, Vietnam - (HAN);Hengyang, China - (HNY);Ho Chi Minh City, Vietnam - (SGN);Hong Kong - (HKG);Hyderabad, India - (HYD);Islamabad, Pakistan - (ISB);Jakarta, Indonesia - (CGK);Jinan, China - (TNA);Karachi, Pakistan - (KHI);Kathmandu, Nepal - (KTM);Kolkata, India - (CCU);Kuala Lumpur, Malaysia - (KUL);Lahore, Pakistan - (LHE);Langfang, China - (NAY);Luoyang, China - (LYA);Macau - (MFM);Malé, Maldives - (MLE);Manila, Philippines - (MNL);Mumbai, India - (BOM);Nagpur, India - (NAG);Nanning, China - (NNG);New Delhi, India - (DEL);Osaka, Japan - (KIX);Phnom Penh, Cambodia - (PNH);Qingdao, China - (TAO);Seoul, South Korea - (ICN);Shanghai, China - (SHA);Shenyang, China - (SHE);Shijiazhuang, China - (SJW);Singapore, Singapore - (SIN);Suzhou, China - (SZV);Taipei - (TPE);Thimphu, Bhutan - (PBH);Tianjin, China - (TSN);Tokyo, Japan - (NRT);Ulaanbaatar, Mongolia - (ULN);Vientiane, Laos - (VTE);Wuhan, China - (WUH);Wuxi, China - (WUX);Xi'an, China - (XIY);Yerevan, Armenia - (EVN);Zhengzhou, China - (CGO);Zuzhou, China - (CSX);Amsterdam, Netherlands - (AMS);Athens, Greece - (ATH);Barcelona, Spain - (BCN);Belgrade, Serbia - (BEG);Berlin, Germany - (TXL);Brussels, Belgium - (BRU);Bucharest, Romania - (OTP);Budapest, Hungary - (BUD);Chișinău, Moldova - (KIV);Copenhagen, Denmark - (CPH);Cork, Ireland -  (ORK);Dublin, Ireland - (DUB);Düsseldorf, Germany - (DUS);Edinburgh, United Kingdom - (EDI);Frankfurt, Germany - (FRA);Geneva, Switzerland - (GVA);Gothenburg, Sweden - (GOT);Hamburg, Germany - (HAM);Helsinki, Finland - (HEL);Istanbul, Turkey - (IST);Kyiv, Ukraine - (KBP);Lisbon, Portugal - (LIS);London, United Kingdom - (LHR);Luxembourg City, Luxembourg - (LUX);Madrid, Spain - (MAD);Manchester, United Kingdom - (MAN);Marseille, France - (MRS);Milan, Italy - (MXP);Moscow, Russia - (DME);Munich, Germany - (MUC);Nicosia, Cyprus - (LCA);Oslo, Norway - (OSL);Paris, France - (CDG);Prague, Czech Republic - (PRG);Reykjavík, Iceland - (KEF);Riga, Latvia - (RIX);Rome, Italy - (FCO);Saint Petersburg, Russia - (LED);Sofia, Bulgaria - (SOF);Stockholm, Sweden - (ARN);Tallinn, Estonia - (TLL);Thessaloniki, Greece - (SKG);Vienna, Austria - (VIE);Vilnius, Lithuania - (VNO);Warsaw, Poland - (WAW);Zagreb, Croatia - (ZAG);Zürich, Switzerland - (ZRH);Arica, Chile - (ARI);Asunción, Paraguay - (ASU);Bogotá, Colombia - (BOG);Buenos Aires, Argentina - (EZE);Curitiba, Brazil - (CWB);Fortaleza, Brazil - (FOR);Guatemala City, Guatemala - (GUA);Lima, Peru - (LIM);Medellín, Colombia - (MDE);Panama City, Panama - (PTY);Porto Alegre, Brazil - (POA);Quito, Ecuador - (UIO);Rio de Janeiro, Brazil - (GIG);São Paulo, Brazil - (GRU);Santiago, Chile - (SCL);Willemstad, Curaçao - (CUR);St. George's, Grenada - (GND);Amman, Jordan - (AMM);Baghdad, Iraq - (BGW);Baku, Azerbaijan - (GYD);Beirut, Lebanon - (BEY);Doha, Qatar - (DOH);Dubai, United Arab Emirates - (DXB);Kuwait City, Kuwait - (KWI);Manama, Bahrain - (BAH);Muscat, Oman - (MCT);Ramallah - (ZDM);Riyadh, Saudi Arabia - (RUH);Tel Aviv, Israel - (TLV);Ashburn, VA, United States - (IAD);Atlanta, GA, United States - (ATL);Boston, MA, United States - (BOS);Buffalo, NY, United States - (BUF);Calgary, AB, Canada - (YYC);Charlotte, NC, United States - (CLT);Chicago, IL, United States - (ORD);Columbus, OH, United States - (CMH);Dallas, TX, United States - (DFW);Denver, CO, United States - (DEN);Detroit, MI, United States - (DTW);Honolulu, HI, United States - (HNL);Houston, TX, United States - (IAH);Indianapolis, IN, United States - (IND);Jacksonville, FL, United States - (JAX);Kansas City, MO, United States - (MCI);Las Vegas, NV, United States - (LAS);Los Angeles, CA, United States - (LAX);McAllen, TX, United States - (MFE);Memphis, TN, United States - (MEM);Mexico City, Mexico - (MEX);Miami, FL, United States - (MIA);Minneapolis, MN, United States - (MSP);Montgomery, AL, United States - (MGM);Montréal, QC, Canada - (YUL);Nashville, TN, United States - (BNA);Newark, NJ, United States - (EWR);Norfolk, VA, United States - (ORF);Omaha, NE, United States - (OMA);Philadelphia, United States - (PHL);Phoenix, AZ, United States - (PHX);Pittsburgh, PA, United States - (PIT);Port-Au-Prince, Haiti - (PAP);Portland, OR, United States - (PDX);Queretaro, MX, Mexico - (QRO);Richmond, Virginia - (RIC);Sacramento, CA, United States - (SMF);Salt Lake City, UT, United States - (SLC);San Diego, CA, United States - (SAN);San Jose, CA, United States - (SJC);Saskatoon, SK, Canada - (YXE);Seattle, WA, United States - (SEA);St. Louis, MO, United States - (STL);Tampa, FL, United States - (TPA);Toronto, ON, Canada - (YYZ);Vancouver, BC, Canada - (YVR);Tallahassee, FL, United States - (TLH);Winnipeg, MB, Canada - (YWG);Adelaide, SA, Australia - (ADL);Auckland, New Zealand - (AKL);Brisbane, QLD, Australia - (BNE);Melbourne, VIC, Australia - (MEL);Noumea, New caledonia - (NOU);Perth, WA, Australia - (PER);Sydney, NSW, Australia - (SYD)"</span>.split(<span class="hljs-string">";"</span>);<span class="hljs-keyword">let</span> area = data.split(<span class="hljs-string">"colo="</span>)[<span class="hljs-number">1</span>].split(<span class="hljs-string">"\n"</span>)[<span class="hljs-number">0</span>];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; areas.length; i++) &#123;<span class="hljs-keyword">if</span> (areas[i].indexOf(area) != <span class="hljs-number">-1</span>) &#123;<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"cdn"</span>).innerHTML = areas[i];<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"ip"</span>).innerHTML = data.split(<span class="hljs-string">"ip="</span>)[<span class="hljs-number">1</span>].split(<span class="hljs-string">"\n"</span>)[<span class="hljs-number">0</span>];<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"httpos"</span>).innerHTML = data.split(<span class="hljs-string">"visit_scheme="</span>)[<span class="hljs-number">1</span>].split(<span class="hljs-string">"\n"</span>)[<span class="hljs-number">0</span>];<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"uag"</span>).innerHTML = data.split(<span class="hljs-string">"uag="</span>)[<span class="hljs-number">1</span>].split(<span class="hljs-string">"\n"</span>)[<span class="hljs-number">0</span>];<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"http"</span>).innerHTML = data.split(<span class="hljs-string">"http="</span>)[<span class="hljs-number">1</span>].split(<span class="hljs-string">"\n"</span>)[<span class="hljs-number">0</span>];<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"loc"</span>).innerHTML = data.split(<span class="hljs-string">"loc="</span>)[<span class="hljs-number">1</span>].split(<span class="hljs-string">"\n"</span>)[<span class="hljs-number">0</span>];<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"tls"</span>).innerHTML = data.split(<span class="hljs-string">"tls="</span>)[<span class="hljs-number">1</span>].split(<span class="hljs-string">"\n"</span>)[<span class="hljs-number">0</span>];<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"warp"</span>).innerHTML = data.split(<span class="hljs-string">"warp="</span>)[<span class="hljs-number">1</span>].split(<span class="hljs-string">"\n"</span>)[<span class="hljs-number">0</span>];<span class="hljs-keyword">break</span>;&#125;&#125;&#125;&#125;)&#125;$(<span class="hljs-built_in">document</span>).ready(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;getCDNinfo();    <span class="hljs-comment">//页面加载完毕就获取CDN信息</span>&#125;);&lt;<span class="hljs-regexp">/script&gt;</span></code></pre></div><p>这个脚本会获取大部分用户信息并解析所链接节点位置,默认链接到<code>cdn.cyfan.top</code>，已通过<code>CORS</code>,接着在网页需要添加的地方增加html代码:</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>当前CDN节点: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"cdn"</span>&gt;</span>【未知】<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">br</span>&gt;</span>你的ip: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"ip"</span>&gt;</span>【未知】<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">br</span>&gt;</span>你当前以: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"httpos"</span>&gt;</span>【未知】<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>形式访问我们的网站<span class="hljs-tag">&lt;/<span class="hljs-name">br</span>&gt;</span>你的User-Agent: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"uag"</span>&gt;</span>【未知】<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">br</span>&gt;</span>你以: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"http"</span>&gt;</span>【未知】<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>形式访问本网站<span class="hljs-tag">&lt;/<span class="hljs-name">br</span>&gt;</span>你的所在国家/地区: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"loc"</span>&gt;</span>【未知】<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">br</span>&gt;</span>你以: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"tls"</span>&gt;</span>【未知】<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">br</span>&gt;</span>你是否以Warp访问我们: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"warp"</span>&gt;</span>【未知】<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre></div><p>[可以根据需要增减]，一般情况下简单获取写成这样：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>当前CDN节点: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"cdn"</span>&gt;</span>【未知】<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> |你的ip: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"ip"</span>&gt;</span>【未知】<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> |你的所在国家/地区: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"loc"</span>&gt;</span>【未知】 <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre></div><p>结果应该类似这样:</p><p><img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/postpic/20200628094419.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>划到页底即可看到。</p><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>OHHH，又水了一篇，下次讲讲如何部署博客到Travis-ci上。溜了溜了 <img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/moji/yhuaji.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;噫，中考结束了，心中一块大石头总算碎了。虽然说考上提前批中考考不考无所谓，但是回去一次模拟考直接把我考傻了，太烂了&lt;img src=&quot;https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/moji/%E8%82%BF%E5%8C%8</summary>
      
    
    
    
    <category term="屌代码" scheme="https://blog.cyfan.top/categories/屌代码/"/>
    
    
    <category term="CloudFlare" scheme="https://blog.cyfan.top/tags/CloudFlare/"/>
    
    <category term="API" scheme="https://blog.cyfan.top/tags/API/"/>
    
    <category term="IP" scheme="https://blog.cyfan.top/tags/IP/"/>
    
    <category term="用户信息" scheme="https://blog.cyfan.top/tags/用户信息/"/>
    
  </entry>
  
  <entry>
    <title>这一个半月，我干了什么</title>
    <link href="https://blog.cyfan.top/p/cc675020.html"/>
    <id>https://blog.cyfan.top/p/cc675020.html</id>
    <published>2020-05-30T08:06:00.000Z</published>
    <updated>2022-01-16T12:23:54.551Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/moji/wjlkdhxs.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>啊，期中考试终于考完了，现在心里想的都是司马脸，<img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/moji/huaji.gif" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>距离上一次更新已经将近1个半月了，赶在5月小尾巴发一篇博文。当然，这个月维护还是做到了，只不过太忙没更新而已。</p><p>过来扯扯这个月发生了什么。</p><h1 id="计算机方面"><a href="#计算机方面" class="headerlink" title="计算机方面"></a>计算机方面</h1><h2 id="网站方面"><a href="#网站方面" class="headerlink" title="网站方面"></a>网站方面</h2><h3 id="VPS"><a href="#VPS" class="headerlink" title="VPS"></a>VPS</h3><p>入手了一台德国VPS，还得感谢这位老兄：</p><p><a href="https://blog.qwqdanchun.cn/archives/1001" target="_blank" rel="noopener">簞純-EUserv 德国永久免费VPS申请</a></p><p>试了一下，性能略差，连IPV4都没有，就当是学习吧，现在就是拿来玩玩的，毕竟我大多数情况下基本是ServerLess。</p><p>以后打算全站迁移到一台VPS上，当然习惯用Hexo了，毕竟Hexo-Admin还是很给力的。</p><h3 id="图床："><a href="#图床：" class="headerlink" title="图床："></a>图床：</h3><p>我当场裂开。</p><p>之前全放在Github上，但是，但是这会导致多线程并发是Worker抛出异常，速度还很慢。而且很大，Github那么恐怖的大小：<img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/post/206.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>三个星期前开始迁移，刚开始采用了GoogleDrive+<br>GDIndex，上学去的时候，加载速度还不错，结果一到学校，自己打开，爆一大堆404.</p><p>Workers自然也出大问题<br><img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/post/pasted-205.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>后来了解到，谷歌网盘在每每输出一个文件，都会来一次销魂的杀毒，一张10kb的图片，杀毒将近10s，Worker超时30s直接返回404！！！？？？，我当时心里就开始表演天皇meta的showtime了。<img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/moji/%E5%96%B7%E8%A1%80.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>所以后来又采用腾讯云免费SCF额度+OneDrive那可怜的5GB制作图床，好歹也能正常加载，但是OMp的工作原理和GI不一样，GoogleDrive在国内那是不可访问的，所以最终还是采用了反向代理，但是OneDrive是可以滴，所以OMp采用的是301跳转。燃鹅，直连速度和延迟相当的感人，在多线程并发时经常超时。<img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/moji/tx.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>当时整个人都裂开了。</p><p>所以，最终解决办法就是，氪金！！！！！！</p><p>腾讯云COS（相当于阿里云OSS）+CDN，当然因为没备案所以放在Hongkong，但是腾讯云有个暗坑，COS绑定自定义域名<del>md</del>居然不给直接开SSL，非得要套层CDN才行，这不是明摆着坑钱么。计算下来，每天平均支出0.03￥.</p><p>肉疼。<img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/moji/s.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>好在腾讯COS也有客户端，上传文件至少没那么麻烦。</p><p><img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/post/207.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>不过话说回来，最近香港局势确实很不稳定，我现在根本无法直连Hongkong的COSBucket，CDN套就套吧，只不过神奇地绕道美国都是什么奇葩玩意，害得我只能A到日本，出口居然是Amazon。</p><h3 id="评论系统"><a href="#评论系统" class="headerlink" title="评论系统"></a>评论系统</h3><p>又是一个当场炸裂的东西。</p><p>Gitalk本身链接api.github.com就是一个相当蛋疼的事情。</p><p><img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/post/205.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>我也尝试着做过类似于DiqusJS的反向代理的尝试，可是到最后一步Github回调地址又给我强制跳到api.github.com，我当时人都傻了。最后实在头疼，换成了Valine。当然找了个魔改版本，看起来还不错。<del>【这一次再也不会造成30天无访问自动归档这种奇异的事情了】</del></p><p><img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/post/208.jpg" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>两个魔改后的JS地址</p><div class="hljs"><pre><code class="hljs html">https://npm.elemecdn.com/chenyfan-oss@1.0.0/js/av-min.jshttps://npm.elemecdn.com/chenyfan-oss@1.0.0/js/valine.min.js</code></pre></div><h2 id="编程方面"><a href="#编程方面" class="headerlink" title="编程方面"></a>编程方面</h2><p>艹，VB轮到我这一届居然不考，<img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/moji/qgbf.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt>，害得我只能硬啃C++。考试还行，就那附加题做不出来，一道高精乘法，居然忘记了<code>strlen()</code>这个函数，当时想撞墙的心态都有了。</p><h1 id="学习方面"><a href="#学习方面" class="headerlink" title="学习方面"></a>学习方面</h1><p>考完了，我完了。</p><p>数学150分扣46分是什么鬼？？？？？？？语文五道选择题错三道又是什么鬼？？？？？？？？</p><p><span class="heimu">还好物理只扣10分，化学一分没扣，计算机也只是附加题最后一道不会写而已</span></p><p>欸欸欸欸欸欸欸，感觉我要垫底。</p><h1 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h1><p>好好学习，天天向上！</p><p>好了好了，继续潜水<img src="https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/moji/%E6%97%A0%E5%A5%88.png" srcset="https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif" alt></p><p>滑稽</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://npm.elemecdn.com/chenyfan-oss@1.0.0/pic/moji/wjlkdhxs.jpg&quot; srcset=&quot;https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/</summary>
      
    
    
    
    <category term="随心记" scheme="https://blog.cyfan.top/categories/随心记/"/>
    
    
    <category term="日常" scheme="https://blog.cyfan.top/tags/日常/"/>
    
    <category term="总结" scheme="https://blog.cyfan.top/tags/总结/"/>
    
  </entry>
  
</feed>
